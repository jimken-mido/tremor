"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[986],{37115:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=r(58168),a=(r(96540),r(15680));r(40281);const o={id:"overview",title:"Architecture Overview",sidebar_position:100},i="Architecture Overview",s={unversionedId:"overview",id:"version-0.11/overview",title:"Architecture Overview",description:"This is a short architectural overview of Tremor.",source:"@site/versioned_docs/version-0.11/overview.md",sourceDirName:".",slug:"/overview",permalink:"/docs/0.11/overview",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/overview.md",tags:[],version:"0.11",sidebarPosition:100,frontMatter:{id:"overview",title:"Architecture Overview",sidebar_position:100},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Tremor",permalink:"/docs/0.11/"},next:{title:"Constraints and Limitations",permalink:"/docs/0.11/ConstraintsLimitations"}},l={},d=[{value:"Scope",id:"scope",level:2},{value:"Goodness of fit",id:"goodness-of-fit",level:2},{value:"Tremor URLs",id:"tremor-urls",level:2},{value:"Runtime model",id:"runtime-model",level:2},{value:"Processing model",id:"processing-model",level:3},{value:"Event ordering",id:"event-ordering",level:2},{value:"Pipeline Model",id:"pipeline-model",level:2},{value:"Dataflow",id:"dataflow",level:3},{value:"SignalFlow",id:"signalflow",level:3},{value:"Contraflow",id:"contraflow",level:3},{value:"Guaranteed delivery",id:"guaranteed-delivery",level:2},{value:"Runtime facilities",id:"runtime-facilities",level:2},{value:"Conductor",id:"conductor",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Data model",id:"data-model",level:2},{value:"Distribution model",id:"distribution-model",level:3},{value:"Client/Server",id:"clientserver",level:3}],p={toc:d},m="wrapper";function c(e){let{components:t,...r}=e;return(0,a.yg)(m,(0,n.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"architecture-overview"},"Architecture Overview"),(0,a.yg)("p",null,"This is a short architectural overview of Tremor."),(0,a.yg)("h2",{id:"scope"},"Scope"),(0,a.yg)("p",null,"We cover the runtime, data and distribution model of Tremor from 50,000 feet."),(0,a.yg)("h2",{id:"goodness-of-fit"},"Goodness of fit"),(0,a.yg)("p",null,"Tremor is designed for high volume messaging environments and is good for:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Man in the middle bridging - Tremor is designed to bridge asynchronous upstream sources with synchronous downstream sinks. More generally, Tremor excels at intelligently bridging from sync/async to async/sync so that message flows can be classified, dimensioned, segmented, routed using user defined logic whilst providing facilities to handle back-pressure and other hard distributed systems problems on behalf of its operators.",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"For example - Log data distributed from Kafka to ElasticSearch via Logstash can introduce significant lag or delays as logstash becomes a publication bottleneck. Untimely, late delivery of log data to the network operations centre under severity zero or at/over capacity conditions reduces our ability to respond to major outage and other byzantine events in a timely fashion."))),(0,a.yg)("li",{parentName:"ul"},"In-flight redeployment - Tremor can be reconfigured via it's API allowing workloads to be migrated to/from new systems and logic to be retuned, reconfigured, or reconditioned without redeployment."),(0,a.yg)("li",{parentName:"ul"},"event processing - Tremor adopts many principles from DEBS ( Distributed Event Based Systems ), ESP ( Event Stream Processor ) and the CEP ( Complex Event Processing ) communities. However in its current state of evolution Tremor has an incomplete feature set in this regard. Over time Tremor MAY evolve as an ESP or CEP solution but this is an explicit non-goal of the project.")),(0,a.yg)("h2",{id:"tremor-urls"},"Tremor URLs"),(0,a.yg)("p",null,"Since Tremor v0.4, all internal artefacts and running instances of ",(0,a.yg)("strong",{parentName:"p"},"onramps"),", ",(0,a.yg)("strong",{parentName:"p"},"offramps")," and ",(0,a.yg)("strong",{parentName:"p"},"pipelines")," are dynamically configurable. The introduction of a dynamically configurable deployment model has resulted in the introduction of Tremor URLs."),(0,a.yg)("p",null,"The Tremor API is built around this URL and the configuration space it enshrines:"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Example URL"),(0,a.yg)("th",{parentName:"tr",align:null},"Description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor://localhost:9898/")),(0,a.yg)("td",{parentName:"tr",align:null},"A local Tremor instance",(0,a.yg)("br",null),(0,a.yg)("em",{parentName:"td"}," Accessible on the local host",(0,a.yg)("br",null))," REST API on port 9898 of the local host")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///")),(0,a.yg)("td",{parentName:"tr",align:null},"The current Tremor instance or 'self'")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///pipeline")),(0,a.yg)("td",{parentName:"tr",align:null},"A list of pipelines")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///pipeline/bob")),(0,a.yg)("td",{parentName:"tr",align:null},"The pipeline identified as bob")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///onramp/alice")),(0,a.yg)("td",{parentName:"tr",align:null},"The onramp identified as Alice")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///binding/talk")),(0,a.yg)("td",{parentName:"tr",align:null},"A binding that allows alice and bob to connect")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"tremor:///binding/talk/tls")),(0,a.yg)("td",{parentName:"tr",align:null},"An active conversation or instance of a talk between alice and bob")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null}),(0,a.yg)("td",{parentName:"tr",align:null})))),(0,a.yg)("p",null,"The Tremor REST API and configuration file formats also follow the same URL format."),(0,a.yg)("p",null,"In the case of configuration, a shorthand URL form is often used. In the configuration model, we discriminate artefacts by type, so it is often sufficient to infer the ",(0,a.yg)("inlineCode",{parentName:"p"},"tremor:///{artefact-kind}")," component when specifying ( configuring ) artefacts."),(0,a.yg)("p",null,"In bindings, however, we minimally need to use the full URL path component ( for example:",(0,a.yg)("inlineCode",{parentName:"p"},"/pipeline/01")," )."),(0,a.yg)("p",null,"At this time, the full URL form is not used in the configuration model."),(0,a.yg)("h2",{id:"runtime-model"},"Runtime model"),(0,a.yg)("p",null,"The Tremor runtime is composed of multiple internal components that communicate via queues across multiple threads of control managed/coordinated by a set of control plane component driven by the Tremor REST API."),(0,a.yg)("h3",{id:"processing-model"},"Processing model"),(0,a.yg)("p",null,"Tremor uses an async task model ontop of the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/stjepang/smol"},"smol runtime")," and\n",(0,a.yg)("a",{parentName:"p",href:"https://async.rs/"},"async-rs"),"."),(0,a.yg)("p",null,"Currently, the model is:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"A task is spawned per onramp"),(0,a.yg)("li",{parentName:"ul"},"A task is spawned per offramp"),(0,a.yg)("li",{parentName:"ul"},"A task is spawned per pipeline"),(0,a.yg)("li",{parentName:"ul"},"Tasks communicate via queues")),(0,a.yg)("p",null,"The Processing model is very likely to evolve over time as concurrency, threading, async and other primitives available in the rust ecosystem mature and evolve."),(0,a.yg)("h2",{id:"event-ordering"},"Event ordering"),(0,a.yg)("p",null,"Events generally flow from onramps, where they are ingested into the system, through pipelines, into offramps where they are pushed to external systems."),(0,a.yg)("p",null,"Tremor imposes causal event ordering over ingested events and processes events deterministically. This does not mean that Tremor imposes a total ordering over all ingested events, however ( ugh, because that is not tractable in a distributed system )."),(0,a.yg)("p",null,"Events flowing into Tremor from multiple onramps are considered independent. Events flowing from multiple clients into Tremor are also considered independent."),(0,a.yg)("p",null,"However, events sent by a ",(0,a.yg)("em",{parentName:"p"},"specific")," client through a ",(0,a.yg)("em",{parentName:"p"},"specific")," onramp into a ",(0,a.yg)("em",{parentName:"p"},"passthrough")," pipeline would flow through Tremor in their origin order and be passed to offramps in the same ",(0,a.yg)("em",{parentName:"p"},"origin")," order."),(0,a.yg)("p",null,"Requests from multiple independent sources over the same pipeline may arbitrarily interleave, but should not re-order."),(0,a.yg)("p",null,"In pipelines, events are processed in depth first order. Where Tremor operators have no intrinsic ordering ( such as a branch split ), Tremor internally ",(0,a.yg)("em",{parentName:"p"},"imposes")," an order."),(0,a.yg)("p",null,"Operator's may ",(0,a.yg)("em",{parentName:"p"},"arbitrarily")," reorder messages. For example, a windowed operator might batch multiple events into a single batch. An iteration operator could reverse the batch and forward individual unbatched events in an order that is the reverse of the original ingest order for that batch of events."),(0,a.yg)("p",null,"However, the engine itself does not re-order events. Events are handled and processed in a strictly deterministic order by design."),(0,a.yg)("h2",{id:"pipeline-model"},"Pipeline Model"),(0,a.yg)("p",null,"The core processing model of Tremor is based on a directed-acyclic-graph based dataflow model."),(0,a.yg)("p",null,"Tremor pipelines are a graph of vertices ( nodes, or operators ) with directed edges ( or connections, or links ) between operators in the graph."),(0,a.yg)("p",null,"Events from the outside world in a Tremor pipeline can only flow in one direction from inputs ( specific operators that connect pipeline operators to onramps ) via operators to outputs ( specific operators that connect pipeline operators to offramps)."),(0,a.yg)("p",null,"Operators process events and may produce ",(0,a.yg)("strong",{parentName:"p"},"zero or many")," output events for each event processed by the operator. As operators are the primary building block of Tremor processing logic they are designed for extension."),(0,a.yg)("p",null,"Tremor pipelines understand three different types of events:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Data events - these are data events delivered via onramps into a pipeline or to offramps from a pipeline. Most events that flow through a Tremor pipeline are of this type."),(0,a.yg)("li",{parentName:"ul"},"Signal events - these are synthetic events delivered by the Tremor runtime into a pipeline under certain conditions."),(0,a.yg)("li",{parentName:"ul"},"Contraflow events - these are synthetic events delivered by the Tremor runtime into a pipeline under certain conditions that are caused by the processing of events already in a Tremor system. Back-pressure events exploit contraflow.")),(0,a.yg)("h3",{id:"dataflow"},"Dataflow"),(0,a.yg)("p",null,"Data-flow events are the bread and butter of Tremor."),(0,a.yg)("p",null,"These are line of business data events ingested via onramps from external upstream systems, processed through pipelines and published downstream via offramps to downstream external systems."),(0,a.yg)("h3",{id:"signalflow"},"SignalFlow"),(0,a.yg)("p",null,"Transparent to pipeline authors, but visible to onramp, offramp and operator developers are signal events. Signal events are synthetic events generated by the tremor-runtime and system that can be exploited by operators for advanced event handling purposes."),(0,a.yg)("h3",{id:"contraflow"},"Contraflow"),(0,a.yg)("p",null,"A core conceit with distributed event-based systems arises due to their typically asynchronous nature. Tremor employs a relatively novel algorithm to handle back-pressure or other events that propagate ",(0,a.yg)("em",{parentName:"p"},"backwards")," through a pipeline."),(0,a.yg)("p",null,"But pipelines are directed-acyclic-graphs ( DAGs ), so how do we back-propagate events without introducing cycles?"),(0,a.yg)("p",null,"The answer is:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"There can be no cycles in a DAG"),(0,a.yg)("li",{parentName:"ul"},"DAGS are traversed in depth-first-search ( DFS ) order"),(0,a.yg)("li",{parentName:"ul"},"There can be no cycles in a DAG traversed in reverse-DFS order."),(0,a.yg)("li",{parentName:"ul"},"If we join a DAG d, with its mirrored ( reversed ) DAG d'",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"We get another DAG where",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"Every output in the DAG d, can continue propagating events in its reverse DAG d', without cycles though its d' mirrored input"),(0,a.yg)("li",{parentName:"ul"},"Branches in DAG d, become Combinators in DAG d'"),(0,a.yg)("li",{parentName:"ul"},"Combinators in DAG d, become Branches in DAG d'"),(0,a.yg)("li",{parentName:"ul"},"Any back-pressure or other events detected in the processing of existing events can result in a synthetic signalling event being injected into the reverse-DAG."))),(0,a.yg)("li",{parentName:"ul"},"We call the injected events 'contraflow' events because they move ",(0,a.yg)("em",{parentName:"li"},"backwards")," against the primary data flow."))),(0,a.yg)("li",{parentName:"ul"},"The cost or overhead of not injecting a contraflow event is zero"),(0,a.yg)("li",{parentName:"ul"},"The cost or overhead of an injected contraflow event ( in Tremor ) is minimised through pruning - for example - operators that are not contraflow aware do not need to receive or process contraflow events - Tremor optimises for this case."),(0,a.yg)("li",{parentName:"ul"},"We call the output-input pairs at the heart of contraflow the 'pivot point'")),(0,a.yg)("p",null,"Contraflow has been used in other event processing systems and was designed /invented by one of the members of the Tremor core team ( in a previous life )."),(0,a.yg)("p",null,"There are many other ways to handle back-pressure ( for example: those used by Spark, Storm, Hazelcast Jet, \u2026 ) but they are biasing for other nuances and tradeoffs than Tremor. Contraflow is far simpler to reason about and develop verifiable systems and code against as a user and puts a lot of the pressure for a good solution onto the Tremor project itself. Only time will tell\nwhich philosophy results in less pager duty!"),(0,a.yg)("p",null,"Although the contraflow mechanism ",(0,a.yg)("em",{parentName:"p"},"may")," seem complex, its far simpler than back-pressure handling by almost all other reasonable mechanisms and with far fewer negative side-effects and tradeoffs."),(0,a.yg)("h2",{id:"guaranteed-delivery"},"Guaranteed delivery"),(0,a.yg)("p",null,"Tremor supports guaranteed delivery as long as both onramps and offramps support it. Alternatively,\nthe ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-query/operators#qos::wal"},"qos::wal")," can be used to introduce a layer of Guaranteed\ndelivery for onramps that do not support it naturally."),(0,a.yg)("p",null,"The basic concept is that each event has a monotonically growing ID, once this ID is acknowledged\nas delivered all events with the provided ID or a lower Id are considered delivered. If an ID\nis marked as failed to deliver all events up until this ID will be replayed."),(0,a.yg)("h2",{id:"runtime-facilities"},"Runtime facilities"),(0,a.yg)("p",null,"Tremor's runtime is composed of a number of facilities that work together to provide service."),(0,a.yg)("h3",{id:"conductor"},"Conductor"),(0,a.yg)("p",null,"The Tremor API is a REST based API that allows Tremor operators to manage the lifecycle of onramps, offramps and pipelines deployed into a Tremor based system."),(0,a.yg)("p",null,"The set of facilities in the runtime that are related to service lifecycle, activation and management are often referred to collectively as the Tremor conductor or Tremor control plane."),(0,a.yg)("p",null,"These terms can be used interchangeably."),(0,a.yg)("p",null,"Operators CAN conduct or orchestrate one or many Tremor servers through its REST based API."),(0,a.yg)("p",null,"The API in turn interfaces with registry and repository facilities. Tremor distinguishes between artefacts and instances. Artefacts in Tremor have no runtime overhead."),(0,a.yg)("p",null,"Artefacts in Tremor are declarative specifications of:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Onramps - An onramp specification is a specific configuration of a supported onramp kind"),(0,a.yg)("li",{parentName:"ul"},"Offramps - An offramp specification is a specific configuration of a supported offramp kind"),(0,a.yg)("li",{parentName:"ul"},"Pipelines - A pipeline specification is a specific configuration of a pipeline graph"),(0,a.yg)("li",{parentName:"ul"},"Bindings - A binding specification describes how onramps, pipelines and offramps should be interconnected")),(0,a.yg)("p",null,"Artefacts can be thought of analagously to code. They are a set of instructions, rules or configurations. As such they are registered with Tremor via its API and stored in Tremor's artefact repository."),(0,a.yg)("p",null,"Deployment in Tremor, is achieved through a mapping artefact. The mapping artefact specifies how artefacts should be deployed into one or many runtime instances, activated, and connected to live instances of onramps or offramps."),(0,a.yg)("p",null,"In Tremor, publishing a mapping results in instances being deployed as a side-effect. By unpublishing or deleting a mapping instances are undeployed as a side-effect."),(0,a.yg)("h3",{id:"metrics"},"Metrics"),(0,a.yg)("p",null,"Metrics in Tremor are implemented as a pipeline and deployed during startup."),(0,a.yg)("p",null,"Metrics are builtin and can not be undeployed."),(0,a.yg)("p",null,"Operators ",(0,a.yg)("strong",{parentName:"p"},"MAY")," attach offramps to the metrics service to distribute metrics to external systems, such as InfluxDB or Kafka."),(0,a.yg)("h2",{id:"data-model"},"Data model"),(0,a.yg)("p",null,"Tremor supports unstructured data."),(0,a.yg)("p",null,"Data can be raw binary, JSON, MsgPack, Influx or other structures."),(0,a.yg)("p",null,"When data is ingested into a Tremor pipeline it can be any ",(0,a.yg)("strong",{parentName:"p"},"supported")," format."),(0,a.yg)("p",null,"Tremor pipeline operators however, often assume ",(0,a.yg)("em",{parentName:"p"},"some")," structure. For hierarchic or nested formats such as JSON and MsgPack, Tremor uses the ",(0,a.yg)("inlineCode",{parentName:"p"},"serde")," serialisation and deserialisation capabilities."),(0,a.yg)("p",null,"Therefore, the ",(0,a.yg)("em",{parentName:"p"},"in-memory")," format for ",(0,a.yg)("em",{parentName:"p"},"JSON-like")," data in Tremor is effectively a ",(0,a.yg)("inlineCode",{parentName:"p"},"simd_json::Value"),". This has the advantage of allowing Tremor-script to work against YAML, JSON or MsgPack data with no changes or considerations in the Tremor-script based on the origin data format."),(0,a.yg)("p",null,"For line oriented formats such as the Influx Line Protocol, or GELF these are typically transformed to Tremor's in-memory format ( currently based on ",(0,a.yg)("inlineCode",{parentName:"p"},"serde"),")."),(0,a.yg)("p",null,"For raw binary or other data formats, Tremor provides a growing set of codecs that convert external data to Tremor in-memory form or that convert Tremor in-memory form to an external data format."),(0,a.yg)("p",null,"In general, operators and developers should ",(0,a.yg)("em",{parentName:"p"},"minimize")," the number of encoding and decoding steps required in the transit of data through Tremor or between Tremor instances."),(0,a.yg)("p",null,"The major overhead in most Tremor systems is encoding and decoding overhead. To compensate that, as JSON is the most dominant format, we ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/simd-lite/simdjson-rs"},"ported")," ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/lemire/simdjson"},"simd-json")," this reduces the cost of en- and decoding significantly compared to other JSON implementations in Rust."),(0,a.yg)("h3",{id:"distribution-model"},"Distribution model"),(0,a.yg)("p",null,"Tremor does not ( yet ) have an out-of-the-box network protocol. A native Tremor protocol is planned in the immediate / medium term."),(0,a.yg)("p",null,"As such, the distribution model for Tremor is currently limited to the set of available onramp and offramp connectors."),(0,a.yg)("p",null,"However the websocket ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/artefacts/onramps#ws"},"onramp")," and ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/artefacts/offramps#ws"},"offramp")," can be used for Tremor to Tremor communication."),(0,a.yg)("h3",{id:"clientserver"},"Client/Server"),(0,a.yg)("p",null,"Tremor, in its current form, is a client-server system. Tremor exposes a synchronous blocking RESTful API over HTTP for conducting operations related to its high throughput and relatively high performance pipeline-oriented data plane."),(0,a.yg)("p",null,"Tremor, in the near future, will add a clustering capability making it a distributed system. Tremor will still support client-server deployments through a 'standalone' mode of clustered operation."),(0,a.yg)("p",null,"Tremor in 'standalone' mode can be thought of as client-server or a 'cluster of one' depending on your own bias or preferences, dear reader."))}c.isMDXComponent=!0}}]);