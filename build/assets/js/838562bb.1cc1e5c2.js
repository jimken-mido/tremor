"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[9357],{41816:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=t(58168),s=(t(96540),t(15680));t(40281);const a={},r="Persistent Write-Ahead Log",i={unversionedId:"recipes/persistent_gd/index",id:"version-0.11/recipes/persistent_gd/index",title:"Persistent Write-Ahead Log",description:"All the application code here is available from the docs git repository.",source:"@site/versioned_docs/version-0.11/recipes/21_persistent_gd/index.md",sourceDirName:"recipes/21_persistent_gd",slug:"/recipes/persistent_gd/",permalink:"/docs/0.11/recipes/persistent_gd/",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/21_persistent_gd/index.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Transient Write-Ahead Log",permalink:"/docs/0.11/recipes/transient_gd/"},next:{title:"Round Robin",permalink:"/docs/0.11/recipes/roundrobin/"}},m={},l=[{value:"Environment",id:"environment",level:2},{value:"Insights",id:"insights",level:2}],d={toc:l},p="wrapper";function c(e){let{components:n,...t}=e;return(0,s.yg)(p,(0,o.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"persistent-write-ahead-log"},"Persistent Write-Ahead Log"),(0,s.yg)("admonition",{type:"note"},(0,s.yg)("p",{parentName:"admonition"},"All the application code here is available from the docs ",(0,s.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/21_persistent_gd/index.md"},"git repository"),".")),(0,s.yg)("p",null,"The write-ahead log ( WAL ) builds on circuit breaker and acknowledgement mechanisms to\nprovide guaranteed delivery. The write-ahead log is useful in situations\nwhere sources/onramps do not offer guaranteed delivery themselves, but the data being distributed downstream can benefit from protection against loss and duplication."),(0,s.yg)("p",null,"In the configuration in this tutorial we configure a persistent WAL."),(0,s.yg)("h2",{id:"environment"},"Environment"),(0,s.yg)("p",null,"We configure a metronome as a source of data."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-yaml"},"# File: etc/tremor/config/metronome.yaml\nonramp:\n  - id: metronome\n    type: metronome\n    config:\n      interval: 1000 # Every second\n")),(0,s.yg)("p",null,"We configure a straight forward passthrough query to distribute\nthe data to connected downstream sinks."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"# File: etc/tremor/config/persistent.trickle\nuse tremor::system;\n\ndefine qos::wal operator on_disk_wal\nwith\n  read_count = 20,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ncreate operator on_disk_wal;\n\nselect patch event of\n  insert hostname = system::hostname()\nend\nfrom in into on_disk_wal;\n\nselect event from on_disk_wal into out;\n")),(0,s.yg)("p",null,"We then distribute the metronome events downstream to another websocket\nlistener. We use websocat for this purpose in this example. We can invoke\nthe server as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-bash"},"$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n")),(0,s.yg)("p",null,"We configure the sink/offramp as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-yaml"},"offramp:\n  - id: ws\n    type: ws\n    config:\n      url: ws://localhost:8080/\n")),(0,s.yg)("p",null,"Finally, we interconnect the source, sink and pipeline logic into\nan active flow:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},'binding:\n  - id: default\n    links:\n      "/onramp/metronome/{instance}/out": ["/pipeline/main/{instance}/in"]\n      "/pipeline/main/{instance}/out": ["/offramp/ws/{instance}/in"]\n\nmapping:\n  /binding/default/01:\n    instance: "01"\n')),(0,s.yg)("p",null,"Running the example via the tremor cli as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-bash"},"$ tremor server run -f etc/tremor/config/*\n")),(0,s.yg)("h2",{id:"insights"},"Insights"),(0,s.yg)("p",null,"If the tremor process restarts we pick up and re-send events that have not been acknowledged by the ws offramp and then carry on with new events coming from the metronome:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-bash"},'$ websocat -s 8080 ; websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":0,"hostname":"localhost","ingest_ns":1600860720749137000}\n{"onramp":"metronome","id":1,"hostname":"localhost","ingest_ns":1600860721751965000}\n{"onramp":"metronome","id":2,"hostname":"localhost","ingest_ns":1600860722756684000}\n{"onramp":"metronome","id":3,"hostname":"localhost","ingest_ns":1600860723761037000}\n{"onramp":"metronome","id":4,"hostname":"localhost","ingest_ns":1600860724764683000}\n{"onramp":"metronome","id":3,"hostname":"localhost","ingest_ns":1600860723761037000}\n{"onramp":"metronome","id":4,"hostname":"localhost","ingest_ns":1600860724764683000}\n{"onramp":"metronome","id":0,"hostname":"localhost","ingest_ns":1600860730353260000}\n{"onramp":"metronome","id":1,"hostname":"localhost","ingest_ns":1600860731355463000}\n{"onramp":"metronome","id":2,"hostname":"localhost","ingest_ns":1600860732357883000}\n{"onramp":"metronome","id":3,"hostname":"localhost","ingest_ns":1600860733362429000}\n{"onramp":"metronome","id":4,"hostname":"localhost","ingest_ns":1600860734364277000}\n{"onramp":"metronome","id":5,"hostname":"localhost","ingest_ns":1600860735367967000}\n{"onramp":"metronome","id":6,"hostname":"localhost","ingest_ns":1600860736373137000}\n')),(0,s.yg)("admonition",{type:"note"},(0,s.yg)("p",{parentName:"admonition"},"We restarted tremor after sending event with id ",(0,s.yg)("inlineCode",{parentName:"p"},"4"),". It did resend events ",(0,s.yg)("inlineCode",{parentName:"p"},"3")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"4")," as they have not been acked from the perspective of the WAL yet.")),(0,s.yg)("p",null,"If the downstream websocket service restarts we can recover up to 1000 events or any number of events worth 1MB. We may lose in flight events that were already acknowledged at the time the server went down and thus not fully delivered by the downstream system."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-bash"},'$ websocat -s 8080 ; websocat -s 8080\n{"onramp":"metronome","id":0,"hostname":"ALT01828","ingest_ns":1600861519788231000}\n{"onramp":"metronome","id":1,"hostname":"ALT01828","ingest_ns":1600861520790241000}\n{"onramp":"metronome","id":2,"hostname":"ALT01828","ingest_ns":1600861521792297000}\n{"onramp":"metronome","id":3,"hostname":"ALT01828","ingest_ns":1600861522797476000}\n{"onramp":"metronome","id":4,"hostname":"ALT01828","ingest_ns":1600861523802114000}\n^C\n$  websocat -s 8080 ; websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":6,"hostname":"ALT01828","ingest_ns":1600861525809835000}\n{"onramp":"metronome","id":7,"hostname":"ALT01828","ingest_ns":1600861526813574000}\n{"onramp":"metronome","id":8,"hostname":"ALT01828","ingest_ns":1600861527817722000}\n{"onramp":"metronome","id":9,"hostname":"ALT01828","ingest_ns":1600861528822667000}\n{"onramp":"metronome","id":10,"hostname":"ALT01828","ingest_ns":1600861529826521000}\n{"onramp":"metronome","id":11,"hostname":"ALT01828","ingest_ns":1600861530830497000}\n')),(0,s.yg)("admonition",{type:"note"},(0,s.yg)("p",{parentName:"admonition"},"We stopped the websocket server and restarted right afterwards. We in fact lost 1 event (id ",(0,s.yg)("inlineCode",{parentName:"p"},"5"),") which was acked inside tremor but not yet fully delivered to the console by websocat. Other events that the offramp was unable to send will be resent once the ws offramp can connect again.")),(0,s.yg)("p",null,"In short, the persistent in memory wal can assist with partial recovery of downstream system or tremor itself and will actively reduce data loss within the configured retention but it is not guarenteed to be lossless."))}c.isMDXComponent=!0}}]);