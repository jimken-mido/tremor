"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[3076],{67215:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=t(58168),s=(t(96540),t(15680));t(40281);const o={},r="Syslog over UDP with DNS lookups",a={unversionedId:"recipes/syslog_udp_dns/index",id:"version-0.11/recipes/syslog_udp_dns/index",title:"Syslog over UDP with DNS lookups",description:"All the application code here is available from the docs git repository.",source:"@site/versioned_docs/version-0.11/recipes/15_syslog_udp_dns/index.md",sourceDirName:"recipes/15_syslog_udp_dns",slug:"/recipes/syslog_udp_dns/",permalink:"/docs/0.11/recipes/syslog_udp_dns/",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/15_syslog_udp_dns/index.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Syslog over UDP",permalink:"/docs/0.11/recipes/syslog_udp/"},next:{title:"Transient Write-Ahead Log",permalink:"/docs/0.11/recipes/transient_gd/"}},p={},l=[{value:"Setup",id:"setup",level:2},{value:"Environment",id:"environment",level:2},{value:"Business Logic",id:"business-logic",level:2}],d={toc:l},c="wrapper";function g(e){let{components:n,...o}=e;return(0,s.yg)(c,(0,i.A)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"syslog-over-udp-with-dns-lookups"},"Syslog over UDP with DNS lookups"),(0,s.yg)("admonition",{type:"note"},(0,s.yg)("p",{parentName:"admonition"},"All the application code here is available from the docs ",(0,s.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/15_syslog_udp_dns/index.md"},"git repository"),".")),(0,s.yg)("p",null,"This workshop is the samne as the ",(0,s.yg)("a",{parentName:"p",href:"/docs/0.11/recipes/syslog_udp/"},"syslog_udp")," workship with the added component of enriching the syslog message we receive with a DNS lookup."),(0,s.yg)("p",null,"We will only discuss the newly introduced components, for the rest pleas refer to the ",(0,s.yg)("a",{parentName:"p",href:"/docs/0.11/recipes/syslog_udp/"},"syslog_udp")," workshop."),(0,s.yg)("h2",{id:"setup"},"Setup"),(0,s.yg)("admonition",{type:"tip"},(0,s.yg)("p",{parentName:"admonition"},"All the code here is available in the ",(0,s.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/docs/recipes/syslog_udp"},"git repository")," as well and can be run with ",(0,s.yg)("inlineCode",{parentName:"p"},"docker compose up"),".")),(0,s.yg)("h2",{id:"environment"},"Environment"),(0,s.yg)("p",null,"We get a new ",(0,s.yg)("a",{target:"_blank",href:t(8709).A},"sink"),", the ",(0,s.yg)("inlineCode",{parentName:"p"},"dns")," sink. This is what tremor calls a ",(0,s.yg)("inlineCode",{parentName:"p"},"linked transport"),", aka a ",(0,s.yg)("inlineCode",{parentName:"p"},"sink")," or ",(0,s.yg)("inlineCode",{parentName:"p"},"source")," that can both receive and send messages."),(0,s.yg)("p",null,"In the case of the ",(0,s.yg)("inlineCode",{parentName:"p"},"dns")," sink it receives lookup requests and sends the replies."),(0,s.yg)("p",null,"This changes the ",(0,s.yg)("a",{target:"_blank",href:t(46454).A},"binding")," the following way:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre"},"metronome -> producer -> syslog-udp-out\n\nsyslog-udp-in -> dns -> dns\n\ndns -> consumer -> stdout-output\n")),(0,s.yg)("h2",{id:"business-logic"},"Business Logic"),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"producer")," pipeline stays unchanged however we add a new ",(0,s.yg)("inlineCode",{parentName:"p"},"dns")," pipeline and the ",(0,s.yg)("inlineCode",{parentName:"p"},"consumer")," piepline now includes some logic."),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"dns")," pipeline does two things. First it moves the event itself into the ",(0,s.yg)("inlineCode",{parentName:"p"},"$correlation")," metadata. Linked transports will preserve this metadata key over requests allowing to correlate the output event with the input request. Second it changes the event into a lookup of the ",(0,s.yg)("inlineCode",{parentName:"p"},"A")," record (ip address) for the hostname. Finally we do the wiering with select statments."),(0,s.yg)("p",null,":::warn\nStoring data in ",(0,s.yg)("inlineCode",{parentName:"p"},"$correlation")," will mean this data has to be kept in memory until the event is processed, depending on throughput and pending requests this can be a significant memory cost.\n:::"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},'# dns.trickle\ndefine script dns\nscript\n let $correlation = event;\n {\n  "lookup": $correlation.hostname,\n  "type": "A"\n }\nend;\n\ncreate script dns;\n\nselect event from in into dns;\nselect event from dns into out;\n')),(0,s.yg)("p",null,"In addition the ",(0,s.yg)("inlineCode",{parentName:"p"},"consumer")," pipeline got slightly more complicated. We use ",(0,s.yg)("inlineCode",{parentName:"p"},"merge")," to replace the lookup response from the ",(0,s.yg)("inlineCode",{parentName:"p"},"dns")," sink with it's correlation (the orriginal event) and merge merge it by inserting the IP we looked up into the event. In result we now have the original event with the added ",(0,s.yg)("inlineCode",{parentName:"p"},"ip")," field containing the IP correlating to the hostname."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},'# consumer.trickle\nselect merge $correlation of {"ip": event[0].A} end from in into out\n')))}g.isMDXComponent=!0},8709:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/files/00_ramps-3aff56264bc3e23d9b0ea73cc601f6a0.yaml"},46454:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/files/01_binding-97bc43bcd7dcd0b04cd4511231a0119a.yaml"}}]);