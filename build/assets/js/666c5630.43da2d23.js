"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[4890],{2424:(e,i,a)=>{a.r(i),a.d(i,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>s});var n=a(58168),t=(a(96540),a(15680));a(40281);const o={},l="Configuration Walkthrough",r={unversionedId:"operations/configuration-walkthrough",id:"version-0.11/operations/configuration-walkthrough",title:"Configuration Walkthrough",description:"A short canned synopsis of configuration tremor.",source:"@site/versioned_docs/version-0.11/operations/configuration-walkthrough.md",sourceDirName:"operations",slug:"/operations/configuration-walkthrough",permalink:"/docs/0.11/operations/configuration-walkthrough",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/operations/configuration-walkthrough.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Tremor cli v0.11",permalink:"/docs/0.11/operations/cli"},next:{title:"Configuring Tremor",permalink:"/docs/0.11/operations/configuration"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Write an onramp specification",id:"write-an-onramp-specification",level:3},{value:"Write an offramp specification",id:"write-an-offramp-specification",level:3},{value:"Write a pipeline specification",id:"write-a-pipeline-specification",level:3},{value:"Write a binding specification",id:"write-a-binding-specification",level:3},{value:"Publish via the REST API / curl",id:"publish-via-the-rest-api--curl",level:2},{value:"Publish onramp specification",id:"publish-onramp-specification",level:3},{value:"Publish offramp specification",id:"publish-offramp-specification",level:3},{value:"Publish pipeline specification",id:"publish-pipeline-specification",level:3},{value:"Publish binding specification",id:"publish-binding-specification",level:3},{value:"Publish metronome offramp specification",id:"publish-metronome-offramp-specification",level:3},{value:"Publish via tremor",id:"publish-via-tremor",level:2},{value:"Publish all specifications",id:"publish-all-specifications",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Deployment",id:"deployment",level:2}],c={toc:s},m="wrapper";function u(e){let{components:i,...a}=e;return(0,t.yg)(m,(0,n.A)({},c,a,{components:i,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"configuration-walkthrough"},"Configuration Walkthrough"),(0,t.yg)("p",null,"A short canned synopsis of configuration tremor."),(0,t.yg)("p",null,"This guide walks through configuring tremor via its API directly and via its command line tool 'tremor'. For the API, we use 'curl' on the command line."),(0,t.yg)("h2",{id:"introduction"},"Introduction"),(0,t.yg)("p",null,"In this walkthrough we will deploy a tremor pipeline that generates a periodic sequence of messages or heartbeats every second. The solution is composed of the following tremor artefacts:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"A metronome onramp - our periodic message generator"),(0,t.yg)("li",{parentName:"ul"},"A stdout offramp - an offramp that serializes to standard output useful for debugging"),(0,t.yg)("li",{parentName:"ul"},"A pipeline - we pass the input ( metronome events ) to our output")),(0,t.yg)("p",null,"In this walkthrough we configure a single onramp, offramp and pipeline but many other configurations are possible."),(0,t.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,t.yg)("h3",{id:"write-an-onramp-specification"},"Write an onramp specification"),(0,t.yg)("p",null,"This creates a config specification for an onramp that can be referenced by the unique id ",(0,t.yg)("inlineCode",{parentName:"p"},"metronome"),". It does not create an instance of it."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-yaml"},"# File: metronome-onramp.yaml\nid: metronome\ntype: metronome\nconfig:\n  interval: 1000\n")),(0,t.yg)("h3",{id:"write-an-offramp-specification"},"Write an offramp specification"),(0,t.yg)("p",null,"This creates a config specification for an offramp that can be referenced by the unique id ",(0,t.yg)("inlineCode",{parentName:"p"},"stdout"),". It does not create an instance of it. Think of this as a blueprint."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-yaml"},"# File: metronome-offramp.yaml\nid: stdout\ntype: stdout\n")),(0,t.yg)("h3",{id:"write-a-pipeline-specification"},"Write a pipeline specification"),(0,t.yg)("p",null,"File: ",(0,t.yg)("inlineCode",{parentName:"p"},"main.trickle"),":"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-tremor"},'#!config id = "main"\nselect event from in into out;\n')),(0,t.yg)("h3",{id:"write-a-binding-specification"},"Write a binding specification"),(0,t.yg)("p",null,"In tremor pipelines have no non-deterministic side-effects."),(0,t.yg)("p",null,"By design, tremor does not allow onramps or offramps to be specified as a part of a pipeline. This would couple running pipelines to external connections. For example, to an external kafka broker and topic. This isn't bad per se, but it would allow a configuration or programming style that allows pipelines that are hard to distribute, clusterable or scalable."),(0,t.yg)("p",null,"To be clear, therefore:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"All data processed by a tremor pipeline is always ingested via an event"),(0,t.yg)("li",{parentName:"ul"},"All events arrive into pipelines via 'input streams', operators that link a pipeline to the outside world"),(0,t.yg)("li",{parentName:"ul"},"All events leave a pipeline via 'output streams', operators that link a pipeline to the outside world"),(0,t.yg)("li",{parentName:"ul"},"Events always traverse a pipeline in graph order ( Depth-First-Search )"),(0,t.yg)("li",{parentName:"ul"},"Where there is no imposed ordering ( in a branch ), tremor imposes declaration order"),(0,t.yg)("li",{parentName:"ul"},"Synthetic events ( signals from the tremor system runtime, or contraflow that derive from events already in-flight in a pipeline ) follow the same rules, without exception."),(0,t.yg)("li",{parentName:"ul"},"All in-flight events in a pipeline are processed to completion before queued events are processed.")),(0,t.yg)("p",null,"As a result, in order to connect onramps, offramps and pipelines , we need to link them together. We call this set of ( required ) links a 'binding specification'. It is ok ",(0,t.yg)("em",{parentName:"p"},"not")," to connect a pipeline input stream or output stream. But it is not ok to not connect the subset exposed in a binding specification."),(0,t.yg)("p",null,"For our scenario, the following will suffice:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-yaml"},'# File: metronome-binding.yaml\nid: default\nlinks:\n  "/onramp/metronome/{instance}/out": ["/pipeline/main/{instance}/in"]\n  "/pipeline/main/{instance}/out": ["/offramp/stdout/{instance}/in"]\n')),(0,t.yg)("p",null,"Ths creates a binding specification. Again this does not instantiate the referenced onramps, offramps or pipelines. This is also a blueprint of a connected topology with a unique identifier ",(0,t.yg)("inlineCode",{parentName:"p"},"default"),"."),(0,t.yg)("h2",{id:"publish-via-the-rest-api--curl"},"Publish via the REST API / curl"),(0,t.yg)("h3",{id:"publish-onramp-specification"},"Publish onramp specification"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs -stderr -X POST -H "Content-Type: application/yaml" --data-binary @metronome-onramp.yaml http://localhost:9898/onramp\n')),(0,t.yg)("p",null,"Check that it published ok:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'$ curl -vs --stderr - -H "Accept: application/yaml" http://localhost:9898/onramp\n- metronome\n')),(0,t.yg)("h3",{id:"publish-offramp-specification"},"Publish offramp specification"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs -stderr -X POST -H "Content-Type: application/yaml" --data-binary @metronome-offramp.yaml http://localhost:9898/offramp\n')),(0,t.yg)("p",null,"Check that it published ok:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs --stderr - -H "Accept: application/yaml" http://localhost:9898/offramp\n- stdout\n')),(0,t.yg)("h3",{id:"publish-pipeline-specification"},"Publish pipeline specification"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs --stderr -X POST -H "Content-type: application/vnd.trickle" --data-binary @main.trickle http://localhost:9898/pipeline\n')),(0,t.yg)("p",null,"Check that it published ok:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'$ curl -vs --stderr -H "Accept: application/vnd.trickle" http://localhost:9898/pipeline/main\n#!config id = "main"\nselect event from in into out;\n')),(0,t.yg)("h3",{id:"publish-binding-specification"},"Publish binding specification"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs -stderr -X POST -H "Content-Type: application/yaml" --data-binary @metronome-binding.yaml http://localhost:9898/binding\n')),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'$ curl -vs --stderr - -H "Accept: application/yaml" http://localhost:9898/binding\n- default\n')),(0,t.yg)("h3",{id:"publish-metronome-offramp-specification"},"Publish metronome offramp specification"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs -stderr -X POST -H "Content-Type: application/yaml" --data-binary @metronome-offramp.yaml http://localhost:9898/offramp\n')),(0,t.yg)("p",null,"Check that it published ok:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs --stderr - -H "Accept: application/yaml" http://localhost:9898/offramp\n- default\n')),(0,t.yg)("h2",{id:"publish-via-tremor"},"Publish via tremor"),(0,t.yg)("p",null,"The tremor command allows the exact sample set of interactions as above. For brevity we simpilify the examples in this section but the steps are the same."),(0,t.yg)("p",null,"Tremor tool, however, makes it easier to switch between JSON and YAML"),(0,t.yg)("h3",{id:"publish-all-specifications"},"Publish all specifications"),(0,t.yg)("p",null,"Publish onramp, offramp, pipeline and binding:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},"tremor api onramp create metronome-onramp.yaml\ntremor api offramp create metronome-offramp.yaml\ntremor api pipeline create metronome-pipeline.yaml\ntremor api binding create metronome-binding.yaml\n")),(0,t.yg)("p",null,"Check all our artefacts have published ok:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},"tremor api onramp list\ntremor api offramp list\ntremor api pipeline list\ntremor api binding list\n")),(0,t.yg)("h2",{id:"limitations"},"Limitations"),(0,t.yg)("p",null,"Live deployments via the API only work with a single entity and passing a list using the API isn't supported. In order to achieve that you can use ",(0,t.yg)("a",{parentName:"p",href:"/docs/0.11/operations/configuration"},"'Static or Bootstrap Deployments")),(0,t.yg)("h2",{id:"deployment"},"Deployment"),(0,t.yg)("p",null,"Once all artefacts are published into the tremor repository we are ready to deploy. We deploy instances, via bindings, through mapping specifications."),(0,t.yg)("p",null,"In all steps to this point, we have been populating the tremor repository. Like a git repository the tremor repository stores artefacts, like git stores code."),(0,t.yg)("p",null,"When we publish a mapping we are deploying live instances of onramps, offramps, and pipelines, in our case, we want to:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Deploy a single metronome onramp instance"),(0,t.yg)("li",{parentName:"ul"},"Deploy a single stdout offramp instance"),(0,t.yg)("li",{parentName:"ul"},"Deploy a single passthrough pipeline"),(0,t.yg)("li",{parentName:"ul"},"We want the onramp to connect to the pipeline"),(0,t.yg)("li",{parentName:"ul"},"We want the offramp to connect to the pipeline")),(0,t.yg)("p",null,"In our final step we specify:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"We want to call our instance 'walkthrough'")),(0,t.yg)("p",null,"A Mapping specification contains values for the placeholders (with curly braces, e.g. ",(0,t.yg)("inlineCode",{parentName:"p"},"{instance}"),") in the binding specification."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-yaml"},'# File: metronome-mapping.yaml\ninstance: "walkthrough"\n')),(0,t.yg)("p",null,"We do not deploy or publish a mapping, we rather instantiate a binding specification and provide a mapping with the placeholder values."),(0,t.yg)("p",null,"Deploy via curl:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},'curl -vs -stderr -X POST -H "Content-Type: application/yaml" --data-binary @metronome-mapping.yaml http://localhost:9898/binding/default/walkthrough\n')),(0,t.yg)("p",null,"Deploy via tremor:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-bash"},"tremor api binding activate default walkthrough metronome-mapping.yaml\n")),(0,t.yg)("p",null,"The result is that all referenced onramps, offramps and pipelines specified in the binding are live and linked and events flow through them."))}u.isMDXComponent=!0}}]);