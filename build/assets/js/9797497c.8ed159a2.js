"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[4136],{97532:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var i=n(58168),a=(n(96540),n(15680));const r={},s=void 0,o={unversionedId:"accepted/binary-type",id:"accepted/binary-type",title:"binary-type",description:"- Feature Name: binary-type",source:"@site/rfc/accepted/0014-binary-type.md",sourceDirName:"accepted",slug:"/accepted/binary-type",permalink:"/rfc/accepted/binary-type",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/rfc/accepted/0014-binary-type.md",tags:[],version:"current",sidebarPosition:14,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"script-operator-enhacements",permalink:"/rfc/accepted/script-operator-enhacements"},next:{title:"troy",permalink:"/rfc/accepted/troy"}},l={},p=[{value:"The <code>binary</code> type",id:"the-binary-type",level:2},{value:"Serialization",id:"serialization",level:2},{value:"Syntax",id:"syntax",level:2},{value:"stdlib",id:"stdlib",level:2},{value:"codecs",id:"codecs",level:2}],d={toc:p},y="wrapper";function g(e){let{components:t,...n}=e;return(0,a.yg)(y,(0,i.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Feature Name: binary-type"),(0,a.yg)("li",{parentName:"ul"},"Start Date: 2020-12-16"),(0,a.yg)("li",{parentName:"ul"},"Tremor Issue: ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-runtime/issues/0000"},"tremor-rs/tremor-runtime#0000")),(0,a.yg)("li",{parentName:"ul"},"RFC PR: ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-rfcs/pull/0000"},"tremor-rs/tremor-rfcs#0000"))),(0,a.yg)("h1",{id:"summary"},"Summary"),(0,a.yg)("p",null,"This RFC proposes the addition of a new type: ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," along with the underpinnings needed to extend tremors type system."),(0,a.yg)("h1",{id:"motivation"},"Motivation"),(0,a.yg)("p",null,"The motivation here is three-fold."),(0,a.yg)("p",null,"As of writing this RFC tremor has no option to handle 'raw' data. As it stands, even if we never want to inspect or modify a payload we always pay the price of translating the data into tremors internal, JSONesque format or representing it as a utf8 string. Both these choices come at a computation cost at best or are wrong and lossy at worst. A binary type allows us to treat a message as \"a bunch of bytes\", removing any loss or additional computational cost of encoding/decoding them."),(0,a.yg)("p",null,"The second reason for a binary datatype is to be able to handle messages that are not covered by existing codes. A binary type along with the functions to inspect, deconstruct or create binary messages gives a new extension point for users to parse their own, non-textual formats."),(0,a.yg)("p",null,"Last but not least, extending tremor with a binary type, something that JSON isn't capable of representing lays the groundwork for adding more powerful types to tremor. It serves as a case study of the cost/complexity of this and will help simplifying the task for later additions."),(0,a.yg)("h1",{id:"guide-level-explanation"},"Guide-level explanation"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," type in tremor comes along with additions to the tremor-script syntax, the type system, codecs, the standard library and a specification of the serialization behavior. We will discuss each of those "),(0,a.yg)("h2",{id:"the-binary-type"},"The ",(0,a.yg)("inlineCode",{parentName:"h2"},"binary")," type"),(0,a.yg)("p",null,"The easiest way to think about it is that the ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," type represents an array of bytes."),(0,a.yg)("h2",{id:"serialization"},"Serialization"),(0,a.yg)("p",null,"Serialization is codec dependant and not always symmetric. A codec that can not represent binary data and is a general-purpose codec it will default to base64 encoding the data as a string (JSON for example). This is an asymmetric change as we will not by default decode a base64 string as binary given without context we can't determine if this is the desired behavior or not, this can however be done using tremor-scripts functions."),(0,a.yg)("h2",{id:"syntax"},"Syntax"),(0,a.yg)("p",null,"We use the ",(0,a.yg)("a",{parentName:"p",href:"https://erlang.org/doc/programming_examples/bit_syntax.html"},"erlang bit syntax")," as an inspiration. Tremor script gains support for binary semi-literals using the form of ",(0,a.yg)("inlineCode",{parentName:"p"},"<< expr1:<size>/<type>, expr2 >>")," where:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"expr")," cab be either a number, another binary or a string."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"size")," defines the size in bits for numbers ranging for 1 to 64, sub bit sizes are supported, or the size in bytes for strings and binaries. The default size for integers is ",(0,a.yg)("inlineCode",{parentName:"li"},"8")," and for strings or binaries is the entire binary"),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"type")," needs to be specified as ",(0,a.yg)("inlineCode",{parentName:"li"},"binary")," for strings and binaries or can be a combination of endianness (",(0,a.yg)("inlineCode",{parentName:"li"},"big"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"little"),"), signedness (",(0,a.yg)("inlineCode",{parentName:"li"},"unsigned"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"signed"),") and numeric type (",(0,a.yg)("inlineCode",{parentName:"li"},"integer"),") where parts are concatinated by a ",(0,a.yg)("inlineCode",{parentName:"li"},"-")," and the first one enumerated is the default")),(0,a.yg)("p",null,"The default (no size or type suffix) being equivalent to ",(0,a.yg)("inlineCode",{parentName:"p"},":8/big-unsigned-integer"),"."),(0,a.yg)("h2",{id:"stdlib"},"stdlib"),(0,a.yg)("p",null,"This RFC introduces the ",(0,a.yg)("inlineCode",{parentName:"p"},"base64")," module for encoding and decoding ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," data as base64 strings. It also adds the ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," module with basic functions such as ",(0,a.yg)("inlineCode",{parentName:"p"},"len"),", as well as conversion functions to and from arrays of numbers."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"string")," module gains functions to convert a string to a ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," as well as a function that will take a ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," and convert it to a utf8 ",(0,a.yg)("inlineCode",{parentName:"p"},"string")," in a potentially lossy fashion for invalid utf8 data."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"type")," module will gain the ",(0,a.yg)("inlineCode",{parentName:"p"},"is_binary")," function as well as ",(0,a.yg)("inlineCode",{parentName:"p"},"type::as_string")," now returning ",(0,a.yg)("inlineCode",{parentName:"p"},'"binary"')," when appropriate."),(0,a.yg)("h2",{id:"codecs"},"codecs"),(0,a.yg)("p",null,"This RFC introduces the ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," codec that passes bytes unmodified as binary data."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"json")," codec is changed to serialize ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," data as a base64 encoded string, however it will not automatically decode base64 strings as binary."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"msgpack")," codec should encode and decode binary as ",(0,a.yg)("inlineCode",{parentName:"p"},"bin")," types."),(0,a.yg)("h1",{id:"reference-level-explanation"},"Reference-level explanation"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"binary")," type is a ",(0,a.yg)("inlineCode",{parentName:"p"},"Vec<u8>")," that serializes as base64 encoded string in simd-json and as ",(0,a.yg)("inlineCode",{parentName:"p"},"bytes")," in serde compatible encoders."),(0,a.yg)("p",null,"If the new implemented functions are all constant, they will be able to be pre-computed when constant folding is possible."),(0,a.yg)("p",null,"The binary semi-literals will, whenever possible be turned into full-literals using constant folding, but remain constructs where not following the example of arrays and records."),(0,a.yg)("p",null,"If a literal is created that is not byte aligned the bits that overhang the last byte boundary will be treated as part of a new\nbyte filling the less significant bits of it."),(0,a.yg)("p",null,"In other words ",(0,a.yg)("inlineCode",{parentName:"p"},"<<1:8, 2:4>>")," where we only have 4 bytes of the second byte will fill to: ",(0,a.yg)("inlineCode",{parentName:"p"},"<<1:8, 2:8>>"),"."),(0,a.yg)("h1",{id:"drawbacks"},"Drawbacks"),(0,a.yg)("p",null,"This breaks symmetry with the JSON representation, however all differences can be recovered using the provided tremor-script functionality."),(0,a.yg)("h1",{id:"rationale-and-alternatives"},"Rationale and alternatives"),(0,a.yg)("p",null,"There are no decent alternative binary syntax to erlangs binary forms we found as part of the research."),(0,a.yg)("p",null,"Many C derived languages support encoding bytes in a string like form, this however doesn't offer anything near the capabilities we require."),(0,a.yg)("h1",{id:"prior-art"},"Prior art"),(0,a.yg)("p",null,"This RFC is heavily inspired by the (erlang bit syntax)","[https://erlang.org/doc/programming_examples/bit_syntax.html]","."),(0,a.yg)("h1",{id:"unresolved-questions"},"Unresolved questions"),(0,a.yg)("p",null,"As of writing the first draft of this RFC it is still open how far into bit syntax compatibility it will go while balancing benefit and time constraints. Binary comprehensions, as existing in erlang are not part of this RFC. Neither support for 'less then a byte' boundaires."),(0,a.yg)("h1",{id:"future-possibilities"},"Future possibilities"),(0,a.yg)("p",null,"Binary comprehensions are a major future possibility for bit syntax. They are also well seperated in the way that extracting them will not harm this RFC."),(0,a.yg)("p",null,"Matching binaries is the next logical step. Due to it being significantly more complex and the work on binary types and semi-literals is self contained, this will be handled in a seperate RFC."))}g.isMDXComponent=!0}}]);