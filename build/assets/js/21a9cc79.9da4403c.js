"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[2596],{21309:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var s=n(58168),a=(n(96540),n(15680));n(40281);const r={},l="path",o={unversionedId:"reference/stdlib/std/path",id:"version-0.12/reference/stdlib/std/path",title:"path",description:"The path module contains utility functions for path handling",source:"@site/versioned_docs/version-0.12/reference/stdlib/std/path.md",sourceDirName:"reference/stdlib/std",slug:"/reference/stdlib/std/path",permalink:"/docs/0.12/reference/stdlib/std/path",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/reference/stdlib/std/path.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"math",permalink:"/docs/0.12/reference/stdlib/std/math"},next:{title:"random",permalink:"/docs/0.12/reference/stdlib/std/random"}},i={},d=[{value:"Functions",id:"functions",level:2},{value:"try_default(base, segments, otherwise)",id:"try_defaultbase-segments-otherwise",level:3}],u={toc:d},h="wrapper";function m(e){let{components:t,...n}=e;return(0,a.yg)(h,(0,s.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"path"},"path"),(0,a.yg)("p",null," The path module contains utility functions for path handling"),(0,a.yg)("h2",{id:"functions"},"Functions"),(0,a.yg)("h3",{id:"try_defaultbase-segments-otherwise"},"try_default(base, segments, otherwise)"),(0,a.yg)("p",null,"Determine if a base value matches an segment index array.\nReturns the value under the match on a hit.\nReturns a default user provided value on no match."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"base")," value can be a record, an array or the literal null."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"segments")," value should be an array where each field is used\nto traverse the ",(0,a.yg)("inlineCode",{parentName:"p"},"base")," value, as follows:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"String yielding expression segments used for field traversal"),(0,a.yg)("li",{parentName:"ul"},"Integer yielding expression segments used for array traversal"),(0,a.yg)("li",{parentName:"ul"},"A empty segment list yields is considered a match yielding the base value")),(0,a.yg)("p",null,"Examples"),(0,a.yg)("blockquote",null,(0,a.yg)("pre",{parentName:"blockquote"},(0,a.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::path;\n\n{"snot": "badger"} == path::try_default({"snot": "badger"}, [], "test")\n"flook" == path::try_default([{"snot": "badger"}, ["fleek", "flook"]], [1, 1], "test")\n"badger" == path::try_default([{"snot": "badger"}, ["fleek", "flook"]], [0, "snot"], "test")\n"fleek" == path::try_default([{"snot": "badger"}, ["fleek", "flook"]], [1, 0], "test")\n"test" == path::try_default([{"snot": "badger"}, ["fleek", "flook"]], [1, 2], "test")\n\n# Statements of the general form\n match event of\n   case %{ absent host } => let event.host = system::hostname()\n   default => event.host\n end;\n\n# Can now be written more tersely as:\n# If host is absent, default to the system hostname\nlet host = try_default(event, ["host"], system::hostname())\n'))),(0,a.yg)("p",null,"Returns a tremor value"))}m.isMDXComponent=!0}}]);