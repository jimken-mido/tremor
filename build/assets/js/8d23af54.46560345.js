"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6496],{55267:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(58168),o=(n(96540),n(15680));const r={},i=void 0,s={unversionedId:"accepted/script-operator-enhacements",id:"accepted/script-operator-enhacements",title:"script-operator-enhacements",description:"- Feature Name: script operator enhancements",source:"@site/rfc/accepted/0013-script-operator-enhacements.md",sourceDirName:"accepted",slug:"/accepted/script-operator-enhacements",permalink:"/rfc/accepted/script-operator-enhacements",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/rfc/accepted/0013-script-operator-enhacements.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Ramp Interface",permalink:"/rfc/accepted/ramp-interface"},next:{title:"binary-type",permalink:"/rfc/accepted/binary-type"}},l={},p=[{value:"<code>state</code>",id:"state",level:2},{value:"<code>script for &quot;&lt;port&gt;&quot;</code>",id:"script-for-port",level:2},{value:"<code>state</code>",id:"state-1",level:2},{value:"<code>script for &quot;&lt;port&gt;&quot;</code>",id:"script-for-port-1",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.yg)(d,(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Feature Name: ",(0,o.yg)("inlineCode",{parentName:"li"},"script")," operator enhancements"),(0,o.yg)("li",{parentName:"ul"},"Start Date: 2021-04-28"),(0,o.yg)("li",{parentName:"ul"},"Tremor Issue: ",(0,o.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-runtime/issues/960"},"tremor-rs/tremor-runtime#960")," ",(0,o.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-runtime/issues/933"},"tremor-rs/tremor-runtime#933")),(0,o.yg)("li",{parentName:"ul"},"RFC PR: ",(0,o.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-rfcs/pull/0000"},"tremor-rs/tremor-rfcs#0000"))),(0,o.yg)("h1",{id:"summary"},"Summary"),(0,o.yg)("p",null,"This RFC aims to add quality of life improvements to the script operator. As it exists today, the operator works well for simple use-cases but-in light of the growing number of complex pipelines and the use of patterns like the configurator pattern it is cumbersome. When first implemented, ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," didn't exist, and ports were not used. Those are the areas of improvement this RFC tackles."),(0,o.yg)("p",null,"The improvements focus around handling of state and tackle two common cases:"),(0,o.yg)("p",null,"1) decupling the control plane logic (setting / modifying state) and the data plane logic (using state to make decisions)\n2) seeding the state with a value"),(0,o.yg)("h1",{id:"motivation"},"Motivation"),(0,o.yg)("p",null,"To demonstrate we will give a motivating example if the reduction of complexity for a simplified algorithm for distributed loadbalancing:"),(0,o.yg)("p",null,"The original code has to contend with not knowing what ports data comes in and having to verify the initalization of state on every event."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-trickle"},'define grouper::bucket operator bucketing;\n\ndefine script lb\nwith\n  rate = 0,\n  peer = {\n    "host": "127.0.0.1",\n    "port": 4242\n  },\n  self = {\n    "host": "127.0.0.1",\n    "port": 4243\n  }\nscript\n  # If the state isn\'t intialized, do this now\n  match absent state.rate of\n    case true => let state = {"quota": args.quota, "rate": 1.0 }\n    default => null\n  end;\n\n  match event of\n    # we got a delta message in reply that tells us how to adjust our quota\n    case %{ present delta } =>\n      let state.quota = state.quota + event.delta\n    # we got a compare message asking us to figure out the adjustment required\n    # apply it, and send it over to the requester\n    case %{ present cmp } =>\n      let delta = state.quota * (state.rate - event.rate),\n      let state.rate = state.rate - delta,\n      let $udp = event.udp,\n      emit {"delta": delta} => "udp"\n    case %{ present rate } =>\n      let state.rate = event.rate,\n      drop\n    # we are asked to propage our rate\n    case %{ id == "proagate" } =>\n      emit { "quota": state.quota } => "config"\n    # Tick event for periodic checks\n    case %{ id == "tick" } =>\n      let $udp = args.peer,\n      emit {"cmp": state.quota, "udp": args.self } => "udp"\n    case _ => emit => "dbg"\n  end\nend;\n\n\ndefine script rate\nscript\n  match event of\n    case %{tags ~= %{node == "bucketing", port == "out", action == "pass"} } => let state.pass = event.fields.count\n    case %{tags ~= %{node == "bucketing", port == "out", action == "overflow"} } => let state.overflow = event.fields.count\n    case _ => drop\n  end;\n\n  match state of\n    case %{ present pass, present overflow } when state.pass + state.overflow > 0 => {"rate": state.pass / (state.pass + state.overflow)}\n    case _ => drop\n  end\nend;\n\n\ndefine script apply\nscript\n  let rate = match state of\n    case null => let state = 0\n    case _ => null\n  end;\n  match event of\n    case %{ present quota } => let state = event.quota, drop\n    case _ => null\n  end;\n  let $class =  "default";\n  let $rate = state\nend;\n\ncreate operator bucketing;\ncreate script apply;\ncreate script rate;\ncreate script lb;\n\n\n# main data flow\nselect event from in into apply;\nselect event from apply into bucketing;\nselect event from bucketing into out;\n\n# rate updates from bucketing metrics\nselect event from bucketing/metrics into rate;\nselect event from rate into lb/rate;\n\n# rate updates from the load balancing logic\nselect event from lb/config into apply/config;\n\n# udp coms for the load balancer\nselect event from in/udp into lb/udp;\nselect event from lb/udp into lb/out;\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-trickle"},'define grouper::bucket operator bucketing;\n\ndefine script lb\nwith\n  rate = 0,\n  peer = {\n    "host": "127.0.0.1",\n    "port": 4242\n  },\n  self = {\n    "host": "127.0.0.1",\n    "port": 4243\n  }\nstate\n  {"quota": args.quota, "rate": 1.0}\nscript from "udp"\n  match event of\n    case %{ present delta } =>\n      let state.quota = state.quota + event.delta,\n      drop\n    # we got a compare message asking us to figure out the adjustment required\n    # apply it, and send it over to the requester\n    case %{ present cmp } =>\n      let delta = state.quota * (state.rate - event.rate),\n      let state.rate = state.rate - delta,\n      let $udp = event.udp,\n      emit {"delta": delta} => "udp"\n  end;\n# rate update event\nscript from "rate"\n  let state.rate = event;\n  drop\n# propagation tick to send current quota to new\nscript from "propagate"\n  emit { "quota": state.quota } => "config"\nscript from "tick"\n  let $udp = args.peer;\n  emit {"cmp": state.quota, "udp": args.self } => "udp"\nscript\n  emit => "dbg"\nend;\n\ndefine script rate\nstate\n  {}\nscript\n  match event of\n    case %{tags ~= %{node == "bucketing", port == "out", action == "pass"} } => let state.pass = event.fields.count\n    case %{tags ~= %{node == "bucketing", port == "out", action == "overflow"} } => let state.overflow = event.fields.count\n    case _ => drop\n  end;\n\n  match state of\n    case %{ present pass, present overflow } when state.pass + state.overflow > 0 => state.pass / (state.pass + state.overflow)\n    case _ => drop\n  end\nend;\n\ndefine script apply\nstate  0\nscript for "config"\n  let state = event;\n  drop\nscript\n  let $class =  "default";\n  let $rate = state;\n  event\nend;\n\ncreate operator bucketing;\ncreate script apply;\ncreate script rate;\ncreate script lb;\n\n# main data flow\nselect event from in into apply;\nselect event from apply into bucketing;\nselect event from bucketing into out;\n\n# rate updates from bucketing metrics\nselect event from bucketing/metrics into rate;\nselect event from rate into lb/rate;\n\n# rate updates from the load balancing logic\nselect event from lb/config into apply/config;\n\n# udp coms for the load balancer\nselect event from in/udp into lb/udp;\nselect event from lb/udp into lb/out;\n\n# ticks\nselect event from in/tick into lb/tick;\nselect event from in/propagate into lb/propagate;\n')),(0,o.yg)("h1",{id:"guide-level-explanation"},"Guide-level explanation"),(0,o.yg)("p",null,"This introduces two new parts to the to the seelct statement."),(0,o.yg)("h2",{id:"state"},(0,o.yg)("inlineCode",{parentName:"h2"},"state")),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," section is introduced as an optional section to provide an initial state. One alternative would be calling it ",(0,o.yg)("inlineCode",{parentName:"p"},"init")," however using that would introduce a new keyword and by that break backwards compatibility and reduce the number of possible idents."),(0,o.yg)("p",null,"The content of ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," would get executed as part of the initialisation and then set once before the script is executes for the first time."),(0,o.yg)("h2",{id:"script-for-port"},(0,o.yg)("inlineCode",{parentName:"h2"},'script for "<port>"')),(0,o.yg)("p",null,"The addition of ",(0,o.yg)("inlineCode",{parentName:"p"},'script for "<port>"')," allows to define different script path for the different ports connected to the script operator."),(0,o.yg)("p",null,"They would share a ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," but not share local variables or constants. This is an extremely handy pattern in scenarios like the configurator pattern where one set of messages is used to adjust state and the other set of messages being processas as events."),(0,o.yg)("p",null,"In other words, it allows seperating control and data plane of a script."),(0,o.yg)("h1",{id:"reference-level-explanation"},"Reference-level explanation"),(0,o.yg)("h2",{id:"state-1"},(0,o.yg)("inlineCode",{parentName:"h2"},"state")),(0,o.yg)("p",null,"This will get executed at initiation time to take ",(0,o.yg)("inlineCode",{parentName:"p"},"args")," into acount. Then never be executed again\nin a running pipeline."),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," section will be optional."),(0,o.yg)("p",null,"This means the addition is backwards compatible."),(0,o.yg)("h2",{id:"script-for-port-1"},(0,o.yg)("inlineCode",{parentName:"h2"},'script for "<port>"')),(0,o.yg)("p",null,"This would basically be a loopup table for ",(0,o.yg)("inlineCode",{parentName:"p"},"port")," -> ",(0,o.yg)("inlineCode",{parentName:"p"},"script"),' with an additional "catch all" ',(0,o.yg)("inlineCode",{parentName:"p"},"script"),"\nthat gets executed if no port is specified."),(0,o.yg)("p",null,"All ",(0,o.yg)("inlineCode",{parentName:"p"},"script for")," sections will be optional, ",(0,o.yg)("inlineCode",{parentName:"p"},"script")," itself however madatory."),(0,o.yg)("p",null,"This means the addition is backwards compatible."),(0,o.yg)("h1",{id:"drawbacks"},"Drawbacks"),(0,o.yg)("p",null,"Drawbacks are addition of additional language constructs and introducing the usage of input ports for the first time which might add complexity for users."),(0,o.yg)("p",null,"On the other hand as both additions are optional thos complexity is hidden unless explicitly used."),(0,o.yg)("h1",{id:"rationale-and-alternatives"},"Rationale and alternatives"),(0,o.yg)("p",null,"One alternative to the ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," keyword could be replaced by ",(0,o.yg)("inlineCode",{parentName:"p"},"init")," which might be more intuitive but would add another keyword and break backwards compatibility by that."),(0,o.yg)("p",null,"Alternatives for ",(0,o.yg)("inlineCode",{parentName:"p"},"script for")," would be adding a ",(0,o.yg)("inlineCode",{parentName:"p"},"port")," keyword to access the port or a ",(0,o.yg)("inlineCode",{parentName:"p"},"system::port()")," function. The addition of the ",(0,o.yg)("inlineCode",{parentName:"p"},"port")," keyword would introduce the same backwards compatibility issues as the ",(0,o.yg)("inlineCode",{parentName:"p"},"init")," keywoard so is likely not a good idea. However adding the ",(0,o.yg)("inlineCode",{parentName:"p"},"system::port()")," (or a differently named) funciton would be possible in addition without negative impact."),(0,o.yg)("h1",{id:"prior-art"},"Prior art"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"init")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"state")," pretty much has prior art in most of any language that uses constructors for data."),(0,o.yg)("p",null,"Since ",(0,o.yg)("inlineCode",{parentName:"p"},'select from "<port>"')," is rather specific to the tremor runtime it isn't inspired by any prior art."),(0,o.yg)("h1",{id:"unresolved-questions"},"Unresolved questions"),(0,o.yg)("p",null,"None at this point."),(0,o.yg)("h1",{id:"future-possibilities"},"Future possibilities"),(0,o.yg)("p",null,"A ",(0,o.yg)("inlineCode",{parentName:"p"},"system::port()")," (or equivalent) function would be a good addition."),(0,o.yg)("p",null,"Another possibility this opens is to allow analyzing different script path and their respective ports. that way we can make a more detailed cycle analysis on a script that has a control plane and a data plane that do not overlap."),(0,o.yg)("p",null,"For example:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},'define script control_and_data\nscript for "control"\n  let state = sevent;\n  drop\nscript for event\n  // do something with event\nend;\n\nselect event from  control_and_data/metrics to control_and_data/control;\nselect event from in into out;\n')),(0,o.yg)("p",null,'Here we could determine that the "control" section never emits data, so no loop is created.'))}u.isMDXComponent=!0}}]);