"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[8669],{96064:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var t=o(58168),r=(o(96540),o(15680));o(40281);const i={},s="Round Robin",a={unversionedId:"recipes/roundrobin/index",id:"version-0.11/recipes/roundrobin/index",title:"Round Robin",description:"All the application code here is available from the docs git repository.",source:"@site/versioned_docs/version-0.11/recipes/22_roundrobin/index.md",sourceDirName:"recipes/22_roundrobin",slug:"/recipes/roundrobin/",permalink:"/docs/0.11/recipes/roundrobin/",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/22_roundrobin/index.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Persistent Write-Ahead Log",permalink:"/docs/0.11/recipes/persistent_gd/"},next:{title:"Kafka delivery guarantees",permalink:"/docs/0.11/recipes/kafka_gd/"}},l={},d=[{value:"Environment",id:"environment",level:2},{value:"Insights",id:"insights",level:2}],m={toc:d},c="wrapper";function u(e){let{components:n,...o}=e;return(0,r.yg)(c,(0,t.A)({},m,o,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"round-robin"},"Round Robin"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"All the application code here is available from the docs ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/recipes/22_roundrobin/index.md"},"git repository"),".")),(0,r.yg)("p",null,"The roundrobin distribution demo builds from the best-effort transient guaranteed\ndelivery demo and adds round-robin load balancing to a fixed number of downstream\nconsumers."),(0,r.yg)("p",null,"In this configuration we build a transient in-memory WAL with round-robin load-balancing\ndispatch to three downstream distribution endpoints."),(0,r.yg)("h2",{id:"environment"},"Environment"),(0,r.yg)("p",null,"We configure a metronome as a source of data."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"# File: etc/tremor/config/metronome.yaml\nonramp:\n  - id: metronome\n    type: metronome\n    config:\n      interval: 1000 # Every second\n")),(0,r.yg)("p",null,"We configure a straight forward passthrough query to distribute\nthe data to connected downstream sinks."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'use tremor::system;\n\ndefine qos::wal operator in_memory_wal with\n  read_count = 20,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ndefine qos::roundrobin operator roundrobin\nwith\n  outputs = [  "ws0", "ws1", "ws2" ]\nend;\n\n# create operator in_memory_wal;\ncreate operator roundrobin;\n\nselect merge event of\n  { "hostname" : system::hostname() }\nend\nfrom in into in_memory_wal;\n\nselect event from in_memory_wal into roundrobin;\n\nselect event from roundrobin/ws0 into out/ws0;\nselect event from roundrobin/ws1 into out/ws1;\nselect event from roundrobin/ws2 into out/ws2;\n')),(0,r.yg)("p",null,"We then distribute the metronome events downstream to three\ndownstream websocket servers and round robin load balance\nacross them"),(0,r.yg)("p",null,"Server 1, in first shell"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n")),(0,r.yg)("p",null,"Server 2, in second shell"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ websocat -s 8081\nListening on ws://127.0.0.1:8081/\n")),(0,r.yg)("p",null,"Server 3, in third shell"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ websocat -s 8082\nListening on ws://127.0.0.1:8082/\n")),(0,r.yg)("p",null,"We configure the sink/offramp instances as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"offramp:\n  - id: ws0\n    type: ws\n    config:\n      url: ws://localhost:8080/\n  - id: ws1\n    type: ws\n    config:\n      url: ws://localhost:8081/\n  - id: ws2\n    type: ws\n    config:\n      url: ws://localhost:8082/\n")),(0,r.yg)("p",null,"Finally, we interconnect the source, sink and pipeline logic into\nan active flow:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'binding:\n  - id: default\n    links:\n      "/onramp/metronome/{instance}/out": ["/pipeline/roundrobin/{instance}/in"]\n      "/pipeline/roundrobin/{instance}/ws0": [ "/offramp/ws0/{instance}/in"]\n      "/pipeline/roundrobin/{instance}/ws1": [ "/offramp/ws1/{instance}/in"]\n      "/pipeline/roundrobin/{instance}/ws2": [ "/offramp/ws2/{instance}/in"]\n\nmapping:\n  /binding/default/01:\n    instance: "01"\n')),(0,r.yg)("p",null,"Running the example via the tremor client as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ tremor server run -f etc/tremor/config/*\n")),(0,r.yg)("h2",{id:"insights"},"Insights"),(0,r.yg)("p",null,"If the tremor process restarts we sequence from the beginning."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},'$ websocat -s 8080\nListening on ws://127.0.0.1:8080/\n{"onramp":"metronome","id":0,"hostname":"ALT01827",  "ingest_ns":1600689100122526000}\n{"onramp":"metronome","id":3,"hostname":"ALT01827","ingest_ns":1600689101122912000}\n{"onramp":"metronome","id":6,"hostname":"ALT01827", "ingest_ns":1600689102124688000}\n...\n')),(0,r.yg)("p",null,"Otherwise, we should see sequences distribute across our downstream\nround-robin distribution set"),(0,r.yg)("p",null,"If we lose a downstream instance we load-balance across the remainder"),(0,r.yg)("p",null,"If we lose all downstream instances, we buffer up to our rentention limit of 1000 events or 1MB of event data."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Notice that we recover ",(0,r.yg)("strong",{parentName:"p"},"most")," but now all of the data. As the downstream websocket connection is not a guaranteed delivery connection the recovery and protection against data loss is best effort in this case")),(0,r.yg)("p",null,"In short, the transient in memory wal can assist with partial recovery and\nwill actively reduce data loss to within the configured retention but it is\nnot lossless. We can also use redundant downstream distribution endpoints to\nfurther insulate against catastrophic unrecoverable errors by adding the round\nrobin dispatch strategy and configuring multiple downstream endpoints."))}u.isMDXComponent=!0}}]);