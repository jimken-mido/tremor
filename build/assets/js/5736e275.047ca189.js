"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[41],{98836:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var o=t(58168),r=(t(96540),t(15680)),a=t(40281);const i={sidebar_label:"http",sidebar_position:1},s="The http Connector",c={unversionedId:"reference/connectors/http",id:"version-0.12/reference/connectors/http",title:"The http Connector",description:"The http connector provides integration against the HTTP protocol suite.",source:"@site/versioned_docs/version-0.12/reference/connectors/http.md",sourceDirName:"reference/connectors",slug:"/reference/connectors/http",permalink:"/docs/0.12/reference/connectors/http",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/reference/connectors/http.md",tags:[],version:"0.12",sidebarPosition:1,frontMatter:{sidebar_label:"http",sidebar_position:1},sidebar:"indexSidebar",previous:{title:"gpubsub_producer (Google Pub/Sub)",permalink:"/docs/0.12/reference/connectors/gpubsub_producer"},next:{title:"kafka",permalink:"/docs/0.12/reference/connectors/kafka"}},l={},p=[{value:"Configuration",id:"configuration",level:2},{value:"Client",id:"client",level:3},{value:"Server",id:"server",level:3},{value:"HTTP configuration example",id:"http-configuration-example",level:2},{value:"The complete annotated source",id:"the-complete-annotated-source",level:3},{value:"Metadata",id:"metadata",level:2},{value:"Request metadata",id:"request-metadata",level:3},{value:"Special cases",id:"special-cases",level:4},{value:"Response metadata",id:"response-metadata",level:3},{value:"Correlation metadata",id:"correlation-metadata",level:3}],d={toc:p},u="wrapper";function h(e){let{components:n,...t}=e;return(0,r.yg)(u,(0,o.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"the-http-connector"},"The ",(0,r.yg)("inlineCode",{parentName:"h1"},"http")," Connector"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"http")," connector provides integration against the HTTP protocol suite."),(0,r.yg)("h2",{id:"configuration"},"Configuration"),(0,r.yg)("h3",{id:"client"},"Client"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="config.troy"',title:'"config.troy"'},'define connector `http-out` from http_client\nwith\n  use std::time::nanos;\n  codec = "json",  # Defaults to HTTP codec\n  config = {\n    # Target URL for this HTTP client\n    "url": "http://host:80",\n\n    # Optional Transport Level Security configuration\n    # If url schme in `url` is `https` then TLS configuration is required\n    # "tls" = { ... },\n\n    # Optional authentication method, can be one of\n    # * "basic" - basic authentication\n    #   ```tremor\n    #      "auth" = { "basic": { "username": "snot", "password": "badger" } },\n    #   ```\n    # * "gcp"   - Google Cloud Platform\n    #   ```tremor\n    #    "auth" = "gcp", # See https://cloud.google.com/docs/authentication/getting-started\n    #  ```\n    # By default, no authentication is used\n    # "auth" = "none",\n\n    # HTTP method - defaults to `POST`, case insensitive\n    # "method" = "get",\n    \n    # Concurrency - number of simultaneous in-flight requests ( defaults to 4 )\n    # "concurrency" = 4,\n\n    # Request timeout - default is unset ( do not timeout )\n    # "timeout" = nanos::from_secs(10), # nanoseconds\n\n    # Optional default HTTP headers\n    # "headers" = { "key": "value", "other-key": ["v1", "v2"] },\n\n    # Custom Mime Codec Map, overrides default `codec`\n    # "custom_codecs" = {\n    #    # key defines the MIME type, value defines codec by name \n    #    "application/json": "json",\n    #    "application/yaml": "yaml"\n    # }\n  }\nend;\n')),(0,r.yg)("h3",{id:"server"},"Server"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="config.troy"',title:'"config.troy"'},'define connector `http-in` from http_server\nwith\n  codec = "json",\n  config = { \n    "url": "http://localhost:8080",\n\n    # Optional Transport Level Security configuration\n    # "tls" = { ... },\n\n    # Custom Mime Codec Map, overrides default `codec`\n    # "custom_codecs" = {\n    #    # key defines the MIME type, value defines codec by name \n    #    "application/json": "json",\n    #    "application/yaml": "yaml"\n    # }\n  }\nend;\n')),(0,r.yg)("h2",{id:"http-configuration-example"},"HTTP configuration example"),(0,r.yg)("p",null,"This is a relatively basic client server system that replays JSON formatted lines of data from a text file over HTTP to a server. The\nserver receives the JSON events and echo's them back to the HTTP client."),(0,r.yg)("p",null,"The client and server are implemented as tremor flows."),(0,r.yg)("p",null,"A high level summary of the overall flow:"),(0,r.yg)(a.K,{chart:"graph LR\n    A[JSON File] --\x3e|read line by line| B(HTTP Client)\n    B --\x3e|send json request| C{HTTP Server}\n    C{HTTP Server} --\x3e|receive json request| D(select event from in into out)\n    D --\x3e|echo json response| B{HTTP Client}\n    B --\x3e|log response| E[Log File]",mdxType:"Mermaid"}),(0,r.yg)("h3",{id:"the-complete-annotated-source"},"The complete annotated source"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define flow server\nflow\n  use integration;\n  use tremor::pipelines;\n  use tremor::connectors;\n\n  define connector http_server from http_server\n  with\n    codec = "json-sorted",\n    config = {\n      "url": "http://localhost:65535/",\n    }\n  end;\n\n  define pipeline instrument\n  pipeline\n    use std::array;\n    define window four from tumbling\n    with\n      size = 4\n    end;\n    select { "event": array::sort(aggr::win::collect_flattened(event)), "meta": array::sort(aggr::win::collect_flattened($)) } from in[four] into out;\n  end;\n\n  create pipeline instrument;\n  create connector stdio from connectors::console;\n  create connector http_server from http_server;\n\n  create pipeline echo from pipelines::passthrough;\n\n  # Echo http server: <http:req> -> server -> server_side -> <http:resp>\n  connect /connector/http_server to /pipeline/echo;\n  connect /pipeline/echo to /connector/http_server;\n  connect /pipeline/echo to /connector/stdio;\n\n  connect /connector/http_server to /pipeline/instrument;\n  connect /pipeline/instrument to /connector/stdio;\nend;\n\ndefine flow client\nflow\n  use integration;\n  use tremor::pipelines;\n  use tremor::connectors;\n\n  define connector http_client from http_client\n  with\n    codec = "json-sorted",\n    config = {\n      "url": "http://localhost:65535/",\n      "headers": {\n        "Client": "Tremor"\n      }\n    },\n    reconnect = {\n      "retry": {\n        "interval_ms": 100,\n        "growth_rate": 2,\n        "max_retries": 3,\n      }\n    }\n  end;\n\n  define pipeline collect\n  into out, exit\n  pipeline\n    use std::array;\n    use std::time::nanos;\n    define window four from tumbling\n    with\n      size = 4\n    end;\n    select array::sort(aggr::win::collect_flattened(event)) from in[four] into out;\n    select { "delay": nanos::from_seconds(1) } from in where event == "exit" into exit;\n  end;\n  create pipeline collect;\n\n  create connector data_in from integration::read_file;\n  create connector data_out from integration::write_file;\n  create connector exit from integration::exit;\n  create connector stdio from connectors::console;\n  create connector http_client from http_client;\n  create connector exit from connectors::exit;\n\n  create pipeline replay from pipelines::passthrough;\n  create pipeline debug from pipelines::passthrough;\n  \n\n  # Replay recorded events over http to server\n  connect /connector/data_in to /pipeline/replay;\n  connect /pipeline/replay to /connector/http_client;\n  connect /connector/http_client/out to /pipeline/collect;\n  connect /connector/http_client/err to /pipeline/debug;\n\n  connect /pipeline/collect to /connector/data_out;\n  connect /pipeline/debug to /connector/stdio;\n  # Terminate at end via `exit` event\n  connect /pipeline/collect/exit to /connector/exit;\nend;\n\ndeploy flow server;\ndeploy flow client;\n')),(0,r.yg)("h2",{id:"metadata"},"Metadata"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"http")," connector supports metadata allowing request and response\nprotocol metadata to be inspected, checked, and manipulated in advanced\nintegrations."),(0,r.yg)("p",null,"Metadata allows context information related to the payload data represented as a value in tremor to be decorated with context from\nconnectors and operators to control specific behaviours in a running\npipeline."),(0,r.yg)("h3",{id:"request-metadata"},"Request metadata"),(0,r.yg)("p",null,"Request metadata allows the HTTP method, headers and other other request parameters of the HTTP request to be overridden."),(0,r.yg)("p",null,"Request metadata can be set for an event"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"let $request = ...\n")),(0,r.yg)("p",null,"The request metadata is applied per request, and should be of ",(0,r.yg)("inlineCode",{parentName:"p"},"record")," type and structured as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'{\n  # Overrides the connector\'s default method HTTP for this request  \n  # -  Setting to an illegal HTTP VERB results in an error\n  "method": "GET", \n  # Overrides the endpoint, path and parameters for this request\n  # -  Care should be taken where authentication is use\n  # -  Setting to a non-http URL results in an error\n  "url": "https://some_host:8080/foo/bar/baz?a=b",\n  # Overrides the headers for this request, passing through unchanged default headers from configuration\n  "headers": { "x-snot": "y-badger", }\n}\n')),(0,r.yg)("h4",{id:"special-cases"},"Special cases"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"If a transfer encoding is specified as ",(0,r.yg)("inlineCode",{parentName:"li"},"chunked")," then chunked transfer encoding will be used for the request transfer"),(0,r.yg)("li",{parentName:"ul"},"If a mime type is set, and custom mime codec mappings are provided the\nuser supplied matching codec will be applied"),(0,r.yg)("li",{parentName:"ul"},"If a mime type is set, and no custom mapping matches, then the configured\nconnector codec will be applied, or the ",(0,r.yg)("inlineCode",{parentName:"li"},"json")," default if none is configured."),(0,r.yg)("li",{parentName:"ul"},"If possible the connector will attempt to set an appropriate content type"),(0,r.yg)("li",{parentName:"ul"},"If authentication is configured, authentication headers will follow the method supplied to the connector")),(0,r.yg)("h3",{id:"response-metadata"},"Response metadata"),(0,r.yg)("p",null,"Response metadata allows records the response parameters set against a HTTP request that\na response is issued against recording the decisions the ",(0,r.yg)("inlineCode",{parentName:"p"},"http_server")," connector makes\nwhen responding to requests."),(0,r.yg)("p",null,"The response can be read from the ",(0,r.yg)("inlineCode",{parentName:"p"},"$response")," metadata."),(0,r.yg)("p",null,"Response metadata takes the following general form:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'{\n  # The HTTP status code\n  "status": 200, \n  # Headers\n  "headers": { "x-snot": "y-badger", }\n  # The HTTP protocol version negotiated\n  "version": "1.1",\n}\n')),(0,r.yg)("h3",{id:"correlation-metadata"},"Correlation metadata"),(0,r.yg)("p",null,"Setting the ",(0,r.yg)("inlineCode",{parentName:"p"},"$correlation")," metadata on an outbound request will result in the response\nbeing tagged with the ",(0,r.yg)("inlineCode",{parentName:"p"},"$correlation")," value set in the corresponding request."))}h.isMDXComponent=!0}}]);