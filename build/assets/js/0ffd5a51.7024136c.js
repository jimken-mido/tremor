"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[9031],{2495:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(58168),n=(r(96540),r(15680));r(40281);const i={},o="Extractors",s={unversionedId:"reference/extractors/index",id:"version-0.12/reference/extractors/index",title:"Extractors",description:"The tremor-script language can recognize micro-formats and extract or elementize data from those micro-formats.",source:"@site/versioned_docs/version-0.12/reference/extractors/index.md",sourceDirName:"reference/extractors",slug:"/reference/extractors/",permalink:"/docs/0.12/reference/extractors/",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/reference/extractors/index.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"textual-length-prefix",permalink:"/docs/0.12/reference/preprocessors/textual-length-prefix"},next:{title:"base64",permalink:"/docs/0.12/reference/extractors/base64"}},l={},c=[{value:"Predicate Form",id:"predicate-form",level:2},{value:"Extraction Form",id:"extraction-form",level:2},{value:"Usage",id:"usage",level:2},{value:"Note",id:"note",level:2}],d={toc:c},p="wrapper";function m(e){let{components:t,...r}=e;return(0,n.yg)(p,(0,a.A)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"extractors"},"Extractors"),(0,n.yg)("p",null,"The ",(0,n.yg)("inlineCode",{parentName:"p"},"tremor-script")," language can recognize micro-formats and extract or elementize data from those micro-formats."),(0,n.yg)("p",null,"There are two basic variants of this in the language:"),(0,n.yg)("h2",{id:"predicate-form"},"Predicate Form"),(0,n.yg)("p",null,"In the predicate form the ",(0,n.yg)("inlineCode",{parentName:"p"},"~")," ( tilde ) operator performs a test to see if the\nassociated micro-format pattern matches a supplied value."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-tremor"},'match event of\n  case %{ level ~ re|^ERR.*$| } => "is an error"\n  default => "is not an error"\nend\n')),(0,n.yg)("p",null,"In the above example a regular expression ",(0,n.yg)("inlineCode",{parentName:"p"},"re")," extractor is tested ( by use of the ",(0,n.yg)("inlineCode",{parentName:"p"},"~")," test operator ) against the pattern form delimited by ",(0,n.yg)("inlineCode",{parentName:"p"},"|")," symbols. The field level ( that must exist on the event supplied, and requires that event is of record type ) is then tested against the regular expression."),(0,n.yg)("h2",{id:"extraction-form"},"Extraction Form"),(0,n.yg)("p",null,"The extraction for is similar. In this case the predicate conditions must pass, but the regular expression can be written with match groups and named matches extracted into a key/value record for further processing."),(0,n.yg)("h2",{id:"usage"},"Usage"),(0,n.yg)("p",null,"Both the predicate and extraction form of extraction use operators with a ",(0,n.yg)("inlineCode",{parentName:"p"},"~")," ( tilde ) operator. When ",(0,n.yg)("inlineCode",{parentName:"p"},"~=")," the micro-format in use ( a regular expression in our example ) acts as both a predicate test ( is it valid given the test specification ) and an extractor that elementizes and returns a subset of information from the micro-format."),(0,n.yg)("p",null,"When only validity against the pattern is desired, then the extraction overhead can be eliminated or reduced depending on the implementation of the extractor configured."),(0,n.yg)("p",null,"Extractors implicitly check if a field is present. If a field isn't present in the record, the predicate will fail and it will check the next predicate. Thus, no further explicit check such as ",(0,n.yg)("inlineCode",{parentName:"p"},"present <field>")," is required."),(0,n.yg)("h2",{id:"note"},"Note"),(0,n.yg)("p",null,"Extractors should not be followed by a function that uses the same field as the one in the extractor. This could result in unintended behaviour as the latter function might return the original value instead of the extracted value"),(0,n.yg)("p",null,"e.g."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-tremor"},'match { "superman" = "message_key: ruler: batman" } of\n  case r = %{superman ~= grok|(?<message_key>(.\\|\\\\n){0,200})|, present superman}\n    => let event.new_ruler = r.superman.name\n default => "switch to marvel"\nend;\n')),(0,n.yg)("p",null,"This will result in unintended behaviour because ",(0,n.yg)("inlineCode",{parentName:"p"},"present")," will return the original string instead of the record extracted by grok."))}m.isMDXComponent=!0}}]);