"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[7664],{13090:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(58168),r=(n(96540),n(15680));const o={title:"Case Study - Multi-Participant Transaction Orchestration",tags:["case-study","wayfair"],author:"The Tremor Team",author_url:"https://github.com/tremor-rs",author_image_url:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4",image:"./media/wayfair.png",draft:!1,hide_table_of_contents:!1},i="Multi-Participant Transaction Orchestration",s={permalink:"/blog/2021/11/07/search",editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/blog/2021-11-07-search.md",source:"@site/blog/2021-11-07-search.md",title:"Case Study - Multi-Participant Transaction Orchestration",description:"The support for multi-participant transaction orchestration in tremor",date:"2021-11-07T00:00:00.000Z",formattedDate:"November 7, 2021",tags:[{label:"case-study",permalink:"/blog/tags/case-study"},{label:"wayfair",permalink:"/blog/tags/wayfair"}],readingTime:8.67,hasTruncateMarker:!1,authors:[{name:"The Tremor Team",url:"https://github.com/tremor-rs",imageURL:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4"}],frontMatter:{title:"Case Study - Multi-Participant Transaction Orchestration",tags:["case-study","wayfair"],author:"The Tremor Team",author_url:"https://github.com/tremor-rs",author_image_url:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4",image:"./media/wayfair.png",draft:!1,hide_table_of_contents:!1},prevItem:{title:"Case Study - Unified Observability Platform",permalink:"/blog/2021/11/08/uop"},nextItem:{title:"Case Study - Modularity, Oh My",permalink:"/blog/2021/11/06/modularity"}},l={image:n(21697).A,authorsImageUrls:[void 0]},c=[{value:"Identified Need",id:"identified-need",level:2},{value:"Required Outcome",id:"required-outcome",level:2},{value:"Characteristics",id:"characteristics",level:3},{value:"Solution",id:"solution",level:2},{value:"We can configure the <code>wal</code> operator",id:"we-can-configure-the-wal-operator",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},m="wrapper";function u(e){let{components:t,...o}=e;return(0,r.yg)(m,(0,a.A)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"The support for multi-participant transaction orchestration in tremor\noriginates with this use case from Wayfair's Search platform services\nteam."),(0,r.yg)("h2",{id:"identified-need"},"Identified Need"),(0,r.yg)("p",null,"One of the frequent requests made of the tremor team by peers in the\nInfrastructure organization at Wayfair has come from the search domain.\nSearch is a critical service at Wayfair and it is the powerplant behind\nmany other services - ranging from recommendation engines through to\nauditing of data streams that are continually being ingested and indexed\ninto multiple searchable databases."),(0,r.yg)("p",null,"At a very high level - streams of documents need to be elementized and\nbroken down into one or many indexable items of interest - these items\nthen need to be indexed ( successfully ) into one or many search\nengines."),(0,r.yg)("p",null,"Many of the use cases that are battle tested with tremor are relevant in\nthis domain:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Cleansing, normalization and enrichment of documents and indexable\nelementization and tracking documents and elementized items"),(0,r.yg)("li",{parentName:"ul"},"Rate limiting, capacity-based load-shedding, with domain classification\nsimilar to the traffic shaping use cases where tremor started"),(0,r.yg)("li",{parentName:"ul"},"Sourcing, transformation and distribution of documents and the\nsynthetic events in real-time at low or very low latencies")),(0,r.yg)("p",null,"But, for the use case at hand, there are additional needs:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"All documents must be processed transactionally, without loss and\nwith proper reporting of processing outcome to upstream services and\nthe documents must be processed in arrival order. The guaranteed\ndelivery and circuit-breaker mechanisms in tremor now need to be\nmulti-pipeline."),(0,r.yg)("li",{parentName:"ul"},"All indexable elements of all documents must be indexed in multiple\ndownstream engines successfully ( or operator errors produced for\nexceptions ) while all possible error cases need to be caught and\nreported upstream in order to issue retries or let operators\nintervene. This is a reasonably orchestration mapping processed elements and tracing\nback to the documents the elements were produced from before publication\ndown stream."),(0,r.yg)("li",{parentName:"ul"},"There is significant variability, variant on a case by case basis, to the exact semantics\nrequired for different document types to be processed to a varying number of downstream\nindexing systems and technologies. The solution needs to be modular")),(0,r.yg)("p",null,"Gathering and aggregating multiple parallel processing outcomes and\nsubsuming them under a common transaction is outside of the baseline\nscope of message-based and message-like systems as they typically only\nsupport point-to-point transactions. Correlation across multiple event\nstreams usually needs to be solved on the application level. Where\nsystems support orchestrated transactions - these are typically\nconstrained by transport/protocol or other factors beyond the\napplication authors control, and therefore inflexible under variant (\nand often fast-changing ) production needs."),(0,r.yg)("h2",{id:"required-outcome"},"Required Outcome"),(0,r.yg)("p",null,"Expand on tremor\u2019s QoS facilities so that multi-participant transaction\norchestration is possible, easily composable and user programmable."),(0,r.yg)("h3",{id:"characteristics"},"Characteristics"),(0,r.yg)("p",null,"The original use cases for tremor were relatively straightforward and\ndata distribution applications with a requirement for traffic shaping\nand rate limiting for data streams when downstream systems were prone to\nbeing overwhelmed at peak traffic conditions."),(0,r.yg)("p",null,"These occurrences were rare - but their impact was high when they\nhappened. And in an infrastructure with higher high peaks year on year\nthis is an ever-present hazard of doing business."),(0,r.yg)("p",null,"More recently, delivery guarantees are expanding as new domains adopt\ntremor in production. In these domains data loss, even user defined and\nstrictly capacity managed traffic shaping, is not tolerable.  "),(0,r.yg)("p",null,"Like with many real-time systems - the percentage of the overall\nin-flight volumetric that requires transactional delivery is typically a\nsmall subset of the overall firehose. Take financial trading systems for\nexample - orders and trades are transactional and they need to be\nprocessed, each and every one, correctly - as there are fiscal and\nregulatory conditions that need to be strictly met.  "),(0,r.yg)("p",null,"But pricing - the ability to buy or sell and equity, or the current\ncurrency rate is often naturally continuously changing due to supply and\ndemand, and naturally redundant - as you can buy or sell the same stock\non many different venues."),(0,r.yg)("p",null,"The search case stretches the QoS mechanisms in tremor and the internal\nmechanisms used to track events as they are processed from a single set\nof flows and a small set of participants - to larger and more complex\nuser defined flows that orchestrate transactions of arbitrary\ncomplexity.  "),(0,r.yg)("p",null,"This is compounded by tremor-based applications today being large,\nincreasingly sophisticated and modular. So the QoS mechanisms that were\noriginally constrained to the boundary of a single pipeline - now need\nto be preserved and propagated across an entire deployment."),(0,r.yg)("h2",{id:"solution"},"Solution"),(0,r.yg)("p",null,"Tremor\u2019s core processing element - pipelines - are executable\ndirected-acyclic graphs."),(0,r.yg)("p",null,"A tremor user designs a workflow or pipeline using the tremor query\nlanguage."),(0,r.yg)("p",null,"Tremor converts this to a directed graph and makes sure that it is\nacyclic."),(0,r.yg)("p",null,"Tremor transforms and optimizes the user defined graph to an executable\nform that is well-structured for easily supporting easy to understand\nand easy to define qualities of service."),(0,r.yg)("p",null,"If we imagine the pipeline graph as a single larger directed-acyclic\ngraph we have what tremor actually uses for event distribution\ninternally. Tremor can distribute and process user defined events -\nthese are business or data events that originate from connectors or user\ndefined logic.  "),(0,r.yg)("p",null,"Tremor can inject control events - these are runtime events that tremor\nuses for quality of service and they are not ordinarily user visible.\nTremor can also inject events originating at outputs ( or that propagate\nfrom downstream systems ) backwards to inputs ( or for propagation to\nupstream systems ). But, we can do so without introducing cycles."),(0,r.yg)("p",null,"The user-defined graph is acyclic. But the tremor runtime has, in\neffect, the ability to coordinate acknowledgements for user-defined\nevents and an ability to signal upstream breaks in connectivity to\ndownstream systems, or downstream breaks to upstream systems. These\nruntime control events - we call them signal-flow and contra-flow - are\ntransparent to users.  "),(0,r.yg)("p",null,"Our ",(0,r.yg)("inlineCode",{parentName:"p"},"wal")," ( write-ahead-log ) operator produces and consumes\nsignal-flow and contra-flow events.  "),(0,r.yg)("p",null,"So, given a simple tremor application that has no defined QoS ( it does\nnot use guaranteed delivery )  "),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle",metastring:'title="/etc/tremor/config/lossy.trickle"',title:'"/etc/tremor/config/lossy.trickle"'},"select patch event of\n  insert hostname = system::hostname()\nend\nfrom in into out;\n")),(0,r.yg)("h3",{id:"we-can-configure-the-wal-operator"},"We can configure the ",(0,r.yg)("inlineCode",{parentName:"h3"},"wal")," operator"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle",metastring:'title="/etc/tremor/config/mostly_guaranteed.trickle"',title:'"/etc/tremor/config/mostly_guaranteed.trickle"'},"\nuse tremor::system;\n\ndefine qos::wal operator in_memory_wal\n\nwith  \n read_count = 20,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ncreate operator in_memory_wal;\nselect patch event of\n  insert hostname = system::hostname()\nend\nfrom in into in_memory_wal;\n\nselect event from in_memory_wal into out;\n")),(0,r.yg)("p",null,"This is a logically equivalent application - but we can tolerate a lag\nof up to 1000 events or 1 megabyte of data before losing data. Under the\nhood of course - events are now tracked and traced. If connectors are\nQoS aware then we now have a more robust application."),(0,r.yg)("p",null,"So if we are consuming from a kafka cluster upstream and distributing to\nanother kafka cluster downstream ( such as in another data center ) -\nthose systems can go offline briefly or be disconnected. The connectors\nthemselves handle lossless delivery ( that\u2019s handled by kafka in both\ncases in this example ). Connectors with less strong guarantees can\nstill be ( mostly ) lossless - so if our downstream system is HTTP-based\n( like elasticsearch ) - we can tolerate transient service loss and\nfully recover.  "),(0,r.yg)("p",null,"What if tremor or the host it is deployed on is rebooted?"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle",metastring:'title="/etc/tremor/config/mostly_guaranteed.trickle"',title:'"/etc/tremor/config/mostly_guaranteed.trickle"'},"use tremor::system;\ndefine qos::wal operator in_memory_wal\nwith  \n  dir = \u201d./recovery\u201d, # Persistent file-based recovery file\n  read_count = 20,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ncreate operator in_memory_wal;\nselect patch event of\n  insert hostname = system::hostname()\nend\n\nfrom in into in_memory_wal;\n\nselect event from in_memory_wal into out;\n")),(0,r.yg)("p",null,"The tremor developer doesn\u2019t need to be too concerned with the internal\nmechanisms, or their implementation. And for simple applications with a\nsingle primary data flow, its as easy as the examples above to\nselectively introduce grades of guaranteed delivery with a spectrum of\nrobustness that derives from choice of connectivity ( kafka vs http ) or\nhow the ",(0,r.yg)("a",{parentName:"p",href:"https://www.tremor.rs/docs/tremor-query/operators/"},"qos"),"\noperators are chosen, placed in a flow, and configured."),(0,r.yg)("p",null,"Orchestration however, is different. In an orchestrated transaction the\nuser defined logic provided by the tremor developer also needs to do\nsome tracking. This is achieved through using tremor\u2019s state mechanism\nalongside the ",(0,r.yg)("inlineCode",{parentName:"p"},"qos")," capabilities and operators that tremor provides to\ncompose a solution.  "),(0,r.yg)("p",null,"So, in our search case - let us say we have two downstream search\nengines - and both need to index a different set of items of interest\nelementized from a single document - we use the state mechanism to track\nprogress of the items for each participant - and when all participants\nhave indexes up to date - we issue a synthetic event ( that can be\nrecorded in a wal ) that publishes the document processing status\ndownstream."),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"search logic",src:n(68241).A,width:"960",height:"720"})),(0,r.yg)("p",null,"So our document source is kafka, our indexing engines for elementized\nitems and our destination for successfully elementized documents ( which\nmay now be enriched with elementization metadata and index metadata )\ncan now be published ( let\u2019s assume kafka again for simplicity ) to an\naudited topic.  "),(0,r.yg)("p",null,"The state mechanism in tremor is a readable/writable value - so\npersistent and recoverable state is a relatively simple composition:  "),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define script remember\nscript\n  let state = event;\n  event\nend;\n\ndefine qos::wal operator forget_me_not\nwith\n  dir = "./brain",\n  read_count = 1,\n  max_elements = 1000, # Capacity limit of 1000 stored events\n  max_bytes = 10485760 # Capacity limit of 1MB of events\nend;\n\ncreate script remember;\ncreate operator forget_me_not;\nselect event from in into remember;\nselect event from remember into forget_me_not;\nselect event from forget_me_not into out;\n')),(0,r.yg)("p",null,"Please don\u2019t run out of disk space!"),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"Most of the changes required to evolve tremor form supporting great qos\nfor simple single pipeline applications to complex multi-pipeline and\nmulti-participant stateful orchestrations did not expose new features to\nthe tremor developer or user.  "),(0,r.yg)("p",null,"It has been a significant change to tremor internals, however and the\nwork reaches a stable point with our ",(0,r.yg)("inlineCode",{parentName:"p"},"0.12")," release - the ability to\n",(0,r.yg)("inlineCode",{parentName:"p"},"pause")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"resume")," connectors, and the ability for the tremor\nruntime itself to detect and act on ",(0,r.yg)("inlineCode",{parentName:"p"},"quiescence")," will mean that tremor\nis flexible enough for the demands and use cases that originated in the\nsearch domain."))}u.isMDXComponent=!0},68241:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/image1-cb4dd9235b1af1100251fcd71cac1652.png"},21697:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/wayfair-b0bafac5cf230fcd5e29c8cb4560c334.png"}}]);