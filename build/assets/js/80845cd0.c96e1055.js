"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6139],{44983:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>n,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>h});var r=a(58168),o=(a(96540),a(15680));const s={title:"To async or Not to async",author:"The Tremor Team",author_image_url:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4",tags:["dev","rust"],draft:!1,image:"/img/async.png",description:"Moving from threads to async tasks."},n=void 0,i={permalink:"/blog/2020/08/06/to-async-or-not-to-async",editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/blog/2020-08-06-to-async-or-not-to-async.md",source:"@site/blog/2020-08-06-to-async-or-not-to-async.md",title:"To async or Not to async",description:"Moving from threads to async tasks.",date:"2020-08-06T00:00:00.000Z",formattedDate:"August 6, 2020",tags:[{label:"dev",permalink:"/blog/tags/dev"},{label:"rust",permalink:"/blog/tags/rust"}],readingTime:5.525,hasTruncateMarker:!0,authors:[{name:"The Tremor Team",imageURL:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4"}],frontMatter:{title:"To async or Not to async",author:"The Tremor Team",author_image_url:"https://avatars.githubusercontent.com/u/60009416?s=200&v=4",tags:["dev","rust"],draft:!1,image:"/img/async.png",description:"Moving from threads to async tasks."},prevItem:{title:"Releasing Tremor v0.9!",permalink:"/blog/2020/10/16/v09-release"},nextItem:{title:"Rust & Tell Berlin- March 2020",permalink:"/blog/2020/03/31/rust-and-tell"}},c={authorsImageUrls:[void 0]},h=[{value:"The Tremor That Was (threads)",id:"the-tremor-that-was-threads",level:2}],l={toc:h},m="wrapper";function d(e){let{components:t,...a}=e;return(0,o.yg)(m,(0,r.A)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"With the upcoming Tremor release, 0.9.0, we're moving from threads as a basis for ramps and pipelines to async tasks."),(0,o.yg)("p",null,"Let's talk about why this is significant, what is changing, and how the architecture is changing."),(0,o.yg)("p",null,"Note that this is not a comprehensive treatise on threads or async tasks."),(0,o.yg)("h2",{id:"the-tremor-that-was-threads"},"The Tremor That Was (threads)"),(0,o.yg)("p",null,"Threads are a basic building block of programs that run multiple pieces of code concurrently.\nThe operating system is responsible for coordinating across competing resource demands."),(0,o.yg)("p",null,"The OS can preempt, pause, and resume threads. We can leverage infinite or tight loops without the risk of completely blocking the system. These guarantees make concurrent code more accessible, with tools like",(0,o.yg)("inlineCode",{parentName:"p"},"crossbeam-channels")," to build upon."),(0,o.yg)("p",null,"Threads work especially well in use cases where the system and logical concurrency models are well aligned; or, we can map application threads to logical cores on the system being used. Each thread can happily work away on its part of the logic and pass the result on to the next. The one thread per core model is what tremor 0.8 and earlier used. We had a thread for the onramp, a thread for the pipeline, and a thread for the offramp. As the computational cost of decoding, processing, and encoding was often in the same ballpark, this worked exceptionally well. We managed to push up to 400MB/s of JSON through the system this way (including parsing, tremor-script logic, and serialization)."),(0,o.yg)("p",null,"This design can degenerate badly if there are more ramps and pipelines than cores on the system in use. Throughput degrades rapidly (as in up to 2 orders of magnitude worse at 30:1 ratio). At the time of writing this, the deployment model was one pipeline/ramp group on a four-core system, so it worked well in practice."),(0,o.yg)("p",null,"However, this places a burden on operators having to think about concurrency and parallelism to tune tremor for optimal performance and capacity."),(0,o.yg)("p",null,"In SMP systems, we observe other undesireable effects: The moment two communicating threads don't share the same underlying cache, performance plummets. This scenario exists when threads reside on two different CPUs or CCXs (",(0,o.yg)("a",{parentName:"p",href:"https://blog.licenser.net/2020/01/multithreaded-rust-on-threadripper/"},"thank you AMD for making me learn so much about CPU caches"),"). As long as two communicating threads share the same cache, data shared between them can avoid trips to main memory and cache coherency protocol overheads. When two threads communicate across different caches, reads/writes may catastrophically collide and introduce overheads that drastically reduce overall performance."))}d.isMDXComponent=!0}}]);