"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6174],{15902:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var t=a(58168),r=(a(96540),a(15680)),o=a(40281);const i={},l="Language",s={unversionedId:"language/index",id:"version-0.12/language/index",title:"Language",description:"Tremor provides a scripting language for defining and deploying event flows.",source:"@site/versioned_docs/version-0.12/language/index.md",sourceDirName:"language",slug:"/language/",permalink:"/docs/0.12/language/",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/language/index.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"index",permalink:"/docs/0.12/api/"},next:{title:"Pipelines",permalink:"/docs/0.12/language/pipelines"}},p={},d=[{value:"Flows",id:"flows",level:2},{value:"Definition",id:"definition",level:3},{value:"Deploy",id:"deploy",level:3},{value:"Pipelines",id:"pipelines",level:2},{value:"Operators",id:"operators",level:3},{value:"Scripts",id:"scripts",level:2},{value:"Events",id:"events",level:2},{value:"Type system",id:"type-system",level:2},{value:"Define and Create",id:"define-and-create",level:2},{value:"Define",id:"define",level:3},{value:"Create",id:"create",level:3},{value:"Modules",id:"modules",level:2},{value:"Example",id:"example",level:3},{value:"TREMOR_PATH",id:"tremor_path",level:3},{value:"Arguments",id:"arguments",level:2}],g={toc:d},c="wrapper";function u(e){let{components:n,...a}=e;return(0,r.yg)(c,(0,t.A)({},g,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"language"},"Language"),(0,r.yg)("p",null,"Tremor provides a scripting language for defining and deploying event flows.\nIt is called ","[Troy]"," - The Tremor Deployment language."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"../reference/connectors"},"Connectors")," providing connectivity to the outside world, "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/pipelines"},"Pipelines")," representing the actual stream processing and event handling "),(0,r.yg)("li",{parentName:"ul"},"and the Connections of both, forming a complete and self-contained Flow of Events.")),(0,r.yg)("p",null,"Troy is used on every level of event processing, starting from the plumbing that provides connectivity to the outside world in the form of a ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow"),", ranging over ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines")," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Scripts")," for expressing complex event routing, filtering, event introspection and transformation, towards the final step of deploying your application and bringing it to production via ",(0,r.yg)("a",{parentName:"p",href:"#deploy"},"Deploy"),"."),(0,r.yg)("h2",{id:"flows"},"Flows"),(0,r.yg)("p",null,"A Flow encapsulates your event flow: the definition of where events should come from, how you want to handle, route, slice and dice them and where to they are sent out: The physical routing, or as we call it, the plumbing. This is where you get your hands dirty and greasy. It is also the unit of Deployment in Tremor. You bring a whole Flow live by ",(0,r.yg)("a",{parentName:"p",href:"#deploy"},"Deploy"),"ing it. Any Tremor server can host many Flows in parallel. You can deploy multiple versions of your Flow to increase parallelism (e.g. have multiple consumers consumer from your kafka topic and send the events downstream after normalizing them to a common format)."),(0,r.yg)("p",null,"Flows are self-contained, sealed units and cannot communicate with each other. Thus users usually want to encapsulate their application in a single Flow and put unrelated event flows in separate ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flows"),"."),(0,r.yg)("h3",{id:"definition"},"Definition"),(0,r.yg)("p",null,"As all other entities in Tremor, ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flows")," need to be defined:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define flow flowy_mc_flowface\nargs\n    url = "localhost:12345"\nflow\n    # import some predefined pipelines\n    use tremor::pipelines;\n    \n    # lets define a connector and parameterize it by the url\n    define connector my_udp from udp_server\n    args\n        url\n    with\n        config = {\n            "url": args.url # pass on the url from the arguments\n        },\n        codec = "json"\n    end;\n\n    # create an instance from the pipeline definitions imported above\n    create pipeline passthrough from pipelines::passthrough;\n    \n    # create a connector instance and pass through the url argument from the flow definition\n    create connector my_udp\n    with\n        url = args.url\n    end;\n\n    # let the events flow from conny through passthrough and then back to my_udp\n    connect /connector/my_udp to /pipeline/passthrough;\n    connect /pipeline/passthrough to /connector/my_udp;\nend;\n')),(0,r.yg)("p",null,"Here we have all the bits and pieces that comprise a full fledged Tremor Application:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"We define where events should come from by defining a connector. In this case we receive events from UDP packets and interpret them as JSON."),(0,r.yg)("li",{parentName:"ul"},"We define how to handle events. In this case we just want to pass them through unchanged, so we use a predefined ",(0,r.yg)("inlineCode",{parentName:"li"},"passthrough")," pipeline."),(0,r.yg)("li",{parentName:"ul"},"We define the final event flow by using the ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/reference/deploy#rule-connect"},(0,r.yg)("inlineCode",{parentName:"a"},"connect"))," statements to route events from our connector ",(0,r.yg)("inlineCode",{parentName:"li"},"conny")," through our passthrough pipeline ",(0,r.yg)("inlineCode",{parentName:"li"},"pippi")," and back to our ",(0,r.yg)("inlineCode",{parentName:"li"},"udp_server")," connector. We essentially formed a UDP echo server.")),(0,r.yg)("p",null,"This definition will also make the ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," with the id ",(0,r.yg)("inlineCode",{parentName:"p"},"flowy_mc_flowface")," available for ",(0,r.yg)("a",{parentName:"p",href:"#deploy"},"Deploy"),"ing it in order to bring it to live and let the events flow through it."),(0,r.yg)("h3",{id:"deploy"},"Deploy"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"It is important to know that a ",(0,r.yg)("a",{parentName:"p",href:"#define-and-create"},(0,r.yg)("inlineCode",{parentName:"a"},"define"))," will never start or deploy anything, it will only create a configuration template that can be ",(0,r.yg)("a",{parentName:"p",href:"#define-and-create"},(0,r.yg)("inlineCode",{parentName:"a"},"created")),"."),(0,r.yg)("p",{parentName:"admonition"},"So don't forget to ","[",(0,r.yg)("inlineCode",{parentName:"p"},"deploy"),"]"," your flow!")),(0,r.yg)("p",null,"How to actually deploy this flow, you might ask? Wait no longer, your thirst for answer will be satisfied:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"deploy flow flowy_mc_flowface;\n")),(0,r.yg)("p",null,"This statement will deploy an instance of ",(0,r.yg)("inlineCode",{parentName:"p"},"flowy_mc_flowface")," and bring it live with the provided port. You can deploy multiple different ",(0,r.yg)("inlineCode",{parentName:"p"},"flowy_mc_flowface")," Flows with different settings provided as parameters in the ",(0,r.yg)("inlineCode",{parentName:"p"},"with")," clause. Your Flow acts as a configurable template. For more details, see ",(0,r.yg)("a",{parentName:"p",href:"#arguments"},"Arguments"),"."),(0,r.yg)("h2",{id:"pipelines"},"Pipelines"),(0,r.yg)("p",null,"In the above ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," we used a very simple ",(0,r.yg)("inlineCode",{parentName:"p"},"passthrough")," pipeline, as we didn't want to modify the events we got in in any form.\nThe thing is, usually you do. Or you want to inspect them and route them based on their log-level, for example, or just drop them because you just got too much events from the upstream system. This is what pipelines are for."),(0,r.yg)("p",null,"Pipelines are self-contained units that define your application logic, the logical routing. It is usually independent of where the input events come from and go to. As with all entities in Tremor, ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines")," need to be defined and created. They also need to be ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-connect"},(0,r.yg)("inlineCode",{parentName:"a"},"connect")),"ed to have events flow through them. This is all done inside a ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow"),", as we have seen in action above."),(0,r.yg)("p",null,"Pipelines have input (",(0,r.yg)("inlineCode",{parentName:"p"},"in"),") and output (",(0,r.yg)("inlineCode",{parentName:"p"},"out"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"err"),") ports, which can be configured upon definition. All events come from one of the configured input ports. Every pipelines actually forms a graph (a directed acyclic graph) with edges spanning from the input ports to operators and finally to the output ports. Events flow along the edges and are processed by the operators."),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," statements are what connects the input/output ports and the processing operators. As the name suggests, they are similar to the ",(0,r.yg)("inlineCode",{parentName:"p"},"SQL SELECT"),". They support filtering out events by a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/query#rule-whereclause"},(0,r.yg)("inlineCode",{parentName:"a"},"where"))," clause,  "),(0,r.yg)("p",null,"The simplest kind of pipeline is the passthrough pipeline we used above:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"define pipeline passthrough\npipeline\n    select event from in into out;\nend;\n")),(0,r.yg)(o.K,{chart:"graph LR\nIN([in]) --\x3e OUT([out])",mdxType:"Mermaid"}),(0,r.yg)("p",null,"Lets add an operator in the middle and only send those events through it that have a ",(0,r.yg)("inlineCode",{parentName:"p"},"log_level")," field with the value ",(0,r.yg)("inlineCode",{parentName:"p"},'"info"'),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define pipeline passthrough\npipeline\n    # define the operator - here we batch events up in groups of 100\n    define operator batch from generic::batch\n    with\n        count = 100\n    end;\n    # create an instance of the operator\n    create operator my_batch from batch;\n\n    # select the log_level = "info" events into the batch operator and into the out port\n    select event from in where event.log_level == "info" into my_batch;\n    select event from my_batch into out;\n    # pass through all the others\n    select event from in where event.log_level != "info" into out;\nend;\n')),(0,r.yg)(o.K,{chart:'graph LR\nIN([in]) --\x3e|"event.log_level == \\"info\\""| BATCH([my_batch]) --\x3e OUT([out])\nIN --\x3e|"event.log_level != \\"info\\""| OUT',mdxType:"Mermaid"}),(0,r.yg)("p",null,"This looks more interesting, doesn't it? We defined and created an operator, which now forms a node in out event processing graph. We used the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," statements to route only certain events into the operator, all others go straight to the ",(0,r.yg)("inlineCode",{parentName:"p"},"out")," port and leave the pipeline."),(0,r.yg)("p",null,"This is the basic structure of a Pipeline. The basic concepts you need to understand to work with them. For more details check out our ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," article."),(0,r.yg)("h3",{id:"operators"},"Operators"),(0,r.yg)("p",null,"Operators are the nodes in a Pipeline graph, connected by ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," statements. Similar to ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines"),", Operators have ports for connecting them to other operators or pipeline input/output ports. The default ports are ",(0,r.yg)("inlineCode",{parentName:"p"},"in")," for input and ",(0,r.yg)("inlineCode",{parentName:"p"},"out")," for output and ",(0,r.yg)("inlineCode",{parentName:"p"},"err")," for erroneous output. Some Operators have custom ports. To find out which, check the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/"},"Documentation"),"."),(0,r.yg)("p",null,"They can keep internal state between events flowing through them, which makes them quite powerful."),(0,r.yg)("p",null,"Tremor provides a list of builtin ",(0,r.yg)("a",{parentName:"p",href:"../reference/operators"},"Operators"),". E.g. for ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/batch"},(0,r.yg)("inlineCode",{parentName:"a"},"generic::batch"))," for batching up events or ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/backpressure"},(0,r.yg)("inlineCode",{parentName:"a"},"qos::backpressure"))," for applying backpressure towards upstream systems if a downstream system fails or takes to long to handle events."),(0,r.yg)("p",null,"If you want to create your own custom operator, you can use a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Script"),", which is handled in the next section."),(0,r.yg)("h2",{id:"scripts"},"Scripts"),(0,r.yg)("p",null,"Scripts are a special kind of Operator. While others are simply configured and perform their event-processing in optimized Rust code, Scripts execute your Tremor code. They also have a special syntax:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define script my_script\nscript\n    let value = \n      match event of\n        case %{ present snot } => "badger"\n        case "stringy" => "string"\n        case 42 => "the answer"\n      end;\n    emit {\n      "original_event": event,\n      "derived_value": value\n    };\nend;\ncreate script my_script;\n')),(0,r.yg)("p",null,"This script inspects the event and derives a value depending on the type and shape of the event. It then emits a transformed value containing the original event and the derived value as the outgoing event."),(0,r.yg)("p",null,"Scripts give users the most control over how to inspect, filter and transform an event. With their ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#state"},"state")," mechanism, they can also work on streams of events (e.g. for creating aggregates or implementing state machines)."),(0,r.yg)("p",null,"So, if you want to implement some complex ETL logic on your event streams, if you want to manipulate event metadata or implement other more complex logic than is expressable in a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," statement, a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Script")," should be your tool of choice."),(0,r.yg)("h2",{id:"events"},"Events"),(0,r.yg)("p",null,"So what exactly is this event thing that is routed from ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connectors")," through pipelines and processed in and emitted from scripts?"),(0,r.yg)("p",null,"An event is a discrete unit of an event stream. An incoming raw data stream is separated into distinct byte chunks either by the ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connector")," itself (e.g. in the case of UDP, each packet will be treated as distinct unit) or by ",(0,r.yg)("a",{parentName:"p",href:"../reference/preprocessors"},"Preprocessors")," configured on the input ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connector"),". Then the configured ",(0,r.yg)("a",{parentName:"p",href:"../reference/codecs"},"Codec")," is decoding the byte chunk into the structured event payload."),(0,r.yg)("p",null,"Each event consists of:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"payload (accessible via the reserved ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#reserved-paths"},(0,r.yg)("inlineCode",{parentName:"a"},"event")," path")),(0,r.yg)("li",{parentName:"ul"},"event metadata, initially added by the ",(0,r.yg)("a",{parentName:"li",href:"../reference/connectors"},"Connector")," this event originated at, accessible via the reserved ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#reserved-paths"},(0,r.yg)("inlineCode",{parentName:"a"},"$")," path")," modifiable by ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/scripts"},"Scripts")," "),(0,r.yg)("li",{parentName:"ul"},"an event id, for uniquely identifying the event inside the system"),(0,r.yg)("li",{parentName:"ul"},"an ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/reference/stdlib/tremor/system#ingestns"},"ingestion timestamp")," in nanosecond resolution"),(0,r.yg)("li",{parentName:"ul"},"an ",(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/reference/stdlib/tremor/origin"},(0,r.yg)("inlineCode",{parentName:"a"},"origin_uri"))," for identifying the event origin (e.g. a TCP connection peer)")),(0,r.yg)("h2",{id:"type-system"},"Type system"),(0,r.yg)("p",null,"All values in Tremor, be it event payload, metadata, local variables, state or anything else, everything is a part of the Tremor type system. The type system is roughly modelled to support all values that can be represented as JSON, with some extensions."),(0,r.yg)("p",null,"Tremor is dynamically typed, that means variables do not have a static type determined at compile time. But they can have any possible type. Treating values as different types than they actually are will lead to errors. E.g. accessing a nested field on a value that is actually a string."),(0,r.yg)("p",null,"Possible types for tremor values are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#null"},(0,r.yg)("inlineCode",{parentName:"a"},"null"))," - represents a JSON ",(0,r.yg)("inlineCode",{parentName:"li"},"null"),", an otherwise undefined value"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#boolean"},"booleans")," - ",(0,r.yg)("inlineCode",{parentName:"li"},"true")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"false")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#integer-numerics"},"integers")," - integers"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#floating-point-numerics"},"floats")," - floating point numbers"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#utf-8-encoded-strings"},"strings")," - UTF-8 encoded strings"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#arrays"},"arrays")," - arrays of arbitrarily typed values, also different types"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#records"},"records")," - mappings from string names to arbitrarily typed values"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"/docs/0.12/language/expressions#binary"},"binary")," - raw binary data")),(0,r.yg)("p",null,"To check for the type of a value, use either a function in the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/stdlib/std/type"},(0,r.yg)("inlineCode",{parentName:"a"},"std::type")," module")," or some of the modules for handling specific types, like integers: ",(0,r.yg)("a",{parentName:"p",href:"../reference/stdlib/std/integer"},"std::integer")," inside a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#match"},"match"),"."),(0,r.yg)("h2",{id:"define-and-create"},"Define and Create"),(0,r.yg)("p",null,"We tried to keep the language as consistent and free of surprises as possible. As such, all entities in Tremor: ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flows"),", ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connectors"),", ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines"),", ",(0,r.yg)("a",{parentName:"p",href:"../reference/operators"},"Operators"),", ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Scripts")," and others, all follow the same pattern: ",(0,r.yg)("strong",{parentName:"p"},"Define and Create"),"."),(0,r.yg)("h3",{id:"define"},"Define"),(0,r.yg)("p",null,"If you want to use an entity, you first have to define it, providing configuration, actual code etc. The Definition Step never creates an instance or somehow affect the runtime, it just makes the preconfigured definition available for creating as many instances from it as you might want."),(0,r.yg)("p",null,"The most important aspect of the split of ",(0,r.yg)("inlineCode",{parentName:"p"},"define")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"create")," is to enable modularity of your code base. ",(0,r.yg)("inlineCode",{parentName:"p"},"defines")," can live in a separate file. You can group regularly used pipelines, scripts or connectors in separate files, and dont repeat yourself too much by reusing recurring bits of your code."),(0,r.yg)("h3",{id:"create"},"Create"),(0,r.yg)("p",null,"The Create step actually creates a runtime instance of the defined entity, with the configuration provided at the Definition step and with the ",(0,r.yg)("a",{parentName:"p",href:"#arguments"},"Arguments")," provided with the create statement."),(0,r.yg)("p",null,"Created operators and scripts (actually also an operator) can be referenced by ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," statements in a pipeline and thus can become part of the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," graph."),(0,r.yg)("p",null,"Created ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connectors")," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines")," can be referenced in ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-connec"},"Connect")," statements and so become part of the event flow that actually routes incoming events towards pipelines and outgoing connectors."),(0,r.yg)("p",null,"One special case are ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flows"),". They are not created, but ",(0,r.yg)("a",{parentName:"p",href:"#deploy"},"Deploy"),"ed. This is because deploying a ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," is also starting all the contained instances of the flow, so the operation is somewhat different and required a different name."),(0,r.yg)("h2",{id:"modules"},"Modules"),(0,r.yg)("p",null,"Troy is built to enable modularization. Instead of cramming all your applications code into a huge single file, you can extract your preconfigured ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connector")," definitions or even a full-grown ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," (or anything you can define in Troy) into separate files and simply ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-use"},(0,r.yg)("inlineCode",{parentName:"a"},"use"))," in your applications main Troy file."),(0,r.yg)("h3",{id:"example"},"Example"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="main.troy"',title:'"main.troy"'},"# importing the module `my_flows` from `my_flows.tremor`\n# making its definitions available in this file\nuse my_flows;\n\n# refer to a flow defined the `my_flows` module and deploy it\ndeploy flow cool_flow_01 from my_flows::cool_flow;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="my_flows.tremor"',title:'"my_flows.tremor"'},"\ndefine flow cool_flow\nflow\n    # make the `pipelines` module within the `troy` namespace available.\n    use tremor::pipelines;\n\n    # make the `connectors` module within the `troy` namespace available.\n    use tremor::connectors;\n\n    # refer to the definition of `console` inside the `connectors` module\n    create connector my_console from connectors::console;\n    # refer to the definition of `passthrough` inside the `pipelines` module\n    create pipeline my_passthrough from pipelines::passthrough;\n\n    connect /connector/my_console to /pipeline/my_passthrough;\n    connect /pipeline/my_passthrough to /connector/my_console;\nend;\n")),(0,r.yg)("p",null,"In this example we put the actual ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," definition in a separate file ",(0,r.yg)("inlineCode",{parentName:"p"},"my_flows.tremor")," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-use"},(0,r.yg)("inlineCode",{parentName:"a"},"use")),"d it in our main Troy file."),(0,r.yg)("p",null,"Even more interestingly, within our ",(0,r.yg)("inlineCode",{parentName:"p"},"my_flows.tremor")," file, we made good use of predefined ",(0,r.yg)("a",{parentName:"p",href:"../reference/connectors"},"Connectors")," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines")," within the ",(0,r.yg)("a",{parentName:"p",href:"../reference/stdlib"},"Standard Library")," modules ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/stdlib/tremor/pipelines"},(0,r.yg)("inlineCode",{parentName:"a"},"tremor::pipelines"))," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/stdlib/tremor/connectors"},(0,r.yg)("inlineCode",{parentName:"a"},"tremor::connectors")),". All standard library modules are available for ",(0,r.yg)("inlineCode",{parentName:"p"},"use")," by default."),(0,r.yg)("p",null,"It is also important to note that you can use ",(0,r.yg)("inlineCode",{parentName:"p"},"use")," statements on all levels of your code. In the top level, in a ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," definition, a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," definition or a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Script")," operator definition. A ",(0,r.yg)("inlineCode",{parentName:"p"},"use")," statement on an outer scope, say inside a ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow")," definition, like above, will not be available on an inner scope, say a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," definition. ",(0,r.yg)("inlineCode",{parentName:"p"},"use")," statements only make the definition of modules available in the current scope."),(0,r.yg)("h3",{id:"tremor_path"},"TREMOR_PATH"),(0,r.yg)("p",null,"Tremor modules you want to ",(0,r.yg)("inlineCode",{parentName:"p"},"use"),", need to be available on a path listed in the environment variable ",(0,r.yg)("inlineCode",{parentName:"p"},"$TREMOR_PATH"),".\nIt follows the same format as the well known ",(0,r.yg)("inlineCode",{parentName:"p"},"$PATH")," variable. It should contain 0 or more directories, separated by a colon (",(0,r.yg)("inlineCode",{parentName:"p"},":"),")."),(0,r.yg)("p",null,"Getting back to the example above: If you want to ",(0,r.yg)("inlineCode",{parentName:"p"},"use")," the ",(0,r.yg)("inlineCode",{parentName:"p"},"my_flows.tremor")," file, its directory needs to be present in ",(0,r.yg)("inlineCode",{parentName:"p"},"$TREMOR_PATH")," and provided to the ",(0,r.yg)("inlineCode",{parentName:"p"},"tremor")," executable on startup."),(0,r.yg)("p",null,"An example command line to start tremor with the files above, assuming ",(0,r.yg)("inlineCode",{parentName:"p"},"my_flows.tremor")," is in the ",(0,r.yg)("inlineCode",{parentName:"p"},"$HOME/modules")," directory, would be:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-console"},'$ TREMOR_PATH="${TREMOR_PATH}:${HOME}/modules tremor server run main.troy\n')),(0,r.yg)("h2",{id:"arguments"},"Arguments"),(0,r.yg)("p",null,"All Tremor entities have a define step, at which they can define arguments, they require upon creation (or upon ",(0,r.yg)("inlineCode",{parentName:"p"},"deploy"),"). The syntax for this is illustrated by the following example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define flow with_args\nargs\n    url = "localhost:12345",    # optional argument with default value\n    codec                       # required argument\nflow\n    define connector conn_with_args from udp_server\n    args\n        url,                    # required argument\n        codec                   # required argument\n    with\n        config = {\n            "url": args.url\n        },\n        codec = args.codec\n    end;\n\n    create connector conn_with_args\n    with\n        url = args.url,         # the value from the flow args are passed through to the connector\n        codec = args.codec      # the same happens here\n    end;\n\n    # ... the rest redacted for the sake of brevity\nend;\n\ndeploy flow with_args\nwith\n    codec = "json"              # we need to provide the required arguments\nend;\n')),(0,r.yg)("p",null,"Arguments are defined after the ",(0,r.yg)("inlineCode",{parentName:"p"},"args")," keyword. It is possible to define required arguments, by omitting a default value, and optional arguments, by providing a default value."),(0,r.yg)("p",null,"Parameter values are provided on ",(0,r.yg)("inlineCode",{parentName:"p"},"create")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"deploy")," statements after the ",(0,r.yg)("inlineCode",{parentName:"p"},"with")," keyword."),(0,r.yg)("p",null,"You can refer to arguments within the body of the entity having arguments defined by the special ",(0,r.yg)("inlineCode",{parentName:"p"},"args")," path expression. It is not possible to refer to ",(0,r.yg)("inlineCode",{parentName:"p"},"args")," from the outer scope. E.g. inside a script we cannot reference the ",(0,r.yg)("inlineCode",{parentName:"p"},"args")," of the outer ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," or outer ",(0,r.yg)("a",{parentName:"p",href:"#flows"},"Flow"),", only the own ",(0,r.yg)("inlineCode",{parentName:"p"},"args")," can be referenced."))}u.isMDXComponent=!0}}]);