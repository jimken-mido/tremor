"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[1582],{57594:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var a=t(58168),o=(t(96540),t(15680)),r=t(40281);const s={},i="Runtime Capabilities",l={unversionedId:"concepts/runtime_capabilities",id:"version-0.12/concepts/runtime_capabilities",title:"Runtime Capabilities",description:"The Tremor runtime is the part of the system that takes your Troy configuration, brings it to live and has your CPUs pump events through your pipelines as fast as we could make it do. We tried to follow a few principles we took from years long experience in writing event processing engines, distributes systems and high performance code:",source:"@site/versioned_docs/version-0.12/concepts/runtime_capabilities.md",sourceDirName:"concepts",slug:"/concepts/runtime_capabilities",permalink:"/docs/0.12/concepts/runtime_capabilities",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/concepts/runtime_capabilities.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"Batching",permalink:"/docs/0.12/concepts/batching"},next:{title:"Reference",permalink:"/docs/0.12/reference/"}},c={},p=[{value:"Keep the hot path as free from allocations as possible",id:"keep-the-hot-path-as-free-from-allocations-as-possible",level:4},{value:"Execute each entity of the runtime on their own task",id:"execute-each-entity-of-the-runtime-on-their-own-task",level:4},{value:"Leverage your CPUs capabilities",id:"leverage-your-cpus-capabilities",level:4},{value:"Contraflow",id:"contraflow",level:2},{value:"The Circuit Breaker Mechanism",id:"the-circuit-breaker-mechanism",level:3},{value:"Garuanteed Delivery",id:"garuanteed-delivery",level:3},{value:"Pause / Resume",id:"pause--resume",level:2},{value:"Quiescence",id:"quiescence",level:2}],u={toc:p},h="wrapper";function m(e){let{components:n,...t}=e;return(0,o.yg)(h,(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"runtime-capabilities"},"Runtime Capabilities"),(0,o.yg)("p",null,"The Tremor runtime is the part of the system that takes your Troy configuration, brings it to live and has your CPUs pump events through your pipelines as fast as we could make it do. We tried to follow a few principles we took from years long experience in writing event processing engines, distributes systems and high performance code:"),(0,o.yg)("h4",{id:"keep-the-hot-path-as-free-from-allocations-as-possible"},"Keep the hot path as free from allocations as possible"),(0,o.yg)("p",null,"The hot path is the way your events take from the input connector through all pipelines towards the output connector. While we need to allocate some memory for the events themselves and for mutations on those events throughout ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline")," and ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Script")," processing, we try to move events from end to end without additional allocations."),(0,o.yg)("p",null,"E.g. for turning JSON encoded data into events, we keep the raw event bytes around and reference that data directly for our JSON strings (with a few exceptions). This avoids one copy of the incoming data."),(0,o.yg)("p",null,"We preallocate all the data\xdfstructures we need for bookkeeping and shuffling events around and try to keep the actual event flwo mechanics as simple as possible. At best we only move some pointers."),(0,o.yg)("h4",{id:"execute-each-entity-of-the-runtime-on-their-own-task"},"Execute each entity of the runtime on their own task"),(0,o.yg)("p",null,"As our runtime is built upon async Rust, our unit of concurrency is a ",(0,o.yg)("a",{parentName:"p",href:"https://book.async.rs/concepts/tasks.html"},"Task"),", which can be scheduled on an executor thread. When and where this task is executed is a decided by the underlying executor. We run every entity, that is ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipelines")," and ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/"},"Connectors"),", on their own task. All entities communicate via channels (Multi-producer-multi-consumer queues) and this is also the way events take. This decouples event receiving from event handling and sending and allows for smoother spreading of load to multiple CPUs in parallel, especially in the case of multiple ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/#flows"},"Flows")," being deployed to a Tremor instance in parallel."),(0,o.yg)("p",null,"This has the nice effect, that you can vertically scale high event volumes by pumping them through multiple parallel flows:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},'define flow kafka_consumer\nflow\n\n    # import connector and pipeline definitions\n    use my_connectors;\n    use my_pipelines;\n    \n    create connector kafka_in from my_connectors::kafka_consumer\n    with\n        consumer_group = "snot",\n        topic = "my_topic",\n        brokers = ["localhost:9092", "example.org:9092"]\n    end;\n    create connector elastic_out from my_connectors::elastic;\n\n    create pipeline consume from my_pipelines::consume;\n    \n    connect /connector/kafka_in to /pipeline/consume;\n    connect /pipeline/consume to /connector/elastic_out;\nend;\n\n# deploy three instances of the above flow to leverage available CPU and memory resources\n# we will have three kafka consumers in one consumer group, consuming in parallel\n# 3 pipelines processing in parallel\n# and 3 elastic connectors pushing events to elasticsearch in parallel (with configurable concurrency)\ndeploy flow kafka_consumer_01 from kafka_consumer;\ndeploy flow kafka_consumer_02 from kafka_consumer;\ndeploy flow kafka_consumer_03 from kafka_consumer;\n')),(0,o.yg)("h4",{id:"leverage-your-cpus-capabilities"},"Leverage your CPUs capabilities"),(0,o.yg)("p",null,"Our CPUs have crazy instruction sets (SSE, AVX2, Neon, ...) for data parallel programming that we mostly only use unintended by some optimizing compiler rewriting our crufty loops. Think of them as turning your CPU into a poor mans GPU. Very intelligent people came up with incredibly clever algorithms for leveraging those instruction sets for e.g. parsing JSON, UTF-8 validation or finding bytes in strings. We try to use those whenever possible. Most of the time, we are standing on the shoulders of giants providing all the goodness for us in existing crates we pull in as dependencies, sometimes we roll our own, as we did with a Rust port of ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/simdjson/simdjson"},"simdjson"),": ",(0,o.yg)("a",{parentName:"p",href:"https://crates.io/crates/simd-json"},"https://crates.io/crates/simd-json")),(0,o.yg)("h2",{id:"contraflow"},"Contraflow"),(0,o.yg)("p",null,"Tremors runtime was built to enable traffic shaping and improving quality of service for high volumetric data streams. It was built with very real possibility of failure in mind. In a system of many connected computers, either any computer or the network could fail in arbitrarily scary and harmful ways. Tremor, as the safeguard of downstream systems, the harbinger of quality of service, needs to be a good citizen and stop pounding downstream systems that are already known to be out of service."),(0,o.yg)("p",null,"To that end, the contraflow mechanism was built to allow signals to be propagated back along the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines"},"Pipeline graph")," to all upstream ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/"},"Connectors"),"."),(0,o.yg)("p",null,"All the pipeline graphs you can build form a directed acyclic graph (or ",(0,o.yg)("strong",{parentName:"p"},"DAG"),"). The reason for this is that we can take this DAG and turn it around and still have a DAG. This ",(0,o.yg)("em",{parentName:"p"},"reversed")," pipeline graph can be used to propagate special events back the pipeline to all reachable inputs."),(0,o.yg)("p",null,"Event flow:"),(0,o.yg)(r.K,{chart:"flowchart LR\n\nIN([in]) --\x3e NODE1[operator] --\x3e OUT([out])\nNODE1 --\x3e ERR([err])\nIN --\x3e SCRIPT[script] --\x3e NODE2[operator] --\x3e OUT\nSCRIPT --\x3e ERR\nNODE2 --\x3e ERR",mdxType:"Mermaid"}),(0,o.yg)("p",null,"Contraflow: "),(0,o.yg)(r.K,{chart:"flowchart LR\nOUT([out]) --\x3e NODE1[operator] --\x3e IN([in])\nOUT --\x3e NODE2[operator] --\x3e SCRIPT[script] --\x3e IN\n\nERR([err]) --\x3e NODE1\nERR --\x3e NODE2\nERR --\x3e SCRIPT",mdxType:"Mermaid"}),(0,o.yg)("p",null,"Contraflow is used to transport signals for successful or failed event delivery, for transmitting topological knowledge between connected connectors (for knowing what other connectors are reachable via the connected pipelines) and for managing the circuit breaker mechanism."),(0,o.yg)("h3",{id:"the-circuit-breaker-mechanism"},"The Circuit Breaker Mechanism"),(0,o.yg)("p",null,"Circuit breakers are used to avoid pounding downstream systems with requests (or events in our case) if we know those are doomed anyways. Then the circuit breaker opens and it fails those events early or buffers them (e.g. when using kafka as a buffer) until the downstream system is healthy again. This mechanism is also builtin to our runtime."),(0,o.yg)("p",null,"It is possible for any operator node in a pipeline and for all connectors to open and close the runtimes builtin circuit breaker by sending a special contraflow event to all reachable upstream pipeline operators and connectors. Each upstream connector receiving such a message will stop pulling data from the external system it connects to, thus stopping to send events downstream. The issuer of the circuit breaker message will check if the downstream system is healthy again and if so, it will close the circuit breaker again in order to start receiving events again."),(0,o.yg)("p",null,"The runtime even makes use of this mechanism for a controlled start of all elements of a ","[Flow]",". Every connector, when connected as an event-",(0,o.yg)("em",{parentName:"p"},"source")," (on the left hand side of a ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-connect"},"connect statement"),"), starts with an opened circuit breaker. This ensures that it doesn't start sending events before downstream connectors are prepared to receive them. And every event-",(0,o.yg)("em",{parentName:"p"},"sink")," connector (on the right-hand side of a ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/deploy#rule-connect"},"connect statement"),") will close the circuit breaker upon startup, so that only when all upstream connectors signal their readiness for events, events actually start to flow from event-source to event-sink."),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/backpressure"},(0,o.yg)("inlineCode",{parentName:"a"},"qos::backpressure")," operator")," can be used with ",(0,o.yg)("inlineCode",{parentName:"p"},"method = pause")," to make use of the circuit breaker mechanism to apply backpressure towards upstream system, otherwise it discards messages by sending them to the ",(0,o.yg)("inlineCode",{parentName:"p"},"overflow")," port, where they are usually discarded. The ",(0,o.yg)("inlineCode",{parentName:"p"},"pause")," method is great when backpressure should preserve all events."),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/roundrobin"},(0,o.yg)("inlineCode",{parentName:"a"},"qos::roundrobin")," operator")," will distribute events to the given outputs in a roundrobin fashion and take outputs out of rotation if they error repeatedly or their circuit breaker is triggered. It will only forward circuit breaker contraflow events if all outputs are unavailable."),(0,o.yg)("p",null,"Both the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/elastic"},(0,o.yg)("inlineCode",{parentName:"a"},"elastic")," connector")," and the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/http#client"},(0,o.yg)("inlineCode",{parentName:"a"},"http_client")," connector")," use the circuit breaker mechanism to limit concurrent in-flight outgoing requests and stop upstream connectors from sending further events if the supported concurrency is exceeded."),(0,o.yg)("h3",{id:"garuanteed-delivery"},"Garuanteed Delivery"),(0,o.yg)("p",null,"Tremor uses the contraflow mechanism to implement ",(0,o.yg)("strong",{parentName:"p"},"Event delivery acknowledgements"),". In a nutshell it works like this:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"When a connector receives an event and handles it successfully without error (e.g. sends it off via TCP) and event delivery acknowledgement is sent backwards via contraflow, if required, which is flagged in each event, usually by the originating connector."),(0,o.yg)("li",{parentName:"ul"},"When a connector fails to handle an event a delivery failure message is sent backwards via contraflow, if required."),(0,o.yg)("li",{parentName:"ul"},"Pipeline operators and connectors emitting events can handle those messages to implement guaranteed delivery.")),(0,o.yg)("p",null,"An event acknowledgement contraflow message is only handled by the connector (or operator) that did send the event. E.g. a ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/kafka#consumer"},(0,o.yg)("inlineCode",{parentName:"a"},"kafka_consumer")," connector")," will commit the offset of the event upon receiving an event acknowledgment."),(0,o.yg)("p",null,"This has the effect that we have 1 contraflow event flowing backwards for each event reaching its destination. The forward traffic volume will be mirrored by the contraflow volume, just that the contraflow itself is not leaving the system but is handled internally by ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/"},"Operators")," and ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/"},"Connectors"),"."),(0,o.yg)("p",null,"Not all connectors support event acknowledgements, as their nature doesn't support the notion of marking parts of a data stream as successfully handled. For example ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/udp"},"UDP")," cannot support this feature. "),(0,o.yg)("p",null,"Connectors like ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/kafka#consumer"},(0,o.yg)("inlineCode",{parentName:"a"},"kafka_consumer"))," ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/wal"},(0,o.yg)("inlineCode",{parentName:"a"},"wal"))," support event delivery acknowledgements and are well suited for implementing workloads that can guarantee *",(0,o.yg)("em",{parentName:"p"},"at-least-once")," delivery."),(0,o.yg)("p",null,"For the circuit breaker mechanism a successful event acknowledgement is used a signal for the circuit breaker to close as the downstream system seems to be back to normal."),(0,o.yg)("h2",{id:"pause--resume"},"Pause / Resume"),(0,o.yg)("p",null,"With the ",(0,o.yg)("a",{parentName:"p",href:"#contraflow"},"Contraflow mechanism")," and the ",(0,o.yg)("a",{parentName:"p",href:"#the-circuit-breaker-mechanism"},"Circuit Breaking")," we have all the bits and pieces in place to automatically stop upstreams from producing and events when they are not going to be successful. Turns out we can also use this to manually stop events from flowing."),(0,o.yg)("p",null,"We do expose API endpoints to change the current status of Flows: ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/api/#tag/flows/operation/patch_flow_status"},"Patch flow status"),"\nand single Connectors inside Flows: ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/api/#tag/connectors/operation/patch_flow_connector_status"},"Patch flow connector status"),"."),(0,o.yg)("p",null,"Here we see that the current status of the flow ",(0,o.yg)("inlineCode",{parentName:"p"},"main")," is ",(0,o.yg)("inlineCode",{parentName:"p"},"running"),". It is accepting events from and emitting events into the runtime from stdin."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'$ curl -s localhost:9898/v1/flows/main | jq .\n{\n  "alias": "main",\n  "status": "running",\n  "connectors": [\n    "console"\n  ]\n}\n')),(0,o.yg)("p",null,"We can patch the flow status to ",(0,o.yg)("em",{parentName:"p"},"pause")," all connectors inside that flow. It will return the new status of the flow in the response:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'curl -s -XPATCH -H\'application/json\' localhost:9898/v1/flows/main -d\'{"status": "paused"}\' | jq .\n{\n  "alias": "main",\n  "status": "paused",\n  "connectors": [\n    "console"\n  ]\n}\n')),(0,o.yg)("p",null,"The connector ",(0,o.yg)("inlineCode",{parentName:"p"},"console")," is receiving string events for each line sent to it via stdin. The whole flow is set up to echo events back to stdout. If we try typing something into the processes terminal, we won't see anythign echoed to stdout, because the connector is paused. It will not pull new data from ",(0,o.yg)("inlineCode",{parentName:"p"},"stdin")," until it is ",(0,o.yg)("em",{parentName:"p"},"resumed")," again."),(0,o.yg)("p",null,"We can resume the flow by patching its status back to ",(0,o.yg)("em",{parentName:"p"},"running"),". It will return the new status of the flow in the response:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-console"},'curl -s -XPATCH -H\'application/json\' localhost:9898/v1/flows/main -d\'{"status": "running"}\' | jq .\n{\n  "alias": "main",\n  "status": "running",\n  "connectors": [\n    "console"\n  ]\n}\n')),(0,o.yg)("h2",{id:"quiescence"},"Quiescence"),(0,o.yg)("p",null,"TBD"))}m.isMDXComponent=!0}}]);