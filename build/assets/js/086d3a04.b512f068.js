"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6521],{74685:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(58168),r=(n(96540),n(15680));n(40281);const i={},s="Recipes",o={unversionedId:"tremor-script/recipes",id:"version-0.11/tremor-script/recipes",title:"Recipes",description:"This document provides a few recipes for common patterns in tremor script. Please note however that it neither is exhaustive nor should those patterns considered the 'only way' to perform certain tasks.",source:"@site/versioned_docs/version-0.11/tremor-script/recipes.md",sourceDirName:"tremor-script",slug:"/tremor-script/recipes",permalink:"/docs/0.11/tremor-script/recipes",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/tremor-script/recipes.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"pp",permalink:"/docs/0.11/tremor-script/pp"},next:{title:"severity",permalink:"/docs/0.11/tremor-script/stdlib/cncf/otel/logs/severity"}},l={},d=[{value:"Extracting a raw message",id:"extracting-a-raw-message",level:2},{value:"Appending to an array",id:"appending-to-an-array",level:2},{value:"Validating over extracted data",id:"validating-over-extracted-data",level:2},{value:"Replacing a field with an extraction",id:"replacing-a-field-with-an-extraction",level:2},{value:"No effect on non matching case",id:"no-effect-on-non-matching-case",level:2},{value:"Boolean decisions",id:"boolean-decisions",level:2},{value:"Diverting an event to a different channel",id:"diverting-an-event-to-a-different-channel",level:2},{value:"The &#39;null default&#39;",id:"the-null-default",level:2},{value:"Testing against the type of a field",id:"testing-against-the-type-of-a-field",level:2},{value:"Routing messages",id:"routing-messages",level:2},{value:"Percentage drops of events",id:"percentage-drops-of-events",level:2},{value:"Check if a variable is present/absent",id:"check-if-a-variable-is-presentabsent",level:2}],p={toc:d},c="wrapper";function g(e){let{components:t,...n}=e;return(0,r.yg)(c,(0,a.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"recipes"},"Recipes"),(0,r.yg)("p",null,"This document provides a few recipes for common patterns in tremor script. Please note however that it neither is exhaustive nor should those patterns considered the 'only way' to perform certain tasks."),(0,r.yg)("h2",{id:"extracting-a-raw-message"},"Extracting a raw message"),(0,r.yg)("p",null,"If the event is a unstructured / raw message parsing it can be tricky since we can not match over a string. The following code offers a solution to it:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = "John Doe"\n\nlet event =  match {"message": event} of\n  case r = %{ message ~= dissect|%{first} %{last}| } => r.message\n  default => drop\nend;\n# event = {"first" : "John", "last": "Doe"}\n')),(0,r.yg)("h2",{id:"appending-to-an-array"},"Appending to an array"),(0,r.yg)("p",null,"When appending to an array we can use the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-script/stdlib/std/array#pusharray-element"},(0,r.yg)("inlineCode",{parentName:"a"},"array::push"))," function"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::array;\n# event = {"key": "value", "tags": ["tag1"]}\nlet event.tags = array::push(event.tags, "tag2");\n# event = {"key": "value", "tags": ["tag1", "tag2"]}\n')),(0,r.yg)("h2",{id:"validating-over-extracted-data"},"Validating over extracted data"),(0,r.yg)("p",null,"Sometimes we want to validate over extracted data without forcing the extraction to be a regular expression. For validations like the one below this pattern can be used."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::array;\nmatch event of\n  # ...\n  case r = %{message ~= dissect|%{log_level} %{log_timestamp}: %{logger}: %{message}|} when array::contains(["ERROR", "WARN", "INFO", "DEBUG"], result.message.log_level) => let event = merge event of r.message end\n  # ...\nend\n')),(0,r.yg)("p",null,"Here we extract the ",(0,r.yg)("inlineCode",{parentName:"p"},"log_level")," and validate of that the it is one of ",(0,r.yg)("inlineCode",{parentName:"p"},"ERROR"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"WARN"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"INFO")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"DEBUG")," by moving the check into the when guard we don't need to use a regular expression for this validation instead can use array membership."),(0,r.yg)("h2",{id:"replacing-a-field-with-an-extraction"},"Replacing a field with an extraction"),(0,r.yg)("p",null,"When extracting a field to merge with with the event and wanting to remove the extracted field we can take advantage of the ",(0,r.yg)("inlineCode",{parentName:"p"},"merge")," expressions behaviour that it will treat ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," in merged records as a command to delete the data by setting the field to replace to ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," before merging."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = %{"message": "John Doe"}\nlet event = merge event of match event of\n  case r = %{message ~= dissect|%{first} %{last}| } => let r = r.message, let r.message = null, r\n  default => {}\nend;\n# event = %{"first": "John", "last": "Doe"}\n')),(0,r.yg)("h2",{id:"no-effect-on-non-matching-case"},"No effect on non matching case"),(0,r.yg)("p",null,"If we use merge with match we can make the ",(0,r.yg)("inlineCode",{parentName:"p"},"default")," case to have no effect by using ",(0,r.yg)("inlineCode",{parentName:"p"},"{}"),". This is possible since ",(0,r.yg)("inlineCode",{parentName:"p"},"merge")," on ",(0,r.yg)("inlineCode",{parentName:"p"},"{}")," is a identity function."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = %{"message": "John Doe"}\nlet event = merge event of match event of\n  case r = %{message ~= dissect|%{first} %{midle} %{last}| } => let r = r.message, let r.message = null, r\n  default => {}\nend;\n# event = %{"message": "John Doe"}\n')),(0,r.yg)("h2",{id:"boolean-decisions"},"Boolean decisions"),(0,r.yg)("p",null,"To make boolean decisions we can match on ",(0,r.yg)("inlineCode",{parentName:"p"},"true")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"false"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::type;\n\nmatch type::is_record(event) of\n  case true => let event_type = "record"\n  case false => let event_type = "other"\nend\n')),(0,r.yg)("h2",{id:"diverting-an-event-to-a-different-channel"},"Diverting an event to a different channel"),(0,r.yg)("p",null,"By default the ",(0,r.yg)("inlineCode",{parentName:"p"},"tremor-script")," operator forwards all events that are not dropped to the ",(0,r.yg)("inlineCode",{parentName:"p"},"out")," channel for further processing. However it is possible to route events to different channels using the ",(0,r.yg)("inlineCode",{parentName:"p"},"emit")," keyword. This allows, for example, diverting certain events to reserve bandwidth for a more important subset."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event.importance of\n  case "high" => emit # this is the same as emit event => "out"\n  case "medium" => emit event => "divert"\n  default => drop # deletes the event\nend\n')),(0,r.yg)("h2",{id:"the-null-default"},"The 'null default'"),(0,r.yg)("p",null,"When the result of a match statement isn't needed - as in we use it purely for it's side effects - and we want the ",(0,r.yg)("inlineCode",{parentName:"p"},"default")," to have no effect we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," here."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event of\n  case %{ tags ~= ["high-priority"]} => let event.importance = "high"\n  default => null\nend\n')),(0,r.yg)("h2",{id:"testing-against-the-type-of-a-field"},"Testing against the type of a field"),(0,r.yg)("p",null,"Sometimes we want to know if a field has a certain type. The ",(0,r.yg)("inlineCode",{parentName:"p"},"type")," module provides help here but common types such as ",(0,r.yg)("inlineCode",{parentName:"p"},"record")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"array")," can be checked using their patterns."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event of\n  case %{field ~= %{}} => emit "event.field is a record"\n  case %{field ~= %[]} => emit "event.field is a array"\n  case %{} when type::is_record(event.field) => emit "event.field is a record"\n  case %{} when type::is_array(event.field) => emit "event.field is a array"\n  case %{} when type::is_number(event.field) => emit "event.field is a number (float or integer)"\n  case %{} when type::is_integer(event.field) => emit "event.field is an integer"\n  case %{} when type::is_float(event.field) => emit "event.field is a float"\n  case %{} when type::is_null(event.field) => emit "event.field is null (but set)"\n  case %{absent field} => emit "event.field is not set"\n  # ...\nend\n')),(0,r.yg)("h2",{id:"routing-messages"},"Routing messages"),(0,r.yg)("p",null,"Tremor script can be used to route messages by combining the ",(0,r.yg)("inlineCode",{parentName:"p"},"emit")," feature and the fact that the tremor runtime operator allows different outputs."),(0,r.yg)("p",null,"To route to doing a ",(0,r.yg)("inlineCode",{parentName:"p"},"blue")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"green")," split based on a field in a record we could use the following code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event of\n  case %{key == "blue"} => emit event => "blue"\n  case %{key == "green"} => emit event => "green"\n  default => drop\nend\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"define script split_script\nscript\n  # see above\nend;\ncreate script split_script;\n\nselect event from split_script/blue into out/blue;\nselect event from split_script/green into out/green;\n")),(0,r.yg)("h2",{id:"percentage-drops-of-events"},"Percentage drops of events"),(0,r.yg)("p",null,"To drop a percentage of all events, functions in the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-script/stdlib/std/random"},"random")," module can be used."),(0,r.yg)("p",null,"We generate a random number in a range and based on the outcome, we decide whether we want to drop an event or not. Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"# drop 50% of the events\nmatch random::integer(0, 100) < 50 of\n  case true => drop\n  default => null\nend\n")),(0,r.yg)("p",null,"Most of the time, we want to do this only for certain matching events (as opposed to all events)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'let random_number = random::integer(0, 100);\nmatch event of\n  case %{key == "blue"} when random_number < 25 => drop   # drop 25% of blue events\n  case %{key == "yellow"} when random_number < 75 => drop # drop 75% of yellow events\n  case %{key == "red"} => drop                            # drop 100% of red events\n  default => null                                         # drop 0% of other events\nend\n')),(0,r.yg)("h2",{id:"check-if-a-variable-is-presentabsent"},"Check if a variable is present/absent"),(0,r.yg)("p",null,"To check if a variable is present, we can rely on the ",(0,r.yg)("inlineCode",{parentName:"p"},"present")," keyword (and inversely, ",(0,r.yg)("inlineCode",{parentName:"p"},"absent"),")."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# matches default case\nmatch present non_existent_var of\n  case true => "is present"\n  default => "not present"\nend;\n')),(0,r.yg)("p",null,"Note that this is different from the case where a variable is set to ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),", for which we can do ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-script/stdlib/std/type#is_nullvalue"},"function-based")," checks as well as pattern-match with ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/#match"},"match"),"."),(0,r.yg)("p",null,"Using non-existent variables in contexts other than ",(0,r.yg)("inlineCode",{parentName:"p"},"present")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"absent")," will throw an error terminating the script, so this is useful for guarding against that when needed. This is especially useful when working with meta variables as part of tremor runtime, where -- as part of a pipeline node -- we may need to check if a certain meta variable is set or not (eg: from a previous pipeline node) and act accordingly. For such needs, the approach above can be used. Alternatively, we can also rely on ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/#matching-record-patterns"},"record patterns")," there:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# tests for presence of $key\nmatch $ of\n  case %{present key} => "present"\n  default => "not present"\nend;\n')),(0,r.yg)("p",null,"Since ",(0,r.yg)("inlineCode",{parentName:"p"},"$")," gives a record with all the meta variable name-value mapping, this works nicely."))}g.isMDXComponent=!0}}]);