"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[3250],{614:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>g});var n=a(58168),s=(a(96540),a(15680));a(40281);const i={},r="The stats namespace",l={unversionedId:"tremor-query/functions/stats",id:"version-0.11/tremor-query/functions/stats",title:"The stats namespace",description:"The stats module contains functions for aggregating statistical measures",source:"@site/versioned_docs/version-0.11/tremor-query/functions/stats.md",sourceDirName:"tremor-query/functions",slug:"/tremor-query/functions/stats",permalink:"/docs/0.11/tremor-query/functions/stats",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/tremor-query/functions/stats.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Tremor-Query",permalink:"/docs/0.11/tremor-query/"},next:{title:"The win namespace",permalink:"/docs/0.11/tremor-query/functions/win"}},o={},g=[{value:"Size",id:"size",level:2},{value:"Functions",id:"functions",level:2},{value:"aggr::stats::count() -&gt; int",id:"aggrstatscount---int",level:3},{value:"aggr::stats::min(int|float) -&gt; int|float",id:"aggrstatsminintfloat---intfloat",level:3},{value:"aggr::stats::max(int|float) -&gt; int|float",id:"aggrstatsmaxintfloat---intfloat",level:3},{value:"aggr::stats::sum(int|float) -&gt; int|float",id:"aggrstatssumintfloat---intfloat",level:3},{value:"aggr::stats::var(int|float) -&gt; float",id:"aggrstatsvarintfloat---float",level:3},{value:"aggr::stats::stdev(int|float) -&gt; float",id:"aggrstatsstdevintfloat---float",level:3},{value:"aggr::stats::mean(int|float) -&gt; float",id:"aggrstatsmeanintfloat---float",level:3},{value:"aggr::stats::hdr(int|float) -&gt; record",id:"aggrstatshdrintfloat---record",level:3},{value:"aggr::stats::dds(int|float) -&gt; record",id:"aggrstatsddsintfloat---record",level:3}],u={toc:g},d="wrapper";function m(e){let{components:t,...a}=e;return(0,s.yg)(d,(0,n.A)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"the-stats-namespace"},"The ",(0,s.yg)("inlineCode",{parentName:"h1"},"stats")," namespace"),(0,s.yg)("p",null,"The ",(0,s.yg)("inlineCode",{parentName:"p"},"stats")," module contains functions for aggregating statistical measures\nof various events."),(0,s.yg)("h2",{id:"size"},"Size"),(0,s.yg)("p",null,"When using stats aggregate functions size in memory becomes an important factor from a capacity\nplanning perspective. The exact size of a window using aggregates depends on three main factors:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},'The size of the dimension identifier. I.e. if the window is identified by the string "window" it will\nrequire that amount of memory related to this. If it is identified by an array of 10.000 elements\nall reading "window" it will use (about) 10.000 times that size.'),(0,s.yg)("li",{parentName:"ul"},"The unit size of each aggregate used in the window. We will try to give an estimate of size\nfor each aggregate but please be aware that those are not always exact as they can depend on\nthe data they hold."),(0,s.yg)("li",{parentName:"ul"},"The number of groups, if grouping is configured. Each group will maintain a separate window of data")),(0,s.yg)("p",null,'For aggregates we\'ll provide an "order of magnitude" and a growth rate if applicable.'),(0,s.yg)("p",null,"For example ",(0,s.yg)("inlineCode",{parentName:"p"},"Fixed, 10 bytes")," indicate that the size doesn't grow and is in the order of two digit\nbytes. We try to give pessimistic estimates where possible."),(0,s.yg)("h2",{id:"functions"},"Functions"),(0,s.yg)("h3",{id:"aggrstatscount---int"},"aggr::stats::count() -> int"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 10 bytes")),(0,s.yg)("p",null,"Counts the number of events aggregated in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::count() # number of items in the window\n")),(0,s.yg)("h3",{id:"aggrstatsminintfloat---intfloat"},"aggr::stats::min(int|float) -> int|float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 10 bytes")),(0,s.yg)("p",null,"Determines the smallest event value in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::min(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatsmaxintfloat---intfloat"},"aggr::stats::max(int|float) -> int|float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 10 bytes")),(0,s.yg)("p",null,"Determines the largest event value in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::max(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatssumintfloat---intfloat"},"aggr::stats::sum(int|float) -> int|float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 10 bytes")),(0,s.yg)("p",null,"Determines the arithmetic sum of event values in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::sum(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatsvarintfloat---float"},"aggr::stats::var(int|float) -> float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 100 bytes")),(0,s.yg)("p",null,"Calculates the sample variance of event values in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::var(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatsstdevintfloat---float"},"aggr::stats::stdev(int|float) -> float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 100 bytes")),(0,s.yg)("p",null,"Calculates the sample standard deviation of event values in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::stdev(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatsmeanintfloat---float"},"aggr::stats::mean(int|float) -> float"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 100 bytes")),(0,s.yg)("p",null,"Calculates the stastical mean of the event values in the current windowed operation."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},"aggr::stats::mean(event.value)\n")),(0,s.yg)("h3",{id:"aggrstatshdrintfloat---record"},"aggr::stats::hdr(int|float) -> record"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 100 Kilo Bytes (note: this strongly depends on configuration, and can be estimated more correctly ",(0,s.yg)("a",{parentName:"li",href:"https://github.com/HdrHistogram/HdrHistogram#footprint-estimation"},"with this formula"),")")),(0,s.yg)("p",null,"Uses a High Dynamic Range ( HDR ) Histogram to calculate all basic statistics against the event values sin the current windowed operation. The function additionally interpolates percentiles or quartiles based on a configuration specification passed in as an argument to the aggregater function."),(0,s.yg)("p",null,"The HDR Histogram trades off memory utilisation for accuracy and is configured internally to limit accuracy to 2 significant decimal places."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},'aggr::stats::hdr(event.value, ["0.5","0.75","0.9","0.99","0.999"])\n')),(0,s.yg)("p",null,"Example output:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "min": 1,\n  "max": 100,\n  "count": 100,\n  "mean": 50.5,\n  "stdev": 28.866_070_047_722_12,\n  "var": 833.25,\n  "percentiles": {\n    "0.5": 50,\n    "0.9": 90,\n    "0.95": 95,\n    "0.99": 99,\n    "0.999": 100,\n    "0.9999": 100\n  }\n}\n')),(0,s.yg)("h3",{id:"aggrstatsddsintfloat---record"},"aggr::stats::dds(int|float) -> record"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"size"),": Fixed, 10 Kilo Bytes (estimate based on ",(0,s.yg)("a",{parentName:"li",href:"https://arxiv.org/pdf/1908.10693.pdf"},"this paper"),")")),(0,s.yg)("p",null,"Uses a Distributed data-stream Sketch ( ",(0,s.yg)("a",{parentName:"p",href:"http://www.vldb.org/pvldb/vol12/p2195-masson.pdf"},"DDS (paper)")," Histogram to calculate count, min, max, mean and quartiles with quartile relative-error accurate over the range of points in the histogram. The DDS histogram trades off accuracy ( to a very low error and guaranteed low relative error ) and unlike HDR histograms does not need bounds specified."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-trickle"},'aggr::stats::dds(event.value, ["0.5","0.75","0.9","0.99","0.999"])\n')),(0,s.yg)("p",null,"Example output:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "count": 100,\n  "sum": 5050.0,\n  "min": 1.0,\n  "max": 100.0,\n  "mean": 50.5,\n  "percentiles": {\n    "0.5": 50.0,\n    "0.9": 89.2,\n    "0.95": 94.7,\n    "0.99": 98.6,\n    "0.999": 98.6,\n    "0.9999": 98.6,\n  }\n}\n')))}m.isMDXComponent=!0}}]);