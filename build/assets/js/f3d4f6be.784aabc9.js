"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[4645],{830:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(58168),r=(n(96540),n(15680));n(40281);const i={},o="Operators",l={unversionedId:"tremor-query/operators",id:"version-0.11/tremor-query/operators",title:"Operators",description:"Operators are part of the pipeline configuration.",source:"@site/versioned_docs/version-0.11/tremor-query/operators.md",sourceDirName:"tremor-query",slug:"/tremor-query/operators",permalink:"/docs/0.11/tremor-query/operators",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/tremor-query/operators.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Modules",permalink:"/docs/0.11/tremor-query/modules"},next:{title:"pp",permalink:"/docs/0.11/tremor-query/pp"}},s={},p=[{value:"script",id:"script",level:2},{value:"grouper::bucket",id:"grouperbucket",level:2},{value:"generic::backpressure",id:"genericbackpressure",level:2},{value:"qos::backpressure",id:"qosbackpressure",level:2},{value:"qos::percentile",id:"qospercentile",level:2},{value:"qos::roundrobin",id:"qosroundrobin",level:2},{value:"qos::wal",id:"qoswal",level:2},{value:"generic::batch",id:"genericbatch",level:2},{value:"generic::counter",id:"genericcounter",level:2},{value:"debug::history",id:"debughistory",level:2}],u={toc:p},d="wrapper";function g(e){let{components:t,...n}=e;return(0,r.yg)(d,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"operators"},"Operators"),(0,r.yg)("p",null,"Operators are part of the pipeline configuration."),(0,r.yg)("p",null,"Operators process events and signals in the context of a pipeline. An operator, upon receiving an event from an upstream operator or stream, MAY produce one or many events to one or many downstream directly connected operators. An operator MAY drop events which halts any further processing."),(0,r.yg)("p",null,"Operators allow the data processing capabilities of tremor to be extended or specialized without changes to runtime behavior, concurrency, event ordering or other aspects of a running tremor system."),(0,r.yg)("p",null,"Operators are created in the context of a pipeline and configured as part of ",(0,r.yg)("inlineCode",{parentName:"p"},"tremor-query")," ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/#custom-operator-definitions"},"statements"),". An operator MUST have an identifier that is unique for its owning pipeline."),(0,r.yg)("p",null,"Configuration is of the general form:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define module::operator_name operator my_custom_operator\nwith\n  param1 = "foo",\n  param2 = [1, 2, 3]\nend;\n\n# create - full form\ncreate operator my_custom_operator_instance from my_custom_operator\nwith\n  param1 = "bar",\n  param2 = [true, false, {}]\nend;\n\n# create - short form\ncreate operator my_custom_operator;\n')),(0,r.yg)("h2",{id:"script"},"script"),(0,r.yg)("p",null,"An embedded tremor script is created with a special syntax that deviates from the operator creation. For a full reference see the section on ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/#embedded-script-definitions"},"tremor-query embedded-scripts"),"."),(0,r.yg)("p",null,"The tremor script runtime allows to modify events or their metadata. To learn more about Tremor Script please see the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-script/"},"related section"),"."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"script")," operator allows to modify the events metadata (via ",(0,r.yg)("inlineCode",{parentName:"p"},"$"),"), and the script local ",(0,r.yg)("inlineCode",{parentName:"p"},"state")," which persists across single events."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out")," (default output used with ",(0,r.yg)("inlineCode",{parentName:"li"},"emit"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"error")," - channel for runtime errors"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"<anything else>")," used when ",(0,r.yg)("inlineCode",{parentName:"li"},'emit event => "<anything else>"'))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Examples"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"# definition\ndefine script rt\nscript\n  emit\nend;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"define script add\nscript\n  emit + 1\nend;\n\ncreate script add;\n\nselect event from in into add;\nselect event from add into out;\n")),(0,r.yg)("h2",{id:"grouperbucket"},"grouper::bucket"),(0,r.yg)("p",null,"Bucket will perform a sliding window rate limiting based on event metadata. Limits are applied for every ",(0,r.yg)("inlineCode",{parentName:"p"},"$class"),". In a ",(0,r.yg)("inlineCode",{parentName:"p"},"$class")," each ",(0,r.yg)("inlineCode",{parentName:"p"},"$dimensions")," is allowed to pass ",(0,r.yg)("inlineCode",{parentName:"p"},"$rate")," messages per second."),(0,r.yg)("p",null,"This operator does not support configuration."),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Metadata Variables"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"$class")," - The class of an event. (String)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"$rate")," - Allowed events per second per class/dimension (Number)"),(0,r.yg)("li",{parentName:"ul"},"(Optional) ",(0,r.yg)("inlineCode",{parentName:"li"},"$dimensions")," - The dimensions of the event. (Any)"),(0,r.yg)("li",{parentName:"ul"},"(Optional)",(0,r.yg)("inlineCode",{parentName:"li"},"$cardinality")," - the maximum number of dimensions kept track of at the same time (Number, default: ",(0,r.yg)("inlineCode",{parentName:"li"},"1000"),")")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"error")," - Unprocessable events for example if ",(0,r.yg)("inlineCode",{parentName:"li"},"$class")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"$rate")," are not set."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"overflow")," - Events that exceed the rate defined for them")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"define grouper::bucket operator group;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Metrics"),":"),(0,r.yg)("p",null,"The bucket operator generates additional metrics. For each class the following two statistics are generated (as an example):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-json"},'{"measurement":"bucketing",\n "tags":{\n   "action":"pass",\n   "class":"test",\n   "direction":"output",\n   "node":"bucketing",\n   "pipeline":"main",\n   "port":"out"\n },\n "fields":{"count":93},\n "timestamp":1553012903452340000\n}\n{"measurement":"bucketing",\n "tags":{\n   "action":"overflow",\n   "class":"test",\n   "direction":"output",\n   "node":"bucketing",\n   "pipeline":"main",\n   "port":"out"\n },\n "fields":{"count":127},\n "timestamp":1553012903452340000\n}\n')),(0,r.yg)("p",null,"This tells us the following, up until this measurement was published in the class ",(0,r.yg)("inlineCode",{parentName:"p"},"test"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"(",(0,r.yg)("inlineCode",{parentName:"li"},"pass"),") Passed 93 events"),(0,r.yg)("li",{parentName:"ul"},"(",(0,r.yg)("inlineCode",{parentName:"li"},"overflow"),") Marked 127 events as overflow due to not fitting in the limit")),(0,r.yg)("h2",{id:"genericbackpressure"},"generic::backpressure"),(0,r.yg)("p",null,"This operator is deprecated please use ",(0,r.yg)("inlineCode",{parentName:"p"},"qos::backpressure")," instead."),(0,r.yg)("h2",{id:"qosbackpressure"},"qos::backpressure"),(0,r.yg)("p",null,"The backpressure operator is used to introduce delays based on downstream systems load. Longer backpressure steps are introduced every time the latency of a downstream system reached ",(0,r.yg)("inlineCode",{parentName:"p"},"timeout"),", or an error occurs. On a successful transmission within the timeout limit, the delay is reset."),(0,r.yg)("p",null,"The operator supports two modes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"discard")," - the standard, when backpressure is triggered it will discard new messages by sending them to the ",(0,r.yg)("inlineCode",{parentName:"li"},"overflow")," output port. This is designed to fulfill the need of low transport latency at the cost of loss."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"pause")," - it will trigger a circuit breaker and ask the sources that send it data to stop sending additional events. No Event is discarded by the backpressure operator. This is designed to deal with situations where losing events is not an option - but the garuantee of losslessness depends on the source and how it can handle circuit breaker events.")),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Configuration options"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"timeout")," - Maximum allowed 'write' time in milliseconds."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"steps")," - Array of values to delay when a we detect backpressure. (default: ",(0,r.yg)("inlineCode",{parentName:"li"},"[50, 100, 250, 500, 1000, 5000, 10000]"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"method")," - Either ",(0,r.yg)("inlineCode",{parentName:"li"},"discard")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"pause")," to define how backpressure is handled (default: ",(0,r.yg)("inlineCode",{parentName:"li"},"discard"),")")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"overflow")," - Events that are not let past due to active backpressure")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define qos::backpressure operator bp\nwith\n  timeout = 100,\n  method = "discard"\nend;\n')),(0,r.yg)("h2",{id:"qospercentile"},"qos::percentile"),(0,r.yg)("p",null,"An alternative traffic shaping option to backpressure. Instead of all dropping events for a given\ntime we drop a statistical subset with an increasing percentage of events dropped the longer we\nsee errors / timeouts."),(0,r.yg)("p",null,"In general ",(0,r.yg)("inlineCode",{parentName:"p"},"step_up")," should always be significantly smaller then ",(0,r.yg)("inlineCode",{parentName:"p"},"step_down")," to ensure we gradually\nreapproach the ideal state."),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Configuration options"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"timeout")," - Maximum allowed 'write' time in milliseconds."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"step_down")," - What additional percentile should be dropped in the case of a timeout (default 5%: ",(0,r.yg)("inlineCode",{parentName:"li"},"0.05"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"step_up")," - What percentile should be recovered in case of a good event. (default: 0.1%: ",(0,r.yg)("inlineCode",{parentName:"li"},"0.001"),")")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"overflow")," - Events that are not let past due to active backpressure")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"define qos::percentile operator as perc\nwith\n  timeout = 100,\n  step_down = 0.1 # 10%\nend;\n")),(0,r.yg)("h2",{id:"qosroundrobin"},"qos::roundrobin"),(0,r.yg)("p",null,"Evenly distributes events over it's outputs. If a CB trigger event is received from an output this\noutput is skipped until the circuit breaker is restored. If all outputs are triggered the operator\nitself triggers a CB event."),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"*")," (any named output is possible)")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define qos::roundrobin operator roundrobin\nwith\n  outputs = ["round", "robin", "outputs"]\nend;\n')),(0,r.yg)("h2",{id:"qoswal"},"qos::wal"),(0,r.yg)("p",null,"A Write Ahead Log that will persist data to disk and feed the following operators from this disk\ncache. It allows to run onramps that do not provide any support for delivery guarantees with\nofframps that do."),(0,r.yg)("p",null,"The wal operator will intercept and generate it's own circuit breaker events. You can think about it\nas a firewall that will protect all operators before itself from issues beyond it. On the other hand\nit will indiscriminately consume data from sources and operators before itself until it's own\ncircuit breaking conditions are met."),(0,r.yg)("p",null,"At the same time will it interact with tremors guaranteed delivery system, events are only removed\nfrom disk once they're acknowledged. In case of delivery failure the WAL operator will replay the\nfailed events. On the same way the WAL operator will acknowledge events that it persists to disk."),(0,r.yg)("p",null,"The WAL operator should be used with caution, since every event that passes through it will be\nwritten to the hard drive it has a significant performance impact."),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Configuration options"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"read_count")," - Maximum number of events that are read form the WAL at one time."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"dir")," - Directory to store the WAL-file in (optional, if omitted the WAL will remain in memory and not be\npersisted to disk)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"max_elements")," - Maximum number of elements the WAL will cache before triggering a CB event"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"max_bytes")," - Maximum space on disk the WAL should take (this is a soft limit!)")),(0,r.yg)("p",null,"Only one of ",(0,r.yg)("inlineCode",{parentName:"p"},"max_elements")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"max_bytes")," is required, setting both is possible."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out"))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define qos::wal operator wal with\n  dir = "./wal",\n  read_count = 20,\n  max_elements = 1000,\n  max_bytes = 10485760\nend;\n')),(0,r.yg)("h2",{id:"genericbatch"},"generic::batch"),(0,r.yg)("p",null,"The batch operator is used to batch multiple events and send them in a bulk fashion. It also allows to set a timeout of how long the operator should wait for a batch to be filled."),(0,r.yg)("p",null,"This operator batches both the event payload and event metadata into a single bulk event. Downstream pipeline nodes or offramps will receive 1 such bulk event but will treat its context as multiple events and might act different e.g. when it comes to building a request payload in the offramp context or other use cases. Empty bulk events are usually considered as ",(0,r.yg)("inlineCode",{parentName:"p"},"no")," event."),(0,r.yg)("p",null,"Supported configuration options are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"count")," - Elements per batch"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"timeout")," - Maximum delay between the first element of a batch and the last element of a batch.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out"))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"define generic::batch operator batch with\n  count = 300\nend;\n")),(0,r.yg)("h2",{id:"genericcounter"},"generic::counter"),(0,r.yg)("p",null,"Keeps track of the number of events as they come and emits the current count out alongside the event. The output is a record of the form ",(0,r.yg)("inlineCode",{parentName:"p"},'{"count": n, "event": event}'),", where ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," is the current count and ",(0,r.yg)("inlineCode",{parentName:"p"},"event")," is the original event."),(0,r.yg)("p",null,"The counter starts when the first event comes through and begins from 1."),(0,r.yg)("p",null,"This operator preserves event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out"))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},"define generic::counter operator counter;\n")),(0,r.yg)("h2",{id:"debughistory"},"debug::history"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"This operator is for debugging purposes only, and should not be used in production deployments.\n"))),(0,r.yg)("p",null,"This operator generates a history entry in the event metadata underneath the field provided in the ",(0,r.yg)("inlineCode",{parentName:"p"},"name")," config value. Data is pushed to the array as a Striong in the form: ",(0,r.yg)("inlineCode",{parentName:"p"},'"event: <op>(<event_id>)"'),"."),(0,r.yg)("p",null,"This can be used as a tracepoint of events in a complex pipeline setup."),(0,r.yg)("p",null,"This operator manipulates a section of the event metadata."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Configuration options"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"op")," - The operation name of this operator"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"name")," - The field to store the history on")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Outputs"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"out"))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'define debug::history operator history with\n  op = "my-checkpoint",\n  name = "event_history"\nend;\n')))}g.isMDXComponent=!0}}]);