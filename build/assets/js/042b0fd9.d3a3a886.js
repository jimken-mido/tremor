"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[3128],{88967:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=t(58168),i=(t(96540),t(15680));t(40281);const s={},r="Aggregations",o={unversionedId:"concepts/aggregation",id:"version-0.12/concepts/aggregation",title:"Aggregations",description:"A key feature of the [Select] queries are aggregations. These are supported with:",source:"@site/versioned_docs/version-0.12/concepts/aggregation.md",sourceDirName:"concepts",slug:"/concepts/aggregation",permalink:"/docs/0.12/concepts/aggregation",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/concepts/aggregation.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"Syslog UDP with DNS",permalink:"/docs/0.12/guides/old/syslog_udp_dns/"},next:{title:"Batching",permalink:"/docs/0.12/concepts/batching"}},g={},l=[{value:"Windowing",id:"windowing",level:2},{value:"Tilt Frames",id:"tilt-frames",level:2}],m={toc:l},d="wrapper";function c(e){let{components:n,...s}=e;return(0,i.yg)(d,(0,a.A)({},m,s,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"aggregations"},"Aggregations"),(0,i.yg)("p",null,"A key feature of the ",(0,i.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," queries are aggregations. These are supported with:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Windows - A window is a range of events, clock or data time. There can be many different types of windows."),(0,i.yg)("li",{parentName:"ul"},"Aggregate functions - An aggregate function is a function that runs in the context of a window of events, emitting results intermittently"),(0,i.yg)("li",{parentName:"ul"},"Tilt Frames - A tilt frame is a chain of compatible windows with ",(0,i.yg)("strong",{parentName:"li"},"decreasing")," resolution used to reduce memory pressure and preserve relative accuracy of windowed aggregate functions")),(0,i.yg)("p",null,"An example clock-driven tumbling window:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-troy"},'use std::time::nanos;\n\ndefine window `15secs` from tumbling\nwith\n   interval = nanos::from_seconds(15),\nend;\n\nselect {\n    "count": aggr::stats::count(), # Aggregate \'count\' function\n    "min": aggr::stats::min(event.value),\n    "max": aggr::stats::max(event.value),\n    "mean": aggr::stats::mean(event.value),\n    "stdev": aggr::stats::stdev(event.value),\n    "var": aggr::stats::var(event.value),\n}\nfrom in[`15secs`] # We apply the window nominally to streams or input ports\ninto out;\n')),(0,i.yg)("p",null,"To use a window we need to define the window specifications, such as a 15 second clock-based\ntumbling window called ",(0,i.yg)("inlineCode",{parentName:"p"},"15secs")," as above. We can then create instances of these windows at runtime by\napplying those windows to streams. This is done in the ",(0,i.yg)("inlineCode",{parentName:"p"},"from")," clause of a ",(0,i.yg)("inlineCode",{parentName:"p"},"select")," statement."),(0,i.yg)("p",null,"Wherever windows are applied, aggregate functions can be used. In the above example, we are calculating\nthe minimum, maximum, average, standard deviation and variance of a ",(0,i.yg)("inlineCode",{parentName:"p"},"value")," numeric field in data streaming\ninto the query via the standard input stream."),(0,i.yg)("p",null,"The query language is not constrained to clock-driven window definitions. Windows can also be\ndata-driven or fully programmatic."),(0,i.yg)("p",null,"A more complete example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tremor"},'select {\n    "measurement": event.measurement,\n    "tags": patch event.tags of insert "window" => window end,\n    "stats": aggr::stats::hdr(event.fields[group[2]], [ "0.5", "0.9", "0.99", "0.999" ]),\n    "class": group[2],\n    "timestamp": aggr::win::first(event.timestamp),\n}\nfrom in[`10secs`, `1min`, `10min`, `1h`]\nwhere event.measurement == "udp_lb_test"\n   or event.measurement == "kafka-proxy.endpoints"\n   or event.measurement == "burrow_group"\n   or event.measurement == "burrow_partition"\n   or event.measurement == "burrow_topic"\ngroup by set(event.measurement, event.tags, each(record::keys(event.fields)))\ninto normalize;\n')),(0,i.yg)("p",null,"In the above example we use a single aggregate function called ",(0,i.yg)("inlineCode",{parentName:"p"},"aggr::stats::hdr")," which uses a high dynamic range\nor HDR Histogram to compute quantile estimates and basic statistics against a number of dynamic grouping fields\nset by the ",(0,i.yg)("inlineCode",{parentName:"p"},"group")," clause. A group clause effectively partitions our operation by the group expressions provided\nby the trickle query programmer. In the example, we're using the field names of the nested 'fields' record on inbound\nevents to compose a component of a group that is also qualified by tags and a measurement name. The field component\nis used as a numeric input to the histogram aggregate function."),(0,i.yg)("p",null,"In the ",(0,i.yg)("inlineCode",{parentName:"p"},"from")," clause, we are using a tilt frame, or a succession of window resolutions over which this aggregate\nfunction is producing results. So a ",(0,i.yg)("inlineCode",{parentName:"p"},"10secs")," window is emitting on a 10-second repeating basis into a ",(0,i.yg)("inlineCode",{parentName:"p"},"1min")," frame.\nSo 6 times per second the state of the 10 second window is merged into the ",(0,i.yg)("inlineCode",{parentName:"p"},"1min")," frame. This merge process is\nperformed for each frame in the tilt frame."),(0,i.yg)("p",null,"The advantage of tilt-frames is that as the target expression is ",(0,i.yg)("strong",{parentName:"p"},"the same")," for each frame, we can ",(0,i.yg)("em",{parentName:"p"},"merge")," across\neach frame without amplifying error - in short, we get the ",(0,i.yg)("strong",{parentName:"p"},"effect")," of summarisation without loss of accuracy."),(0,i.yg)("h2",{id:"windowing"},"Windowing"),(0,i.yg)("p",null,"Assuming a periodic event delivered every 2 seconds into tremor."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"tumbling-event-windows.png",src:t(82097).A,width:"800",height:"336"})),(0,i.yg)("p",null,"A size based window of size 2 would emit a synthetic output event every 2 events.\nSo the lifespan of a size based window is 2 events, repeated and non-overlapping for tumbling style windows.\nIn the illustration above events ",(0,i.yg)("inlineCode",{parentName:"p"},"1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"2")," in the first window ",(0,i.yg)("inlineCode",{parentName:"p"},"w0")," produce a single synthetic or derivate event ",(0,i.yg)("inlineCode",{parentName:"p"},"a"),"\nEvents ",(0,i.yg)("inlineCode",{parentName:"p"},"3")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"4")," in the second window ",(0,i.yg)("inlineCode",{parentName:"p"},"w1")," produce a single synthetic or derivate event ",(0,i.yg)("inlineCode",{parentName:"p"},"b"),"\nAs there is no 6th event in the example illustration, we will ",(0,i.yg)("em",{parentName:"p"},"never")," get another synthetic output event"),(0,i.yg)("p",null,"Contrast this with the 10 second or clock-based tumbling window. In the first window ",(0,i.yg)("inlineCode",{parentName:"p"},"w0"),"s lifetime we capture\nall events in the illustration."),(0,i.yg)("h2",{id:"tilt-frames"},"Tilt Frames"),(0,i.yg)("p",null,"Assuming a continuous flow of events into tremor..."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"tilt-frame-mechanics.png",src:t(46049).A,width:"720",height:"316"})),(0,i.yg)("p",null,"All the synthetic outputs of successive 5 minute windows that fit into a 15 minute interval are ",(0,i.yg)("strong",{parentName:"p"},"merged"),"\ninto the 15 minute window. All the outputs of successive 15 minute intervals that fit into a 1 hour interval\nare ",(0,i.yg)("strong",{parentName:"p"},"merged")," into the 1 hour window. By chaining and merging, tremor can optimise ( reduce ) the amount\nof memory required across the chain when compared to multiple independent windows ",(0,i.yg)("inlineCode",{parentName:"p"},"select")," expressions.\nIn the case of aggregate functions like ",(0,i.yg)("inlineCode",{parentName:"p"},"aggr::stats::hdr`` or"),"aggr::stats::dds``` the savings are significant."),(0,i.yg)("p",null,"If we imagine 1M events per second, that is 300M events every 5 minutes. 900M every 15, 3.6B every hour."),(0,i.yg)("p",null,"By using tilt frames we can maximally minimize internal memory consumption, whilst reducing the volume of\nincremental computation ( per event, per frame ), and further whilst preserving relative accuracy for\nmerge-capable aggregate functions."),(0,i.yg)("p",null,"The converged statistics under merge exhibit the same relative accuracy at a fraction of the computational\nand memory overhead without the using the tilt-frame mechanism."))}c.isMDXComponent=!0},46049:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/tilt-frame-mechanics-ad37cfa0eab92e84ec9838c364ceef1b.png"},82097:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/tumbling-event-windows-0c396bde4a1226bc661003e2bfee0ebd.png"}}]);