"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[9185],{79545:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>g,frontMatter:()=>s,metadata:()=>i,toc:()=>h});var a=n(58168),o=(n(96540),n(15680));n(40281);const s={},r="Batching",i={unversionedId:"concepts/batching",id:"version-0.12/concepts/batching",title:"Batching",description:"Batching is a complex topic. It happens in many layers, and it's easy to confuse one with another. This makes it especially important to explain the concepts of batching the tremor engine uses.",source:"@site/versioned_docs/version-0.12/concepts/batching.md",sourceDirName:"concepts",slug:"/concepts/batching",permalink:"/docs/0.12/concepts/batching",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/concepts/batching.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"Aggregations",permalink:"/docs/0.12/concepts/aggregation"},next:{title:"Runtime Capabilities",permalink:"/docs/0.12/concepts/runtime_capabilities"}},c={},h=[{value:"Inbound messages (Connectors)",id:"inbound-messages-connectors",level:2},{value:"Transparent unbatching",id:"transparent-unbatching",level:3},{value:"Userland unbatching",id:"userland-unbatching",level:3},{value:"Pipelines",id:"pipelines",level:2},{value:"The batch operator",id:"the-batch-operator",level:3},{value:"windows and aggregates",id:"windows-and-aggregates",level:3},{value:"the script operator",id:"the-script-operator",level:3},{value:"select and group by each",id:"select-and-group-by-each",level:3},{value:"Outbound messages (Connectors)",id:"outbound-messages-connectors",level:2},{value:"Batched events",id:"batched-events",level:3},{value:"userland batched events",id:"userland-batched-events",level:3}],l={toc:h},p="wrapper";function g(e){let{components:t,...n}=e;return(0,o.yg)(p,(0,a.A)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"batching"},"Batching"),(0,o.yg)("p",null,"Batching is a complex topic. It happens in many layers, and it's easy to confuse one with another. This makes it especially important to explain the concepts of batching the tremor engine uses."),(0,o.yg)("p",null,"In general, tremor is not a batching or micro batching engine. Every event is handled as it happens, when it happens, without combining it with outer events."),(0,o.yg)("p",null,"When we refer to batching, we refer to an event that comes out of the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/batch"},"batch operator"),". These events are special as they create a batch but retain information about the unique events in them. The engine has specific methods of handing them and some connectors to treat it differently - more to that later."),(0,o.yg)("p",null,"To explain how batching can come into play, let's look at the different parts of the engine."),(0,o.yg)("h2",{id:"inbound-messages-connectors"},"Inbound messages (Connectors)"),(0,o.yg)("p",null,"Generally, tremor does not batch for inbound events. There are cases where the connector receives batched messages. There are two ways the tremor handles this, depending on the connector."),(0,o.yg)("h3",{id:"transparent-unbatching"},"Transparent unbatching"),(0,o.yg)("p",null,"Some connectors use batching as a way of transport optimization, where the server sends many events in a single network package to reduce cost. The ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/kafka"},"kafka")," connector would be an example of this. Here the batching behavior is transparent to tremors and users. Each event in the batch will be treated as if the batch didn't exist."),(0,o.yg)("h3",{id:"userland-unbatching"},"Userland unbatching"),(0,o.yg)("p",null,"Sometimes batching happens in userland, or the connector is not aware of it as it isn't an inherent part of the transport or protocol but rather something that was built on top of it. In these cases, tremor will treat the entire batch as a single event, and it's up to the user to implement this userland de-batching."),(0,o.yg)("p",null,"Sending several logs in a single UDP message would be an excellent example. From tremor's perspective, it is one message, so one event. Tremor can't know that, in this instance, the content of the message would reflect multiple events without being told. "),(0,o.yg)("p",null,"To bridge this, we offer the concept of ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/preprocessors/"},"preprocessors"),", which allows taking a large message and splitting it into smaller ones. The most common one used is the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/preprocessors/separate"},"separate"),", which allows separating the input given a specific byte (by default, the newline)."),(0,o.yg)("h2",{id:"pipelines"},"Pipelines"),(0,o.yg)("p",null,"In pipelines, we have multiple ways of turning a single event into many events (unlatching) or turning many events into a single one (batching). Again, we have the difference between a userland method and an engine-aware method."),(0,o.yg)("h3",{id:"the-batch-operator"},"The batch operator"),(0,o.yg)("p",null,"The batch operator is a very powerful operator that allows for performance optimizing downstream connections. For details on how to configure it please look at ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/batch"},"it's documentation"),"."),(0,o.yg)("p",null,"It generates a new event from several existing events, combining them so that the engine is aware this is a batch and can be handled transparently for the downstream connector in a way that's appropriate for the system it connects to."),(0,o.yg)("h3",{id:"windows-and-aggregates"},"windows and aggregates"),(0,o.yg)("p",null,"You can find more details on how aggregation is implemented in tremor in the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/concepts/aggregation"},"aggregation section")," of the concepts. "),(0,o.yg)("p",null,"What windows and aggregates allow is to combine multiple events into a single event given user land logic. This means batches can be pretty cheap and fairly flexibly created. However, since the shape of these batches is opaque to the engine, the resulting event isn't considered a \"batched\" event. It's regarded as a regular event, so connectors will treat it like any other event."),(0,o.yg)("h3",{id:"the-script-operator"},"the script operator"),(0,o.yg)("p",null,"Scripts allow for batching as they support complete and stateful control over events. For logic that goes beyond what a select and aggregate can do, they give complete control over how multiple events are combined into a single one. This is a lot more powerful than aggregates with a window, but it trades this for being more resource-intensive."),(0,o.yg)("p",null,"This is opaque to the engine like aggregates and windows, and the result is treated as a singular event."),(0,o.yg)("h3",{id:"select-and-group-by-each"},"select and group by each"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"select")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"group by each(...)")," can be used to un-batch an event because it takes a singular event that in some shape can be turned into an array and processes separately after this. It is to preprocessors what scripts are to aggregates. It's more powerful but also more expensive."),(0,o.yg)("h2",{id:"outbound-messages-connectors"},"Outbound messages (Connectors)"),(0,o.yg)("p",null,"The batching behavior of outbound connectors mostly mirrors the behavior of inbound connectors."),(0,o.yg)("h3",{id:"batched-events"},"Batched events"),(0,o.yg)("p",null,"When an event arrives as a batched event, meaning it was generated using the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/batch"},"batch operator"),", the connector will treat it in a way that is most sensitive to the transport and the downstream application (if known)."),(0,o.yg)("p",null,"So, for example, the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/elastic"},"elastic")," connector that receives a batched event will combine all included events into a batched request. We can do this since, for this specialty connector, tremor can be aware of the application layer contract."),(0,o.yg)("p",null,"On the other hand, in a system like ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/kafka"},"kafka"),", a batched event will be unrolled, and each included event will be sent as its own message."),(0,o.yg)("p",null,"Connectors like ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/connectors/http"},"http")," form the middle ground. For batched events, they will concatenate the encoded events and send them in one message. This behavior can be influenced by ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/postprocessors/"},"postprocessors")," that allow modifying the data before it's being concatenated. An excellent example of this would be the ",(0,o.yg)("a",{parentName:"p",href:"/docs/0.12/reference/postprocessors/separate"},"separate")," postprocessors that insert a separator between each batch event."),(0,o.yg)("h3",{id:"userland-batched-events"},"userland batched events"),(0,o.yg)("p",null,"Events batched using ",(0,o.yg)("inlineCode",{parentName:"p"},"select")," or the ",(0,o.yg)("inlineCode",{parentName:"p"},"script")," operator will always be treated as a singular event. It is up to the user to bring it in a form that is understood by the other sites' application layer."))}g.isMDXComponent=!0}}]);