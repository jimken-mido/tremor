"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[3636],{35507:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var a=t(58168),r=(t(96540),t(15680)),i=t(40281);const s={sidebar_position:9},o="Common Patterns",l={unversionedId:"language/common_patterns",id:"version-0.12/language/common_patterns",title:"Common Patterns",description:"This document provides a few recipes for common patterns in Tremor [Scripts]. Please note however that it neither is exhaustive nor should those patterns considered the 'only way' to perform certain tasks.",source:"@site/versioned_docs/version-0.12/language/common_patterns.md",sourceDirName:"language",slug:"/language/common_patterns",permalink:"/docs/0.12/language/common_patterns",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/language/common_patterns.md",tags:[],version:"0.12",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"indexSidebar",previous:{title:"Script Grammar",permalink:"/docs/0.12/language/reference/script"},next:{title:"History",permalink:"/docs/0.12/language/history"}},p={},d=[{value:"Extracting a raw message",id:"extracting-a-raw-message",level:2},{value:"Appending to an array",id:"appending-to-an-array",level:2},{value:"Validating over extracted data",id:"validating-over-extracted-data",level:2},{value:"Replacing a field with an extraction",id:"replacing-a-field-with-an-extraction",level:2},{value:"No effect on non matching case",id:"no-effect-on-non-matching-case",level:2},{value:"Boolean decisions",id:"boolean-decisions",level:2},{value:"Diverting an event to a different channel",id:"diverting-an-event-to-a-different-channel",level:2},{value:"The &#39;null default&#39;",id:"the-null-default",level:2},{value:"Testing against the type of a field",id:"testing-against-the-type-of-a-field",level:2},{value:"Routing messages",id:"routing-messages",level:2},{value:"Percentage drops of events",id:"percentage-drops-of-events",level:2},{value:"Check if a variable is present/absent",id:"check-if-a-variable-is-presentabsent",level:2},{value:"Branching",id:"branching",level:3},{value:"Combining",id:"combining",level:3}],g={toc:d},c="wrapper";function m(e){let{components:n,...t}=e;return(0,r.yg)(c,(0,a.A)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"common-patterns"},"Common Patterns"),(0,r.yg)("p",null,"This document provides a few recipes for common patterns in Tremor ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/scripts"},"Scripts"),". Please note however that it neither is exhaustive nor should those patterns considered the 'only way' to perform certain tasks."),(0,r.yg)("h2",{id:"extracting-a-raw-message"},"Extracting a raw message"),(0,r.yg)("p",null,"If the event is a unstructured / raw message parsing it can be tricky since we can not match over the contents string, except for similarity with a ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#utf-8-encoded-strings"},"String literal"),". The following code offers a solution to it by using the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/extractors/dissect"},"dissect extractor"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = "John Doe"\n\nlet event =  match {"message": event} of\n  case r = %{ message ~= dissect|%{first} %{last}| } => r.message\n  default => drop\nend;\n# event = {"first" : "John", "last": "Doe"}\n')),(0,r.yg)("h2",{id:"appending-to-an-array"},"Appending to an array"),(0,r.yg)("p",null,"In order to append to an array we can use the ",(0,r.yg)("a",{parentName:"p",href:"../reference/stdlib/std/array#pusharray-element"},(0,r.yg)("inlineCode",{parentName:"a"},"array::push"))," function"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::array;\n# event = {"key": "value", "tags": ["tag1"]}\nlet event.tags = array::push(event.tags, "tag2");\n# event = {"key": "value", "tags": ["tag1", "tag2"]}\n')),(0,r.yg)("h2",{id:"validating-over-extracted-data"},"Validating over extracted data"),(0,r.yg)("p",null,"Sometimes we want to validate over extracted data without forcing the extraction to be a regular expression. For validations like the one below this pattern can be used."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::array;\nmatch event of\n  # ...\n  case result = %{message ~= dissect|%{log_level} %{log_timestamp}: %{logger}: %{message}|} when array::contains(["ERROR", "WARN", "INFO", "DEBUG"], result.message.log_level) => \n    let event = merge event of reesult.message end\n  # ...\nend\n')),(0,r.yg)("p",null,"Here we extract the ",(0,r.yg)("inlineCode",{parentName:"p"},"log_level")," and validate of that the it is one of ",(0,r.yg)("inlineCode",{parentName:"p"},"ERROR"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"WARN"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"INFO")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"DEBUG")," by moving the check into the when guard we don't need to use a regular expression for this validation. Instead we can use array membership."),(0,r.yg)("h2",{id:"replacing-a-field-with-an-extraction"},"Replacing a field with an extraction"),(0,r.yg)("p",null,"When extracting a field to merge with with the event and wanting to remove the extracted field we can take advantage of the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#merge"},(0,r.yg)("inlineCode",{parentName:"a"},"merge"))," expressions behaviour that it will treat ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," in merged records as a command to delete the data by setting the field to replace to ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," before merging."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = %{"message": "John Doe"}\nlet event = merge event of \n  match event of\n    case r = %{message ~= dissect|%{first} %{last}| } => \n      let r = r.message;\n      let r.message = null;\n      r\n    default => {}\n  end;\nend;\n# event = %{"first": "John", "last": "Doe"}\n')),(0,r.yg)("h2",{id:"no-effect-on-non-matching-case"},"No effect on non matching case"),(0,r.yg)("p",null,"If we use ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#merge"},(0,r.yg)("inlineCode",{parentName:"a"},"merge"))," with match we can make the ",(0,r.yg)("inlineCode",{parentName:"p"},"default")," case to have no effect by using ",(0,r.yg)("inlineCode",{parentName:"p"},"{}"),". This is possible since ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#merge"},(0,r.yg)("inlineCode",{parentName:"a"},"merge"))," on ",(0,r.yg)("inlineCode",{parentName:"p"},"{}")," is a identity function."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# event = %{"message": "John Doe"}\nlet event = merge event of \n  match event of\n    case r = %{message ~= dissect|%{first} %{midle} %{last}| } => \n      let r = r.message;\n      let r.message = null;\n      r\n    default => {}\n  end;\nend;\n# event = %{"message": "John Doe"}\n')),(0,r.yg)("h2",{id:"boolean-decisions"},"Boolean decisions"),(0,r.yg)("p",null,"To make boolean decisions we can match on ",(0,r.yg)("inlineCode",{parentName:"p"},"true")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"false"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::type;\n\nmatch type::is_record(event) of\n  case true => let event_type = "record"\n  case false => let event_type = "other"\nend\n')),(0,r.yg)("h2",{id:"diverting-an-event-to-a-different-channel"},"Diverting an event to a different channel"),(0,r.yg)("p",null,"By default the ","[Script]"," operator forwards all events that are not dropped to the ",(0,r.yg)("inlineCode",{parentName:"p"},"out")," port for further processing. However it is possible to route events to different ports using the ",(0,r.yg)("inlineCode",{parentName:"p"},"emit")," keyword. This allows, for example, diverting certain events to reserve bandwidth for a more important subset."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event.importance of\n  case "high" => emit # this is the same as emit event => "out"\n  case "medium" => emit event => "divert"\n  default => drop # deletes the event\nend\n')),(0,r.yg)("h2",{id:"the-null-default"},"The 'null default'"),(0,r.yg)("p",null,"When the result of a match statement isn't needed - as in we use it purely for it's side effects - and we want the ",(0,r.yg)("inlineCode",{parentName:"p"},"default")," to have no effect we can use ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," here."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'match event of\n  case %{ tags ~= ["high-priority"]} => let event.importance = "high"\n  default => null\nend\n')),(0,r.yg)("h2",{id:"testing-against-the-type-of-a-field"},"Testing against the type of a field"),(0,r.yg)("p",null,"Sometimes we want to know if a field has a certain type. The ",(0,r.yg)("inlineCode",{parentName:"p"},"type")," module provides help here but common types such as ",(0,r.yg)("inlineCode",{parentName:"p"},"record")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"array")," can be checked using their patterns."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'use std::type;\n\nmatch event of\n  case %{field ~= %{}} => emit "event.field is a record"\n  case %{field ~= %[]} => emit "event.field is a array"\n  case %{} when type::is_record(event.field) => emit "event.field is a record"\n  case %{} when type::is_array(event.field) => emit "event.field is a array"\n  case %{} when type::is_number(event.field) => emit "event.field is a number (float or integer)"\n  case %{} when type::is_integer(event.field) => emit "event.field is an integer"\n  case %{} when type::is_float(event.field) => emit "event.field is a float"\n  case %{} when type::is_null(event.field) => emit "event.field is null (but set)"\n  case %{absent field} => emit "event.field is not set"\n  # ...\nend\n')),(0,r.yg)("h2",{id:"routing-messages"},"Routing messages"),(0,r.yg)("p",null,"A ","[Script]"," can be used to route messages by combining the ",(0,r.yg)("inlineCode",{parentName:"p"},"emit")," feature and the fact that the ","[Script]"," operator allows different output ports."),(0,r.yg)("p",null,"To route to doing a ",(0,r.yg)("inlineCode",{parentName:"p"},"blue")," / ",(0,r.yg)("inlineCode",{parentName:"p"},"green")," split based on a field in a record we could use the following code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'define pipeline split\npipeline\n\n  define script split_script\n  script\n    match event of\n      case %{key == "blue"} => emit event => "blue"\n      case %{key == "green"} => emit event => "green"\n      default => drop\n    end\n  end;\n  create script split_script;\n\n  select event from split_script/blue into out/blue;\n  select event from split_script/green into out/green;\nend\n')),(0,r.yg)("h2",{id:"percentage-drops-of-events"},"Percentage drops of events"),(0,r.yg)("p",null,"To drop a percentage of all events, functions in the ",(0,r.yg)("a",{parentName:"p",href:"../reference/stdlib/std/random"},"random")," module can be used."),(0,r.yg)("p",null,"We generate a random number in a range and based on the outcome, we decide whether we want to drop an event or not. Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"# drop 50% of the events\nmatch random::integer(0, 100) < 50 of\n  case true => drop\n  default => null\nend\n")),(0,r.yg)("p",null,"Most of the time, we want to do this only for certain matching events (as opposed to all events)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'let random_number = random::integer(0, 100);\nmatch event of\n  case %{key == "blue"} when random_number < 25 => drop   # drop 25% of blue events\n  case %{key == "yellow"} when random_number < 75 => drop # drop 75% of yellow events\n  case %{key == "red"} => drop                            # drop 100% of red events\n  default => null                                         # drop 0% of other events\nend\n')),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Also consider the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/reference/operators/percentile"},(0,r.yg)("inlineCode",{parentName:"a"},"qos::percentile")," operator")," for this kind of task.")),(0,r.yg)("h2",{id:"check-if-a-variable-is-presentabsent"},"Check if a variable is present/absent"),(0,r.yg)("p",null,"To check if a variable is present, we can rely on the ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/script#presence-and-absence"},(0,r.yg)("inlineCode",{parentName:"a"},"present")," keyword")," (and inversely, ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/reference/script#presence-and-absence"},(0,r.yg)("inlineCode",{parentName:"a"},"absent")),")."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# matches default case\nmatch present non_existent_var of\n  case true => "is present"\n  default => "not present"\nend;\n')),(0,r.yg)("p",null,"Note that this is different from the case where a variable is set to ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),", for which we can do ",(0,r.yg)("a",{parentName:"p",href:"../reference/stdlib/std/type#is_nullvalue"},"function-based")," checks as well as pattern-match with ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#match"},"match"),"."),(0,r.yg)("p",null,"Using non-existent variables in contexts other than ",(0,r.yg)("inlineCode",{parentName:"p"},"present")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"absent")," will throw an error terminating the script, so this is useful for guarding against that when needed. This is especially useful when working with meta variables as part of tremor runtime, where -- as part of a pipeline node -- we may need to check if a certain meta variable is set or not (eg: from a previous pipeline node) and act accordingly. For such needs, the approach above can be used. Alternatively, we can also rely on ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/expressions#matching-record-patterns"},"record patterns")," there:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},'# tests for presence of $key\nmatch $ of\n  case %{present key} => "present"\n  default => "not present"\nend;\n')),(0,r.yg)("p",null,"Since ",(0,r.yg)("inlineCode",{parentName:"p"},"$")," gives a record with all the meta variable name-value mapping, this works nicely."),(0,r.yg)("h3",{id:"branching"},"Branching"),(0,r.yg)("p",null,"Branching data into multiple streams is performed via ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," operations"),(0,r.yg)("p",null,"Branch data into 3 different output stream ports:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"select event from in into out/a;\nselect event from in into out/b;\nselect event from in into out/c;\n")),(0,r.yg)(i.K,{chart:"graph LR\n  A --\x3e|branch| B & C & D",mdxType:"Mermaid"}),(0,r.yg)("p",null,"Branch data into 3 different intermediate ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#stream-definitions"},"Streams"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"create stream a;\ncreate stream b;\ncreate stream c;\n\nselect event from in into a;\nselect event from in into b;\nselect event from in into c;\n")),(0,r.yg)("h3",{id:"combining"},"Combining"),(0,r.yg)("p",null,"Multiple data streams can also be combined via ",(0,r.yg)("a",{parentName:"p",href:"/docs/0.12/language/pipelines#select-queries"},"Select")," operations."),(0,r.yg)("p",null,"Combine 3 data streams into a single output stream:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"...\n\nselect event from a into out;\nselect event from b into out;\nselect event from c into out;\n")),(0,r.yg)("p",null,"Combine 3 data stream ports from 1 or many streams into a single output stream"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tremor"},"...\n# select events from port `1` on stream `a`\nselect event from a/1 into out;\n\n# select events from port `2` on stream `a`\nselect event from a/2 into out;\n\n# select event from default port `out` on stream `b`\nselect event from b into out;\n")))}m.isMDXComponent=!0}}]);