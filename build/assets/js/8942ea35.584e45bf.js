"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[7622],{50846:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=t(58168),o=(t(96540),t(15680));t(40281);const a={sidebar_position:0},r="Basics",s={unversionedId:"guides/basics",id:"version-0.12/guides/basics",title:"Basics",description:"This guide is a walk through of tremor basics. It is a starting point to learn",source:"@site/versioned_docs/version-0.12/guides/basics.md",sourceDirName:"guides",slug:"/guides/basics",permalink:"/docs/0.12/guides/basics",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/guides/basics.md",tags:[],version:"0.12",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"indexSidebar",previous:{title:"Guides",permalink:"/docs/0.12/guides/"},next:{title:"Metrics",permalink:"/docs/0.12/guides/metrics"}},l={},p=[{value:"Topics",id:"topics",level:2},{value:"Passthrough",id:"passthrough",level:2},{value:"Flow",id:"flow",level:3},{value:"Connectors",id:"connectors",level:3},{value:"Pipeline",id:"pipeline",level:3},{value:"Wiring",id:"wiring",level:3},{value:"Deploying the flow",id:"deploying-the-flow",level:3},{value:"Transformation",id:"transformation",level:2},{value:"Defining our pipeline",id:"defining-our-pipeline",level:3},{value:"Transforming in the select body",id:"transforming-in-the-select-body",level:3},{value:"Transforming in Scripts",id:"transforming-in-scripts",level:3},{value:"Running",id:"running",level:3},{value:"Filter",id:"filter",level:2},{value:"Adding the <code>exit</code> connector.",id:"adding-the-exit-connector",level:3},{value:"Filtering out exit messages",id:"filtering-out-exit-messages",level:3},{value:"Running",id:"running-1",level:3}],c={toc:p},d="wrapper";function m(e){let{components:n,...a}=e;return(0,o.yg)(d,(0,i.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"basics"},"Basics"),(0,o.yg)("p",null,"This guide is a walk through of tremor basics. It is a starting point to learn\nhow to stream data into the system, process this data stream, and produce a\nstream of synthetic events based on the processing of the original stream of\ndata."),(0,o.yg)("p",null,"The example is illustrative and a construction to introduce fundamentals, but it\nmay be useful as a string point for more complex works."),(0,o.yg)("p",null,"This guide has a number of progressive steps, each building on the fundamentals\nintroduced in the previous step."),(0,o.yg)("p",null,"After following the steps in this guide, you will have a small but complete and\nrunnable tremor application."),(0,o.yg)("p",null,"The source for the code in this guide is available in ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/guides/basics.md/../code/basics"},"github"),"."),(0,o.yg)("h2",{id:"topics"},"Topics"),(0,o.yg)("p",null,"This guide introduces the following new concepts"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Passthrough"),(0,o.yg)("li",{parentName:"ul"},"Flows"),(0,o.yg)("li",{parentName:"ul"},"Connectors"),(0,o.yg)("li",{parentName:"ul"},"Pipelines"),(0,o.yg)("li",{parentName:"ul"},"Scripts"),(0,o.yg)("li",{parentName:"ul"},"Queries with ",(0,o.yg)("inlineCode",{parentName:"li"},"select"),", and the ",(0,o.yg)("inlineCode",{parentName:"li"},"with")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"where")," clauses"),(0,o.yg)("li",{parentName:"ul"},"Modules and the ",(0,o.yg)("inlineCode",{parentName:"li"},"use")," statement for importing library functions, pipelines and connectors")),(0,o.yg)("h2",{id:"passthrough"},"Passthrough"),(0,o.yg)("p",null,"This is a very useful streaming operation that consumes data streams from a a source and\nrelays each received event to a destination or target downstream. It distributes each\nreceived event from the source to the destination."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Passthrough query\nselect event from in into out;\n")),(0,o.yg)("p",null,"We call this ",(0,o.yg)("inlineCode",{parentName:"p"},"passthrough")," as the data events stream or ",(0,o.yg)("strong",{parentName:"p"},"pass through")," without modification."),(0,o.yg)("p",null,"The processing and data sources and destinations are decoupled. These are connected together in ",(0,o.yg)("a",{parentName:"p",href:"#Flow"},"flow"),"\nstatements."),(0,o.yg)("h3",{id:"flow"},"Flow"),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"flow")," statement encapsulates instances of ",(0,o.yg)("inlineCode",{parentName:"p"},"connector")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"pipeline")," that can be interconnected to provide\na runnable embedded service complete with connectivity."),(0,o.yg)("p",null,"We begin our study from the outside, and define a flow called ",(0,o.yg)("inlineCode",{parentName:"p"},"main"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Our main flow\ndefine flow main\nflow\n  # ... We define and create connectors and pipelines here\nend;\n")),(0,o.yg)("h3",{id:"connectors"},"Connectors"),(0,o.yg)("p",null,"A ",(0,o.yg)("inlineCode",{parentName:"p"},"connector")," is a way to establish streams of data and use them to provide a useful flow."),(0,o.yg)("p",null,"A very useful set of connectors that ship as a part of tremor are the standard input/output\nor ",(0,o.yg)("a",{parentName:"p",href:"../reference/connectors/stdio"},(0,o.yg)("inlineCode",{parentName:"a"},"stdio"))," connectors. These pipe the standard input, output and error streams from the\nconsole to processors."),(0,o.yg)("p",null,"We use pre-packaged definitions in this example from the ",(0,o.yg)("inlineCode",{parentName:"p"},"tremor::connectors")," module from the standard library."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"The console connector is a configured instance of the ",(0,o.yg)("inlineCode",{parentName:"p"},"stdio")," connector that uses the ",(0,o.yg)("inlineCode",{parentName:"p"},"separate")," pre and postprocessor to make it line-based and the ",(0,o.yg)("a",{parentName:"p",href:"../reference/codecs/string"},(0,o.yg)("inlineCode",{parentName:"a"},"string")," codec")," to avoid any parsing of the input data.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  \n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n    # ... We have a means to read/write line delimited JSON, but have yet to define any processing logic\nend;\n")),(0,o.yg)("h3",{id:"pipeline"},"Pipeline"),(0,o.yg)("p",null,"Lastly, we need to define the processing logic for this ",(0,o.yg)("inlineCode",{parentName:"p"},"main")," flow."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"We could define passthrough ourselves as follows, but it is in common use, so available through the\nstandard library in ",(0,o.yg)("inlineCode",{parentName:"p"},"tremor::pipelines")," and called ",(0,o.yg)("inlineCode",{parentName:"p"},"passthrough"),":"),(0,o.yg)("pre",{parentName:"admonition"},(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="troy/pipelines.troy"',title:'"troy/pipelines.troy"'},"define pipeline passthrough\npipeline\n    select event from in into out;\nend\n"))),(0,o.yg)("p",null,"We use the definition provided by the standard library"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  # import the `tremor::pipelines` module\n  use tremor::pipelines;\n\n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n  # create an instance of the passthrough pipeline\n  create connector passthrough from pipelines::passthrough;\n\n  # ... We still `need` to interconnect our `console` and `passthrough` instances\nend;\n")),(0,o.yg)("h3",{id:"wiring"},"Wiring"),(0,o.yg)("p",null,"We now have all the components we need, a flow to host it all, a connector to read and write data, and a pipeline to process (or pass) the data. With that all in place, we need to wire those parts up. We can do that with ",(0,o.yg)("inlineCode",{parentName:"p"},"connect")," in the flow."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"   Connect allows connecting to different ports on connectors and pipelines. When omitted, ports default to ",(0,o.yg)("inlineCode",{parentName:"p"},"/out"),"  for the connection's source and to ",(0,o.yg)("inlineCode",{parentName:"p"},"/in")," for the connection's target. We will explore this more in a later step. For now, we'll ignore ports.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  # import the `tremor::pipelines` module\n  use tremor::pipelines;\n\n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n  # create an instance of the passthrough pipeline\n  create pipeline passthrough from pipelines::passthrough;\n\n  # connect the console (STDIN) to our pipeline input\n  connect /connector/console to /pipeline/passthrough;\n\n  # then connect the pipeline output to the console (STDOUT)\n  connect /pipeline/passthrough to /connector/console;\nend;\n")),(0,o.yg)("h3",{id:"deploying-the-flow"},"Deploying the flow"),(0,o.yg)("p",null,"We have already used pre-defined pipelines and connectors and created instances of them. Flows are not much different. They have a definition and an instantiation phase. While we call the instantiating of pipelines and connectors ",(0,o.yg)("inlineCode",{parentName:"p"},"create"),", for flows, we use ",(0,o.yg)("inlineCode",{parentName:"p"},"deploy")," as it is the step where the theoretical configuration becomes actual running code."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  # import the `tremor::pipelines` module\n  use tremor::pipelines;\n\n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n  # create an instance of the passthrough pipeline\n  create pipeline passthrough from pipelines::passthrough;\n\n  # connect the console (STDIN) to our pipeline input\n  connect /connector/console to /pipeline/passthrough;\n\n  # then connect the pipeline output to the console (STDOUT)\n  connect /pipeline/passthrough to /connector/console;\n\nend;\n# Deploy the flow, so tremor starts it\ndeploy flow main;\n")),(0,o.yg)("p",null,"That's it, you can fetch this file from ",(0,o.yg)("a",{target:"_blank",href:t(85680).A},"git")," and run it via:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"$ tremor run passthrough/main.troy\nhello\nhello\nworld\nworld\n\n")),(0,o.yg)("h2",{id:"transformation"},"Transformation"),(0,o.yg)("p",null,"We now have a way to pass data in our system, moving it through it and looking at the result. Our result is relatively simple, the same as the input we have. Let us change that and make the whole thing a bit more interesting."),(0,o.yg)("p",null,'Our goal will be to make each entry a "sentence" by capitalizing the first letter and adding a period ',(0,o.yg)("inlineCode",{parentName:"p"},".")," or question mark to the end."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"Tremor has handy utility modules for most data types that provide several functions to work with them, the ",(0,o.yg)("a",{parentName:"p",href:"../language"},"reference documentation")," gives an overview of them.")),(0,o.yg)("h3",{id:"defining-our-pipeline"},"Defining our pipeline"),(0,o.yg)("p",null,"We've been using the ",(0,o.yg)("inlineCode",{parentName:"p"},"tremor::pipelines::passthrough")," pipeline in the last step. It, as the name suggests, passes it through. So the first thing we need to do is replace this with our own. For simplicities sake, we'll start by replacing it with our pipeline. We will name this ",(0,o.yg)("inlineCode",{parentName:"p"},"main")," as we will extend it to be more than a passthrough."),(0,o.yg)("p",null,"To do this we create a new files named ",(0,o.yg)("inlineCode",{parentName:"p"},"lib/pipelines.tremor")," and use this pipeline in our flow."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"   Pipelines, by default, use the ports ",(0,o.yg)("inlineCode",{parentName:"p"},"in")," for input, ",(0,o.yg)("inlineCode",{parentName:"p"},"out")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"err")," for outputs. As with ",(0,o.yg)("inlineCode",{parentName:"p"},"connect"),", those definitions can be omitted as long as we use the standard. For details on defining your own ports, you can refer to the ",(0,o.yg)("a",{parentName:"p",href:"../language"},"reference documentation"),".")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="lib/pipelines.tremor"',title:'"lib/pipelines.tremor"'},"\n# define our main pipeline\ndefine pipeline main\npipeline\n  select event from in into out;\nend;\n")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="main.troy"',title:'"main.troy"'},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  # import the `tremor::pipelines` module\n  use lib::pipelines;\n\n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n  # create an instance of the passthrough pipeline\n  create pipeline main from pipelines::main;\n\n  # connect the console (STDIN) to our pipeline input\n  connect /connector/console to /pipeline/main;\n\n  # then connect the pipeline output to the console (STDOUT)\n  connect /pipeline/main to /connector/console;\n\nend;\n# Deploy the flow, so tremor starts it\ndeploy flow main;\n")),(0,o.yg)("h3",{id:"transforming-in-the-select-body"},"Transforming in the select body"),(0,o.yg)("p",null,"Now we have our pipeline in which we will capitalize the text that's passed through the pipeline, ",(0,o.yg)("a",{parentName:"p",href:"../reference/stdlib/std/string#capitalizeinput"},(0,o.yg)("inlineCode",{parentName:"a"},"std::string::capitalize"))," will do that for us, and we can use it right in the select statement we:"),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"In select statements, you can do any transformation that's creating new data, but you can't do any mutating manipulations. Simplified, you can think that ",(0,o.yg)("inlineCode",{parentName:"p"},"let")," is not allowed.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="lib/pipelines.tremor"',title:'"lib/pipelines.tremor"'},"# define our own main pipeline\ndefine pipeline main\npipeline\n  # use the `std::string` module\n  use std::string;\n  # Capitalize the string\n  select string::capitalize(event) from in into out;\nend;\n")),(0,o.yg)("h3",{id:"transforming-in-scripts"},"Transforming in Scripts"),(0,o.yg)("p",null,"Some transformations are a bit more complicated, and instead of the select body, we want a more elaborate script that makes the logic more readable."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"The significant advantage of scripts is to allow more complex mutation, chained logic, and access to ",(0,o.yg)("inlineCode",{parentName:"p"},"state"),". In this example, we'll not touch on all of them.")),(0,o.yg)("p",null,"So our goal will be to check if our sentence has punctuation. Otherwise, decide if we add a ",(0,o.yg)("inlineCode",{parentName:"p"},".")," or a ",(0,o.yg)("inlineCode",{parentName:"p"},"?"),"."),(0,o.yg)("p",null,"Scripts are a node in the pipeline, and we use ",(0,o.yg)("inlineCode",{parentName:"p"},"select")," statements to connect them, the same way that we use ",(0,o.yg)("inlineCode",{parentName:"p"},"connect")," to connect nodes of a flow."),(0,o.yg)("p",null,"To do this we, again define a new file ",(0,o.yg)("inlineCode",{parentName:"p"},"lib/scripts.tremor")," "),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"   The script could be inlined in the pipeline and the pipeline in the flow, but the model we use here creates nicer to manage applications.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="lib/pipeline.tremor"',title:'"lib/pipeline.tremor"'},'# define our script\ndefine script punctuate\nscript\n  # Short circuit if we already end with a punctuation\n  match event of\n    case ~re|[.?!]$| => emit event\n    case _ => null\n  end;\n\n  # Find the right punctuation by looking at the first wird of the last sentence\n  # yes this is a poor heuristic!\n  let punctuation = match event of \n    case ~ re|.*[.?!]?(Why\\|How\\|Where\\|Who)[^.?!]*$| => "?"\n    case _ => "."\n  end;\n  event + punctuation\nend;\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="lib/pipeline.tremor"',title:'"lib/pipeline.tremor"'},"define pipeline main\npipeline\n  # use the `std::string` module\n  use std::string;\n  use lib::scripts;\n\n  # Create our script\n  create script punctuate from scripts::punctuate;\n\n  # Wire our capitalized text to the script\n  select string::capitalize(event) from in into punctuate;\n  # Wire our script to the output\n  select event from punctuate into out;\nend;\n")),(0,o.yg)("h3",{id:"running"},"Running"),(0,o.yg)("p",null,"Same as before we can test our code, you can fetch the finished file from ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/guides/basics.md/../code/basics/transform.troy"},"git"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},'$ TREMOR_PATH="$TREMOR_PATH:${PWD}/transform" tremor run transfor/main.troy\nhello\nHello.\nwhy\nWhy?\n')),(0,o.yg)("h2",{id:"filter"},"Filter"),(0,o.yg)("p",null,"Aside from transformations, filtering is an integral part of what tremor can do to an event. We'll use this feature to allow users to type ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," and have the application stop."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"Stopping tremor is usually not something you'll want to do on a life server as it might impact other users, but it's a nice feature for an example like this.")),(0,o.yg)("h3",{id:"adding-the-exit-connector"},"Adding the ",(0,o.yg)("inlineCode",{parentName:"h3"},"exit")," connector."),(0,o.yg)("p",null,"We use the ",(0,o.yg)("a",{parentName:"p",href:"../reference/connectors/exit"},(0,o.yg)("inlineCode",{parentName:"a"},"exit")," connector"),". This connector will stop the tremor instance on every event it receives."),(0,o.yg)("p",null,"We'll use a different port on the pipeline, the ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," port, and wire this up to the ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," connector."),(0,o.yg)("p",null,"We, however, stop short here from actually filtering just yet."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"We can omit ",(0,o.yg)("inlineCode",{parentName:"p"},"in")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"out")," as ports as that's what tremor defaults to. For ",(0,o.yg)("inlineCode",{parentName:"p"},"exit"),", we have to be more specific.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="main.troy"',title:'"main.troy"'},"# Our main flow\ndefine flow main\nflow\n  # import the `tremor::connectors` module\n  use tremor::connectors;\n  use lib::pipelines;\n\n  # Define the exit connector\n  define connector exit from exit;\n\n  # create the exit connector;\n  create connector exit;\n\n  # create an instance of the console connector\n  create connector console from connectors::console;\n\n  # create an instance of the passthrough pipeline\n  create pipeline main from pipelines::main;\n\n  # connect the console (STDIN) to our pipeline input\n  connect /connector/console to /pipeline/main;\n\n  # then connect the pipeline output to the console (STDOUT)\n  connect /pipeline/main to /connector/console;\n\n  # connect the `exit` port of our pipeline to the exit connector\n  connect /pipeline/main/exit to /connector/exit;\n\nend;\n# Deploy the flow, so tremor starts it\ndeploy flow main;\n")),(0,o.yg)("h3",{id:"filtering-out-exit-messages"},"Filtering out exit messages"),(0,o.yg)("p",null,"The last thing left to do is filter out messages that read ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," and forward them to the ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," port instead of out."),(0,o.yg)("p",null,"We need to add the ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," port to the ",(0,o.yg)("inlineCode",{parentName:"p"},"into")," part of the ",(0,o.yg)("inlineCode",{parentName:"p"},"pipeline")," definition, so it becomes available."),(0,o.yg)("p",null,":::hint\nFor pipelines, we can omit ",(0,o.yg)("inlineCode",{parentName:"p"},"into")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"from"),". If done, it is treated as ",(0,o.yg)("inlineCode",{parentName:"p"},"into out, err")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"from in"),". Replacing one will ",(0,o.yg)("strong",{parentName:"p"},"not add")," to these ports but replace them, so if we want ",(0,o.yg)("inlineCode",{parentName:"p"},"out")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," as ports, we have to write ",(0,o.yg)("inlineCode",{parentName:"p"},"into out, exit"),"."),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"from")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"into")," are independent. Overwriting one does not affect the other.\n:::"),(0,o.yg)("p",null,"Once that is done, we can add the filter logic. To do that, we create a new select statement with a ",(0,o.yg)("inlineCode",{parentName:"p"},'where event == "exit"')," clause that will only forward events that read ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," and add a ",(0,o.yg)("inlineCode",{parentName:"p"},'where event != "exit"')," to our existing clause, forwarding the rest to the punctuate script."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tremor",metastring:'title="lib/pipelines.tremor"',title:'"lib/pipelines.tremor"'},'define pipeline main\n# The exit port is not a default port, so we have to overwrite the built-in port selection\ninto out, exit\npipeline\n  # Use the `std::string` module\n  use std::string;\n  use lib::scripts;\n\n  # Create our script\n  create script punctuate from scripts::punctuate;\n\n  # Filter any event that just is `"exit"` and send it to the exit port\n  select {"graceful": false} from in where event == "exit" into exit;\n\n  # Wire our capitailized text to the script\n  select string::capitalize(event) from in where event != "exit" into punctuate;\n  # Wire our script to the output\n  select event from punctuate into out;\nend;\n')),(0,o.yg)("h3",{id:"running-1"},"Running"),(0,o.yg)("p",null,"That all set, we can run our script as before, just this time, when entering ",(0,o.yg)("inlineCode",{parentName:"p"},"exit")," tremor will terminate."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},'$ TREMOR_PATH="$TREMOR_PATH:${PWD}/filter" tremor run filter/main.troy\nhello\nHello.\nwhy\nWhy?\nexit\n')))}m.isMDXComponent=!0},85680:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/files/main-a20e6bbdb83ec800aea6ea238497dbba.troy"}}]);