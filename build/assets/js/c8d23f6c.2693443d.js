"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[2942],{19216:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>v,frontMatter:()=>a,metadata:()=>o,toc:()=>m});var s=n(58168),r=(n(96540),n(15680));n(40281);const a={},i="Periodic Synthetic Metrics Events",o={unversionedId:"tremor-query/recipes",id:"version-0.11/tremor-query/recipes",title:"Periodic Synthetic Metrics Events",description:"Periodically, produce basic statistics and percentiles / quartiles from a stream of ingested events, for a particular value in the inbound event stream.",source:"@site/versioned_docs/version-0.11/tremor-query/recipes.md",sourceDirName:"tremor-query",slug:"/tremor-query/recipes",permalink:"/docs/0.11/tremor-query/recipes",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/tremor-query/recipes.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"pp",permalink:"/docs/0.11/tremor-query/pp"},next:{title:"Trickle Walkthough",permalink:"/docs/0.11/tremor-query/walkthrough"}},c={},m=[],l={toc:m},u="wrapper";function v(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,s.A)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"periodic-synthetic-metrics-events"},"Periodic Synthetic Metrics Events"),(0,r.yg)("p",null,"Periodically, produce basic statistics and percentiles / quartiles from a stream of ingested events, for a particular value in the inbound event stream."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-trickle"},'# Every 10 seconds\ncreate tumbling window `10secs`\n with\n   interval = datetime::with_seconds(10),\nend;\n\n# Aggregate events producing statistics into a temporary stream\nselect {\n    "measurement": event.measurement,\n    "tags": patch event.tags of insert "window" => "10s" end,\n    "stats": aggr::stats::hdr(event.fields[group[2]], [ "0.42", "0.5", "0.9", "0.99", "0.999" ]),\n    "class": group[2]\n}\nfrom in[`10secs`]\ngroup by set(event.measurement, event.tags, each(record::keys(event.fields)))\ninto normalize\nhaving event.stats.count > 100; # discard if not enough sample data for group\n\n# create a temporary stream to normalize results\ncreate stream normalize;\n\n# normalize output record to match requirements downstream ( influx )\nselect {\n  "measurement":  event.measurement,\n  "tags":  event.tags,\n  "fields":  {\n    "count_#{event.class}":  event.stats.count,\n    "min_#{event.class}":  event.stats.min,\n    "max_#{event.class}":  event.stats.max,\n    "mean_#{event.class}":  event.stats.mean,\n    "stdev_#{event.class}":  event.stats.stdev,\n    "var_#{event.class}":  event.stats.var,\n    "p42_#{event.class}":  event.stats.percentiles["0.42"],\n    "p50_#{event.class}":  event.stats.percentiles["0.5"],\n    "p90_#{event.class}":  event.stats.percentiles["0.9"],\n    "p99_#{event.class}":  event.stats.percentiles["0.99"],\n    "p99.9_#{event.class}":  event.stats.percentiles["0.999"]\n  }\n}\nfrom normalize\ninto out;\n')))}v.isMDXComponent=!0}}]);