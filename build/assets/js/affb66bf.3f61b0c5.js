"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[4382],{91907:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var n=t(58168),o=(t(96540),t(15680));t(40281);const r={},a="chash",i={unversionedId:"reference/stdlib/tremor/chash",id:"version-0.12/reference/stdlib/tremor/chash",title:"chash",description:"The chash module contains functions for consistent hashing of values.",source:"@site/versioned_docs/version-0.12/reference/stdlib/tremor/chash.md",sourceDirName:"reference/stdlib/tremor",slug:"/reference/stdlib/tremor/chash",permalink:"/docs/0.12/reference/stdlib/tremor/chash",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/reference/stdlib/tremor/chash.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"tremor",permalink:"/docs/0.12/reference/stdlib/tremor/"},next:{title:"connectors",permalink:"/docs/0.12/reference/stdlib/tremor/connectors"}},h={},l=[{value:"Functions",id:"functions",level:2},{value:"jump(key, slot_count)",id:"jumpkey-slot_count",level:3},{value:"jump_with_keys(k1, k2, key, slot_count)",id:"jump_with_keysk1-k2-key-slot_count",level:3},{value:"sorted_serialize(any)",id:"sorted_serializeany",level:3}],c={toc:l},u="wrapper";function d(e){let{components:s,...t}=e;return(0,o.yg)(u,(0,n.A)({},c,t,{components:s,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"chash"},"chash"),(0,o.yg)("p",null," The ",(0,o.yg)("inlineCode",{parentName:"p"},"chash")," module contains functions for consistent hashing of values.\nThis can be used to achieve consistent routing over multiple outputs."),(0,o.yg)("h2",{id:"functions"},"Functions"),(0,o.yg)("h3",{id:"jumpkey-slot_count"},"jump(key, slot_count)"),(0,o.yg)("p",null,"Hashes an input key (string) and determine its placement in a slot list."),(0,o.yg)("p",null,"For example It can be used to pick a routing destination using an array of\nhosts:"),(0,o.yg)("blockquote",null,(0,o.yg)("pre",{parentName:"blockquote"},(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},'use tremor::chash;\n let hosts = ["host1", "host2", "host3", "host4", "host5"];\n{\n "key1": hosts[chash::jump("key1", array::len(hosts))],\n "key1_again": hosts[chash::jump("key1", array::len(hosts))],\n "key2": hosts[chash::jump("key2", array::len(hosts))],\n "key3": hosts[chash::jump("key3", array::len(hosts))],\n "key4": hosts[chash::jump("key4", array::len(hosts))],\n}\n'))),(0,o.yg)("p",null,"Returns an ",(0,o.yg)("inlineCode",{parentName:"p"},"integer"),"."),(0,o.yg)("h3",{id:"jump_with_keysk1-k2-key-slot_count"},"jump_with_keys(k1, k2, key, slot_count)"),(0,o.yg)("p",null,"The same as chash::jump but uses the integers k1 and k2 to initialise the\nhashing instead of using default values."),(0,o.yg)("blockquote",null,(0,o.yg)("pre",{parentName:"blockquote"},(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},'use tremor::chash;\n let hosts = ["host1", "host2", "host3", "host4", "host5"];\n{\n "key1": hosts[chash::jump_with_keys(7, 42, "key1", array::len(hosts))],\n "key1_again": hosts[chash::jump_with_keys(7, 42, "key1", array::len(hosts))],\n "key2": hosts[chash::jump_with_keys(7, 42, "key2", array::len(hosts))],\n "key3": hosts[chash::jump_with_keys(7, 42, "key3", array::len(hosts))],\n "key4": hosts[chash::jump_with_keys(7, 42, "key4", array::len(hosts))],\n}\n'))),(0,o.yg)("p",null,"Returns an ",(0,o.yg)("inlineCode",{parentName:"p"},"integer")),(0,o.yg)("h3",{id:"sorted_serializeany"},"sorted_serialize(any)"),(0,o.yg)("p",null,"Serialises the given data in a sorted and repeatable fashion no matter how\ndata is internally stored. In comparison, the normal serialisation functions\ndo not ensure order for performance reasons. Their behaviour is well suited\nfor encoding data on the wire, but in the context of consistent hashing we\nneed to guarantee that data is always encoded to the same serialisation on a\nbyte level not only on the logical level"),(0,o.yg)("blockquote",null,(0,o.yg)("pre",{parentName:"blockquote"},(0,o.yg)("code",{parentName:"pre",className:"language-tremor"},'use tremor::chash;\n{\n  "s1": chash::sorted_serialize("snot"),\n  # Arrays serialize preserving element order\n  "s2": chash::sorted_serialize(["badger", "snot"]),\n  "s3": chash::sorted_serialize(["snot", "badger"]),\n  # Records serialize *normalizing* field element order\n  "s4": chash::sorted_serialize({ "badger": "snot", "snot": "badger"}),\n  "s5": chash::sorted_serialize({ "snot": "badger", "badger": "snot"}),\n}\n'))),(0,o.yg)("p",null,"Returns an ",(0,o.yg)("inlineCode",{parentName:"p"},"string")))}d.isMDXComponent=!0}}]);