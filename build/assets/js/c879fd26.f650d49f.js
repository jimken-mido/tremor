"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[1532],{61863:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var t=r(58168),a=(r(96540),r(15680));r(40281);const o={},i="Linked Transports",s={unversionedId:"operations/linked-transports",id:"version-0.11/operations/linked-transports",title:"Linked Transports",description:"Linked transports are in alpha status as of v0.9.0 and we recommend its use only for exploratory projects. Details around it (including any on this page) are likely to change, as the feature set matures.",source:"@site/versioned_docs/version-0.11/operations/linked-transports.md",sourceDirName:"operations",slug:"/operations/linked-transports",permalink:"/docs/0.11/operations/linked-transports",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.11/operations/linked-transports.md",tags:[],version:"0.11",frontMatter:{},sidebar:"version-0.11/tutorialSidebar",previous:{title:"Circuit Breakers and Guaranteed Delivery",permalink:"/docs/0.11/operations/gdcb"},next:{title:"Monitoring",permalink:"/docs/0.11/operations/monitoring"}},l={},p=[{value:"Basic configuration",id:"basic-configuration",level:2},{value:"Supported ramps",id:"supported-ramps",level:2},{value:"Example use cases",id:"example-use-cases",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Correlation",id:"correlation",level:2},{value:"Future work",id:"future-work",level:2}],c={toc:p},m="wrapper";function d(e){let{components:n,...r}=e;return(0,a.yg)(m,(0,t.A)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"linked-transports"},"Linked Transports"),(0,a.yg)("admonition",{type:"caution"},(0,a.yg)("p",{parentName:"admonition"},"Linked transports are in alpha status as of v0.9.0 and we recommend its use only for exploratory projects. Details around it (including any on this page) are likely to change, as the feature set matures.")),(0,a.yg)("p",null,"Tremor supports ingestion of events from external sources (",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/artefacts/onramps"},"onramps"),") and after processing them from pipelines, they can be written to external sinks (",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/artefacts/offramps"},"offramps"),"). Since v0.9, Tremor also supports Linked Transports (LT): a mechanism that allows linking of source and sink nature into one ramp artefact."),(0,a.yg)("p",null,"In other words -- once this mechanism is turned on -- a Tremor onramp can behave as an ",(0,a.yg)("em",{parentName:"p"},"offramp")," (i.e. send events to the outside world) and similarly, a Tremor offramp can behave as an ",(0,a.yg)("em",{parentName:"p"},"onramp")," (i.e. receive events from the outside world). This is specifically useful for onramps and offramps like REST and websocket, where the protocol already provides facility for responding to events, and as such, the mechanism is currently supported for those onramps and offramps only."),(0,a.yg)("p",null,"With the addition of linked transports and the whole new possibilities for event-flow that comes with it, Tremor has become a platform for implementing a wider variety of applications -- think servers, proxies, bridges etc., and not only ETL-style use cases. Moreover, in combination with other Tremor features and the composability that is Tremor's signature, operators can create richer applications with linked transports at the center -- think loadbalancers, or custom APIs that dynamically change pipeline behaviour (without the need for pipeline redeploy)."),(0,a.yg)("p",null,"This document will describe the feature with concrete examples next, so if the above possibilities seem abstract to you, we hope it will be more clear by the end here."),(0,a.yg)("h2",{id:"basic-configuration"},"Basic configuration"),(0,a.yg)("p",null,"The linked behavior for an onramp or offramp can be turned on by setting the ",(0,a.yg)("inlineCode",{parentName:"p"},"linked")," config param for the artefact to ",(0,a.yg)("inlineCode",{parentName:"p"},"true")," (by default, it's ",(0,a.yg)("inlineCode",{parentName:"p"},"false"),"). A basic Tremor deployment illustrating the feature:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},'onramp:\n  - id: websocket\n    type: ws\n    # turns on linked transport for this ramp\n    linked: true\n    codec: string\n    preprocessors:\n      # events are delimited by new line\n      - lines\n    postprocessors:\n      - lines\n    config:\n      host: localhost\n      port: 8139\n\nbinding:\n  - id: echo\n    links:\n      # send incoming event from a websocket connection to the built-In\n      # passthrough pipeline\n      "/onramp/websocket/{instance}/out":\n        ["/pipeline/system::passthrough/system/in"]\n\n      # and now send back the event from the same websocket connection\n      "/pipeline/system::passthrough/system/out":\n        ["/onramp/websocket/{instance}/in"]\n\nmapping:\n  /binding/echo/01:\n    instance: "01"\n')),(0,a.yg)("p",null,"This instantiates a websocket server that listens to (new-line delimited) events on port 8139. After an event comes through a client websocket connection, it goes to the built-in passthrough pipeline, and is then sent back out to the client from the same connection."),(0,a.yg)("p",null,"We have now in our hands a classic websocket echo server! You can test the functionality with a tool like ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/vi/websocat"},"websocat"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},'# we see the same message echoed back \\o/\n$ echo "hello" | websocat -n1 ws://localhost:8139\nhello\n')),(0,a.yg)("p",null,"The offramp linking works similarly, with the offramp ",(0,a.yg)("inlineCode",{parentName:"p"},"out")," port capturing the event coming back as a reply to the event transmitted to the external sink (examples of this in action are detailed below)."),(0,a.yg)("h2",{id:"supported-ramps"},"Supported ramps"),(0,a.yg)("p",null,"Ramp artefacts that support linked transports are listed here:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/onramps#rest"},"REST Onramp")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/offramps#rest"},"REST Offramp")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/onramps#ws"},"Websocket Onramp")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/onramps#ws"},"Websocket Offramp")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/onramps#discord"},"Discord onramp")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/artefacts/offramps#kv"},"KV offramp"))),(0,a.yg)("p",null,"As part of the above docs, you will also find event metadata variables that these onramps/offramps set (and use), which can be utilized as part of the wider application built using these aretefacts."),(0,a.yg)("h2",{id:"example-use-cases"},"Example use cases"),(0,a.yg)("p",null,"In the above example, instead of using a passthrough pipeline, you can imagine processing the incoming event from a custom trickle pipeline, with the various ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-query/operators"},"operators")," we have at our disposal. In this vein, more elaborate server examples based on onramp linking (and supporting request/response style interactions) are linked below:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/servers_lt_http/"},"HTTP server")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/servers_lt_ws/"},"Websocket server"))),(0,a.yg)("p",null,"When linked onramps of this sort are coupled with linked offramps, we have proxy applications, where incoming requests from clients can be forwarded to upstream servers and the resulting response can then be returned back to the client which initiated the request. Custom proxying logic (eg: deciding the upstream based on incoming request attributes) can be coded up as part of the ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-query/operators#runtimetremor"},"runtime script"),". Some concrete examples demonstrating this pattern:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/proxies_lt_http/"},"HTTP Proxy")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/proxies_lt_ws/"},"Websocket Proxy"))),(0,a.yg)("p",null,'example "Example binding for a HTTP proxy"'),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},'- id: main\n  links:\n    # send incoming requests for processing\n    "/onramp/http/{instance}/out":\n      ["/pipeline/request_processing/{instance}/in"]\n    # process incoming requests and relay it to upstream\n    "/pipeline/request_processing/{instance}/out":\n      ["/offramp/upstream/{instance}/in"]\n    # send the response from upstream for processing\n    # (here be linked offramp)\n    "/offramp/upstream/{instance}/out":\n      ["/pipeline/response_processing/{instance}/in"]\n    # process upstream response and send it back as a response to incoming\n    # (here be linked onramp)\n    "/pipeline/response_processing/{instance}/out":\n      ["/onramp/http/{instance}/in"]\n')),(0,a.yg)("p",null,"And when proxying, if we configure linked onramps and offramps of different types, we have bridges:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/bridges_lt_http_ws/"},"HTTP -> WS Bridge"))),(0,a.yg)("p",null,"Or when the proxying use case is combined with some qos operators (",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-query/operators#qosroundrobin"},"roundrobin")," and ",(0,a.yg)("a",{parentName:"p",href:"/docs/0.11/tremor-query/operators#qosbackpressure"},"backpressure"),"), we get a working load-balancer:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/reverse_proxy_load_balancing/"},"HTTP Load Balancing"))),(0,a.yg)("p",null,"These are some example use cases now possible with linked transports at the center, but with the amount of flexibility and composability that Tremor supports for its various capabilities, we can get very creative with what we can do here -- our imagination is the limit."),(0,a.yg)("p",null,"Examples of even more advanced Tremor applications:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/quota_service/"},"Quota Service")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/docs/0.11/recipes/configurator/"},"Configurator"))),(0,a.yg)("h2",{id:"error-handling"},"Error handling"),(0,a.yg)("p",null,"The above linked examples also demonstrate typical error handling needed for applications built on top of linked transports (eg: for HTTP-based applications, how to send a proper error response to the client with an appropriate status code on tremor-internal failures like runtime script errors, or codec errors on malformed input)."),(0,a.yg)("p",null,'example "Example error-handling binding for a HTTP proxy"'),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-yaml"},'- id: error\n  links:\n    "/onramp/http/{instance}/err":\n      ["/pipeline/internal_error_processing/{instance}/in"]\n    "/pipeline/request_processing/{instance}/err":\n      ["/pipeline/internal_error_processing/{instance}/in"]\n    "/offramp/upstream/{instance}/err":\n      ["/pipeline/internal_error_processing/{instance}/in"]\n    "/pipeline/response_processing/{instance}/err":\n      ["/pipeline/internal_error_processing/{instance}/in"]\n    # send back errors as response as well\n    "/pipeline/internal_error_processing/{instance}/out":\n      ["/onramp/http/{instance}/in"]\n    # respond on errors during error processing too\n    "/pipeline/internal_error_processing/{instance}/err":\n      ["/onramp/http/{instance}/in"]\n')),(0,a.yg)("p",null,"The key here is remembering to link the error ports for all the onramp/offramp/pipeline artefacts involved in the main event-flow, ensuring that the end destination for error events (emitted from the ",(0,a.yg)("inlineCode",{parentName:"p"},"err")," ports) are visible to the client (or user)."),(0,a.yg)("h2",{id:"correlation"},"Correlation"),(0,a.yg)("p",null,"If requests to and responses from a linked transport need to be correlated, the reserved metadata field ",(0,a.yg)("inlineCode",{parentName:"p"},"$correlation")," can be used. It will be forwarded from the request event to the response event, so that some data from the request can be present in the response context."),(0,a.yg)("p",null,"Example pipeline:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-trickle"},'define script correlate\nscript\n  let $correlation = event.correlation_id;\n  let event = patch event of erase "correlation_id" end;\n  event\nend;\n\ncreate script correlate;\n\nselect event from in into correlate;\nselect event from correlate into out;\nselect event from correlate/err into err;\n')),(0,a.yg)("p",null,"This script within the pipeline file above will erase ",(0,a.yg)("inlineCode",{parentName:"p"},"correlation_id")," from the event and put it into the ",(0,a.yg)("inlineCode",{parentName:"p"},"$correlation")," metadata. It will be available in the response pipeline, also as ",(0,a.yg)("inlineCode",{parentName:"p"},"$correlation"),"."),(0,a.yg)("p",null,"If both events need to be fully present and ",(0,a.yg)("inlineCode",{parentName:"p"},"$correlation")," is only used for having a common unique identifier to bring them both together, a windowed select statement with a group by clause can help:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-trickle"},'define tumbling window window_size_2\nwith\n  size = 2\n  # eviction_period = ...\nend;\n\nselect aggr::win::collect_flattened({\n  "event": event,\n  "meta": $\n}) from in[window_size_2] group by $correlation into out;\n')),(0,a.yg)("p",null,"This pipeline will output both request and response as 2-element array:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},'[{"event": {}, "meta": {"correlation": "123456"}}, {"event": {}, "meta": {"correlation": "123456"}}]\n')),(0,a.yg)("h2",{id:"future-work"},"Future work"),(0,a.yg)("p",null,"v0.9.0 introduces linked transports as a feature preview. There are known rough edges and issues with the current mode of configuring linked transports, and also how the richer, linked-transports-powered capabilities interface with rest of Tremor configuration. Some known items for future work, aimed at improving the overall usability:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Improve the LT port linking for onramps/offramps (",(0,a.yg)("inlineCode",{parentName:"li"},"onramp/in")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"offramp/out")," are not natural there)"),(0,a.yg)("li",{parentName:"ul"},"Resolve the boilerplate involved in various aspects of LT use (eg: error handling, pipeline flow, server code)"),(0,a.yg)("li",{parentName:"ul"},"Simplify scatter-gather workflows"),(0,a.yg)("li",{parentName:"ul"},"Guaranteed delivery of events between pipelines"),(0,a.yg)("li",{parentName:"ul"},"Allow certain meta-variables (eg: rate/cardinality) to be set dynamically"),(0,a.yg)("li",{parentName:"ul"},"Better namespacing/sharing for meta-variables")))}d.isMDXComponent=!0}}]);