"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6813],{41778:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var i=t(58168),a=(t(96540),t(15680));const r={},o=void 0,s={unversionedId:"accepted/troy",id:"accepted/troy",title:"troy",description:"- Feature Name: deployment_language",source:"@site/rfc/accepted/0020-troy.md",sourceDirName:"accepted",slug:"/accepted/troy",permalink:"/rfc/accepted/troy",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/rfc/accepted/0020-troy.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{},sidebar:"defaultSidebar",previous:{title:"binary-type",permalink:"/rfc/accepted/binary-type"},next:{title:"Remove Actix",permalink:"/rfc/implemented/remove-actix-from-tremor-runtime"}},l={},p=[{value:"Example",id:"example",level:2},{value:"Artefact definitions",id:"artefact-definitions",level:2},{value:"Connector definitions",id:"connector-definitions",level:3},{value:"Pipeline definitions",id:"pipeline-definitions",level:3},{value:"Flow definitions",id:"flow-definitions",level:3},{value:"Flow Create Statements",id:"flow-create-statements",level:4},{value:"Flow Connect Statements",id:"flow-connect-statements",level:4},{value:"Deploying Flows",id:"deploying-flows",level:3},{value:"Versions we considered and discarded",id:"versions-we-considered-and-discarded",level:2},{value:"Configure Artefacts using Script blocks",id:"configure-artefacts-using-script-blocks",level:2},{value:"Graceful Operations",id:"graceful-operations",level:2},{value:"Non-String Tremor-URLs",id:"non-string-tremor-urls",level:2},{value:"Define Codecs and interceptors (a.k.a pre- and post-processors)",id:"define-codecs-and-interceptors-aka-pre--and-post-processors",level:2},{value:"Syntax sugar for let expressions in with blocks",id:"syntax-sugar-for-let-expressions-in-with-blocks",level:4},{value:"Reference an external trickle file for pipeline definitions",id:"reference-an-external-trickle-file-for-pipeline-definitions",level:4},{value:"Flow Connect Statement Sugar",id:"flow-connect-statement-sugar",level:4},{value:"Top level connect statements",id:"top-level-connect-statements",level:4}],d={toc:p},c="wrapper";function m(e){let{components:n,...t}=e;return(0,a.yg)(c,(0,i.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Feature Name: deployment_language"),(0,a.yg)("li",{parentName:"ul"},"Start Date: 2020-12-15"),(0,a.yg)("li",{parentName:"ul"},"Tremor Issue: ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-runtime/pull/1203"},"tremor-rs/tremor-runtime#1203")),(0,a.yg)("li",{parentName:"ul"},"RFC PR: ",(0,a.yg)("a",{parentName:"li",href:"https://github.com/tremor-rs/tremor-rfcs/pull/0000"},"tremor-rs/tremor-rfcs#0000"))),(0,a.yg)("h1",{id:"summary"},"Summary"),(0,a.yg)("p",null,"Add a deployment language to tremor with which whole event flows, consisting of connectors, pipelines and flows can be defined, instantiated, run and removed again."),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"connector")," is an existing artefact and represents a connection between tremor and an external system."),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"pipeline")," is an existing artefact and is equivalent to a ",(0,a.yg)("inlineCode",{parentName:"p"},"trickle")," query script which compiles to an executable pipeline as defined in the ",(0,a.yg)("inlineCode",{parentName:"p"},"tremor-pipeline")," crate."),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," is a new construct which replaces the concept of a ",(0,a.yg)("inlineCode",{parentName:"p"},"binding")," and a ",(0,a.yg)("inlineCode",{parentName:"p"},"mapping")," in the legacy deployment syntax ",(0,a.yg)("inlineCode",{parentName:"p"},"yaml")," which this RFC is targetted at replacing."),(0,a.yg)("h1",{id:"motivation"},"Motivation"),(0,a.yg)("p",null,"Current deployments are separated into configuration scopes as follows:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"onramps")," - these define legacy ",(0,a.yg)("inlineCode",{parentName:"li"},"onramp")," or ",(0,a.yg)("inlineCode",{parentName:"li"},"source")," connector configurations"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"offramps")," - these define legacy ",(0,a.yg)("inlineCode",{parentName:"li"},"offramp")," or ",(0,a.yg)("inlineCode",{parentName:"li"},"sink")," connector configurations"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"pipeline")," - these are referenced implicitly by name using the file stem ( name minus extension, for a top level pipeline ) passed to the tremor server command line arguments"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"bindings")," - which defines how onramps, offramps and pipelines interconnect"),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"mappings")," - which instanciate and deploy binding.")),(0,a.yg)("p",null,"The YAML format used for deployment configuration is sub-optimal for tremor application authors."),(0,a.yg)("p",null,"With modular tremor scripts, the business logic needed in tremor queries is significantly reduced for well-designed and well-factored tremor streaming applications. With ",(0,a.yg)("a",{parentName:"p",href:"/rfc/implemented/modular-queries"},"modular queries")," entire sub-queries can be modularised and reused allowing the query logic required to compose a query application to be similarly terse."),(0,a.yg)("p",null,"This specification provides the same mechanisms and modularity provisions as the query and script language DSLs for deployments by replacing the YAML syntax with a modular deployment domain specific language to achieve the same hygiene factors with minimal additional syntax."),(0,a.yg)("p",null,"Also, given our experiences with tremor-script and tremor-query, a DSL that is well suited for the task at hand provides significant benefits:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Helpful and consistent hygienic errors that are syntax and semantics aware"),(0,a.yg)("li",{parentName:"ul"},"Modularization of common definitions as reusable modules (e.g. HTTP proxy setup with sources, sinks, pipeline, and interconnecting flows)"),(0,a.yg)("li",{parentName:"ul"},"More expressive - the deployment language embeds the query language, which embeds the scripting language allowing more expressive application authoring."),(0,a.yg)("li",{parentName:"ul"},"Paves the way for a live REPL environment in the future")),(0,a.yg)("p",null,"The primary advantage is a capability to integrate definitions seamlessly and reuse existing language concepts and idioms. Tremor developers and operators get a consistent experience across the suite of languages and avoid distractions inherent in context switching from native DSLs to YAML which requires a higher degree of knowledge of tremor internals than desireable for new users to tremor."),(0,a.yg)("h1",{id:"guide-level-explanation"},"Guide-level explanation"),(0,a.yg)("p",null,"A useful tremor deployment always consists of one or more ",(0,a.yg)("inlineCode",{parentName:"p"},"connectors"),", connected to one or more ",(0,a.yg)("inlineCode",{parentName:"p"},"pipelines"),". These are deployed as a single unit that captures their interconnections and the overall flow of the deployed\napplication logic."),(0,a.yg)("p",null,"The deployment lifecycle for an artefact follows the form:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Publish definition (with all configuration) with a unique artefact id."),(0,a.yg)("li",{parentName:"ul"},"Compute a Tremor URL that uniquely identifies the instance being created."),(0,a.yg)("li",{parentName:"ul"},"Incarnate or launch the instance, if not already running given its url."),(0,a.yg)("li",{parentName:"ul"},"Compute the instance id and url and register the instance accordingly."),(0,a.yg)("li",{parentName:"ul"},"Interconnect ",(0,a.yg)("inlineCode",{parentName:"li"},"connectors")," and ",(0,a.yg)("inlineCode",{parentName:"li"},"pipelines")," required for correct runtime operation.")),(0,a.yg)("p",null,"The shutdown or undeployment sequence follows a similar form:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Pause and disconnect the interlinked artefact instances."),(0,a.yg)("li",{parentName:"ul"},"Stop and remove instances that are no longer referenced ( quiescence )"),(0,a.yg)("li",{parentName:"ul"},"Cascade and sweep remove any artefact instances that are no longer in use."),(0,a.yg)("li",{parentName:"ul"},"Cascade and sweep remove any artefact definitions that are no longer in use.")),(0,a.yg)("p",null,"The Tremor Deployment Language ( ",(0,a.yg)("inlineCode",{parentName:"p"},"troy")," for short ) is the interface with\nthe tremor runtime and guarantees that these control interactions follow\nthe correct sequence of operations."),(0,a.yg)("p",null,"The language aims for sufficient expressivity to define complex deployment patterns, whilst providing a syntax that encourages iterative refinement and\ndevelopment of complex applications from simple working parts."),(0,a.yg)("p",null,"When a troy deployment specification is deployed - the definitions, instances and interconnections are created and launched following the lifecycle patterns summarised above by the runtime."),(0,a.yg)("p",null,"As with ",(0,a.yg)("inlineCode",{parentName:"p"},"trickle"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"troy")," supports modular definition and leverages the same preprocessor ",(0,a.yg)("inlineCode",{parentName:"p"},"mod .. end")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"use")," statements and shares the same module path and loading and module resolution mechanisms."),(0,a.yg)("p",null,"This allows ",(0,a.yg)("inlineCode",{parentName:"p"},"boilerplate")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"reusable")," logic to be shared across multiple\napplication deployments whether deployed in the same tremor instance or otherwise."),(0,a.yg)("h2",{id:"example"},"Example"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'# Defines a connector called `my_http_connector` based on\n# the builtin `http_server` connector\n\ndefine http_server connector my_http_connector\n\n# Specifies required, possibly defaulted, arguments and defines\n# the public interface of the `my_http_connector` user defined\n# connector\n\nargs\n  server = "Tremor/1.2.3",\n\n# Defaults builtin `http_server` connector arguments, potentially\n# referencing interface arguments\n\nwith\n  codec = "json",\n  preprocessors = [ "newline" ],\n  config = {\n    "headers": {\n      "Server": args.server\n    }\n  }\nend;\n\n# Defines a connector called `my_file` based on\n# the builtin `file` connector\n\ndefine file connector my_file\n\n# Has an empty interface specification\n\nwith\n    # Specializes the arguments to the builtin `file` connector\n    config = {\n      "path": "/snot/badger.json"\n    },\n    codec = "json",\n    preprocessors = [ "newline" ]\nend;\n\n# Define a simple passthrough pipeline called `passthrough`\n\ndefine pipeline passthrough\npipeline\n    select event from in into out;\nend;\n\n# Define the `my_flow_application` deployment\n\ndefine flow my_flow_application\nflow\n\n  # This flow will create one instance of `my_http_connector`\n\n  create connector ma_http from my_http_connector\n  with\n    # specializing or overriding the `server` interface argument\n    server = "Tremor/3.2.1"\n  end;\n\n  # This flow will create one instance of `passthrough`\n  create pipeline passthrough;\n\n  # This flow will create one instance of `my_file`\n  create connector my_file;\n\n    # Link instances by id - may reference pre-existing instances known\n    # to the target runtime where this flow is deployed\n    #\n    connect "/connector/my_http_connector/ma_http/out" to "/pipeline/passthrough/passthrough/in";\n\n    # Alternately, may use local identifiers with explicit port assignments\n    connect passthrough/out to my_file/in;\n\n    # Or, local identifiers with defaulted port assignments\n    connect passthrough/out to my_file/in;\nend;\n\n# Finally, instruct the runtime to `deploy` our flow application\ndeploy flow my_app from my_flow_application;\n')),(0,a.yg)("p",null,"For an overview of alternatives we considered and discussed, see ",(0,a.yg)("a",{parentName:"p",href:"#rationale-and-alternatives"},"Rationale and Alternatives")),(0,a.yg)("h1",{id:"reference-level-explanation"},"Reference-level explanation"),(0,a.yg)("p",null,"Troy supports two very basic operations / kinds of statements:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Definition of artefacts with ",(0,a.yg)("inlineCode",{parentName:"li"},"define")," statements"),(0,a.yg)("li",{parentName:"ul"},"Creation of artefact instances with ",(0,a.yg)("inlineCode",{parentName:"li"},"create")," statements"),(0,a.yg)("li",{parentName:"ul"},"Interlinking of instances with ",(0,a.yg)("inlineCode",{parentName:"li"},"connect")," statements"),(0,a.yg)("li",{parentName:"ul"},"Deployment control plane commands with ",(0,a.yg)("inlineCode",{parentName:"li"},"deploy")," statements")),(0,a.yg)("h2",{id:"artefact-definitions"},"Artefact definitions"),(0,a.yg)("p",null,"Definitions of ",(0,a.yg)("inlineCode",{parentName:"p"},"connector"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"pipeline")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," specifications\nare declared using the ",(0,a.yg)("inlineCode",{parentName:"p"},"define")," statement. The BNF for which is\nprovided below"),(0,a.yg)("h3",{id:"connector-definitions"},"Connector definitions"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ebnf"},'connector       = "define" builtin_ref "connector" artefact_id\n                  [ "args" argument_list ]\n                  [ with_block ]?\n                  "end"\nbuiltin_ref     = id      \nartefact_id     = id     \nargument_list   = required_no_default | required_with_default ) [ "," argument_list ]\nrequired_no_default = id\nrequired_with_default = id "=" expr\nwith_block      = "with" assignment_list\nassignment_list = assignment [ "," assignment_list ]\nassignment      = let_path "=" expr\nlet_path        = id [ "." id ]\n')),(0,a.yg)("p",null,"The statement declares a user defined connector definition based on a\nbuiltin connector provided by tremor with a user defined id. A set of\nspecification arguments with required and optionally defaulted parameters\ncan be provided in the ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," clause. A set of configuration parameters\nrequired by the builtin connector from which the user defined connector\nis being created is provided with the ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," clause."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," specification is the users parameterization of the user defined\nconnector. It declares the intended interface to users of the connector."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," specification provides required configuration to the underlying\nbuiltin tremor connector."),(0,a.yg)("p",null,"Defaulted arguments provided in the ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," block can be used in the ",(0,a.yg)("inlineCode",{parentName:"p"},"with"),"\nblock. The values are any valid ",(0,a.yg)("inlineCode",{parentName:"p"},"tremor-script")," expression that ordinarily\nreturns a value. So ",(0,a.yg)("inlineCode",{parentName:"p"},"match")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"patch")," statements or ",(0,a.yg)("inlineCode",{parentName:"p"},"for")," comprehensions\ncan be used for values, or literals. But the ",(0,a.yg)("inlineCode",{parentName:"p"},"emit")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"drop")," expressions\nwhich ordinarily halt event flow cannot."),(0,a.yg)("p",null,"Whitespace and newlines are not significant in the BNF grammar."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define http connector my_http\n\n# Specifies the `my_http` user defined connector interface\nargs\n    required_argument,\n    optional_arg_with_default = "default value"\n\n# Provides essential configuration to the intrinsic or builtin\n# `http` connector on top of which `my_http` is defined.\nwith\n    codec = "json",\n    preprocessors = [ \n        {\n            "type": "split",\n            "config": {\n                "split_by": "\\n"\n            }\n        },\n        "base64"\n    ],\n    config = {\n      "host": "localhost",\n      "port": args.required_argument, # TODO verify\n    },\n    err_required = args.optional_arg_with_default\nend;\n')),(0,a.yg)("h3",{id:"pipeline-definitions"},"Pipeline definitions"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ebnf"},'pipeline             = "define" "pipeline" artefact_id\n                       [ "args" argument_list ]\n                       "pipeline" pipeline\n                       "end"\nartefact_id           = id     \nargument_list         = required_no_default | required_with_default ) [ "," argument_list ]\nrequired_no_default   = id\nrequired_with_default = id "=" expr\npipeline              = <tremor-pipeline>\n')),(0,a.yg)("p",null,"The statement declares a user defined pipeline definition based on a\nuser defined inline tremor query and bound to a user defined id.\nA set of specification arguments with required and optionally defaulted parameters can be provided in the ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," clause."),(0,a.yg)("p",null,"This statement does not support a ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," clause as there are no intrinsic\nartefacts being extended or parameterised by this type of definition."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," specification is the users parameterization of the user defined\npipeline. It declares the intended interface to users of the pipeline."),(0,a.yg)("p",null,"Whitespace and newlines are not significant in the BNF grammar."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define pipeline my_pipeline\n# Specifies the `my_http` user defined connector interface\nargs\n    required_argument,\n    optional_arg_with_default = "default value"\npipeline\n    # An inline tremor query ( trickle ) script\n    use std::datetime;\n    define tumbling window fifteen_secs\n    with\n        interval = datetime::with_seconds(args.required_argument),\n    end;\n\n    select { "count": aggr::stats::count(event) } from in[fifteen_secs] into out having event.count > 0;\nend;\n')),(0,a.yg)("h3",{id:"flow-definitions"},"Flow definitions"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ebnf"},'connector       = "define" "flow" artefact_id\n                  [ "args" argument_list ]\n                  "flow" flow_stmts\n                  "end"\nartefact_id     = id     \nargument_list   = required_no_default | required_with_default ) [ "," argument_list ]\nrequired_no_default = id\nrequired_with_default = id "=" expr\nflow_stmts            = flow_stmt [ ";" flow_stmts ]*\nflow_stmt             = flow_create | flow_connect\nflow_create           = "create" create_kind instance_id "from" modular_target [ with_block ]? "end"\ncreate_kind           = "connector" | "pipeline"\ninstance_id           = id\nmodular_target        = [ id "::" ]* id\nwith_block            = "with" assignment_list\nassignment_list       = assignment [ "," assignment_list ]\nassignment            = let_path "=" expr\nlet_path              = id [ "." id ]\nflow_connect          = "connect" connect_endpoint "to" connect_endpoint\nconnect_endpoint      = system_endpoint | troy_endpoint\nsystem_endpoint       = <stringified-url>\ntroy_endpoint         = id [ "/" port_id ]?\nport_id               = id\n')),(0,a.yg)("p",null,"The statement declares a user defined flow specification. Flow specifications replace the ",(0,a.yg)("inlineCode",{parentName:"p"},"binding")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"mapping")," constructs in the legacy YAML syntax. In\nthe legacy syntax the ",(0,a.yg)("inlineCode",{parentName:"p"},"binding")," section specified how artefacts linked with each other to form a flow graph, and the ",(0,a.yg)("inlineCode",{parentName:"p"},"mapping")," section specified how instances of the referenced artefacts were created at runtime."),(0,a.yg)("p",null,"Both were required to define a useful event flow graph at runtime. Production users of tremor who have been with the project from the beginning have outgrown these primitives as they are now building significant, complex, non-trivial streaming applications on top of tremor."),(0,a.yg)("p",null,"The YAML syntax is not modular and outside of simpler deployments the separation of instance management and interlinking doesn't work well for larger applications based on tremor."),(0,a.yg)("p",null,"Medium to large streaming applications were niche 18 months ago. They are\nnormal today."),(0,a.yg)("p",null,"A set of specification arguments with required and optionally defaulted parameters can be provided in the ",(0,a.yg)("inlineCode",{parentName:"p"},"args")," clause."),(0,a.yg)("p",null,"Flow specifications unify the creation of artefact instances and their interlinking in a hygienic fashion with potential to enhance the model in future by allowing sub flows to be defined, interlinked and instanciated in future revisions of troy."),(0,a.yg)("p",null,"Whitespace and newlines are not significant in the BNF grammar."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define flow my_eventflow\nargs\n    required_arg,\n    optional_arg = "default value"\nflow\n    # Create instances required by this flow specification\n    create connector my_source from my_http_connector;\n    create pipeline my_pipeline from passthrough\n    with\n      required_argument = 15 # 15 second aggregation interfals\n    end;\n    create connector my_sink from my_file;\n\n    # Interlink instances\n    connect "tremor://connector/my_source/{required_arg}/out" to \n    my_pipeline:in;\n    connect my_pipeline:out to my_sink:in;\nend;\n')),(0,a.yg)("h4",{id:"flow-create-statements"},"Flow Create Statements"),(0,a.yg)("p",null,"Every artefact that has a definition via ",(0,a.yg)("inlineCode",{parentName:"p"},"define")," that is in scope in a flow\nspecification can be created, optionally passing parameters using a ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," clause:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF Grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bnf"},'create          = "create"  flow_id "from" modular_target\n                  [ "with" assignment_list ]\n                  "end"\nflow_id         = id\nmodular_target  = [ id "::" ]* id\nassignment_list = assignment [ "," assignment_list ]\nassignment      = let_path "=" expr\nlet_path        = id [ "." id ]\n')),(0,a.yg)("p",null,"The instance_id provided in the definition coupled with the computed modular scope of the flow definition it is created within and the troy file it is created from are used to create the internal representation."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"create")," statement can be used with ",(0,a.yg)("inlineCode",{parentName:"p"},"connector")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"pipeline")," definitions but not ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," definitions in this iteration of the troy language."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Example:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"create pipeline my_pipeline from passthrough\nwith\n  required_argument = 15 # 15 second aggregation interfals\nend;\n")),(0,a.yg)("h4",{id:"flow-connect-statements"},"Flow Connect Statements"),(0,a.yg)("p",null,"Flow ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," statements allow artefact instances created in the same flow to be interlinked or artefacts that from a tremor deployment that are already deployed to be interlinked with a flow."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF Grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bnf"},'flow_connect          = "connect" connect_endpoint "to" connect_endpoint\nconnect_endpoint      = system_endpoint | troy_endpoint\nsystem_endpoint       = <stringified-url>\ntroy_endpoint         = id [ "/" port_id ]?\nport_id               = id\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," statement links artefact instance specifications. A ",(0,a.yg)("inlineCode",{parentName:"p"},"from")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"to")," endpoint is required. Both the ",(0,a.yg)("inlineCode",{parentName:"p"},"from")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"to")," endpoints need to resolve to either pre-existing instances already running in termor, or instances that are defined in the context of the flow definition they are defined within."),(0,a.yg)("p",null,"There are two basic forms of endpoint:"),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Troy Native Connect Flow Form")),(0,a.yg)("p",null,"This form uses the creation id's from the flow specification to create a reference to the target instance. If no port specification is provided then the default ",(0,a.yg)("inlineCode",{parentName:"p"},"in")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"out")," ports are inferred automatically."),(0,a.yg)("p",null,"The short form:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"connect passthrough to my_pipeline\n")),(0,a.yg)("p",null,"Is equivalent to the longer form:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"connect passthrough/out to my_pipeline/in\n")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Runtime Flow Connect Form:")),(0,a.yg)("p",null,"The alternative form can be used to link with artefact instances that are defined external to the flow specification that is currently in context."),(0,a.yg)("p",null,"For example, we can connect to the tremor runtime provided default passthrough flow pipeline as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'connect my_http_connector/out to "/pipeline/system::passthrough/system/in"\n')),(0,a.yg)("h3",{id:"deploying-flows"},"Deploying Flows"),(0,a.yg)("p",null,"Flow definitions are a specification. They define how artefacts interconnect and they specify instances to be created if required. They can also reference\npre-existing instances via their tremor URLs."),(0,a.yg)("p",null,"To deploy a flow into the tremor runtime and start, run and active any\nconnectors, pipelines and flow graph connections defined in a flow we must\nuse the ",(0,a.yg)("inlineCode",{parentName:"p"},"deploy")," statement."),(0,a.yg)("p",null,"A unit of deployment in ",(0,a.yg)("inlineCode",{parentName:"p"},"troy")," is a flow specification."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"EBNF Grammar:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bnf"},'create          = "deploy"  deployment_id "from" modular_target\n                  [ "with" assignment_list ]\n                  "end"\ndeployment_id   = id\nmodular_target  = [ id "::" ]* id\nassignment_list = assignment [ "," assignment_list ]\nassignment      = let_path "=" expr\nlet_path        = id [ "." id ]\n\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"deploy")," statement references a ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," to be deployed using\nthe ",(0,a.yg)("inlineCode",{parentName:"p"},"from")," clause and may use a ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," clause to override the\ndefault flow configuration specified for that flow, if required."),(0,a.yg)("h1",{id:"drawbacks"},"Drawbacks"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"YAML is widely known especially within cloud-native environments.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Troy is new DSL in tremor, but it builds on the same mechanisms as the query and script DSLs and leverages the same namspace and modularity mechanisms")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Introducing a new DSL steepens the learning curve for new tremor users."))),(0,a.yg)("h1",{id:"rationale-and-alternatives"},"Rationale and alternatives"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The query language ",(0,a.yg)("inlineCode",{parentName:"p"},"trickle")," was once defined in YAML. The query language\nwas designed to provide a better user experience, hygienic easy to interpret error reporting and a syntax and semantics that was designed to\nmeet the needs of tremor continuous streaming query authors.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"By embedding the ",(0,a.yg)("inlineCode",{parentName:"p"},"tremor")," script language via the query ",(0,a.yg)("inlineCode",{parentName:"p"},"script")," operator\nthe unification reduced the deployment and operational complexity and led\nto easier to develop queries.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"By following the same proven and well-trodden path with ",(0,a.yg)("inlineCode",{parentName:"p"},"troy"),", and building on the idioms and conventions introduced with ",(0,a.yg)("inlineCode",{parentName:"p"},"trickle")," this\nshould hold true for ",(0,a.yg)("inlineCode",{parentName:"p"},"troy"),". Early indications from tremor production users is that it is a significant improvement over the YAML based deployment model.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Lastly, removing the remaining YAML serialization, deserialization and supporting code from tremor runtime enables refactoring of complex internals that are far-reaching and affect rust-lifetimes and other performance critical or user facing parts of tremor that haven't evolved since the earliest version of tremor when YAML was introduced to tremor as a stop-gap solution at the very beginning of the project."))),(0,a.yg)("h2",{id:"versions-we-considered-and-discarded"},"Versions we considered and discarded"),(0,a.yg)("p",null,"One initial draft contained ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," as a keyword for starting a key-value mapping (a record in tremor-script)\nas a special case only used in configuration contexts:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define connector artefact ws_conn\nwith\n  type = ws,\n  # nested record\n  config with\n    host = "localhost",\n    port = 8080\n  end,\n  codec = my_json with ... end\n  interceptors = ...\nend;\n')),(0,a.yg)("p",null,"This was discarded because ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," as a keyword doesn't really work as keyword for a key-value mapping. To be consistent with tremor-script, it should be ",(0,a.yg)("inlineCode",{parentName:"p"},"record"),"."),(0,a.yg)("p",null,"The first name for ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," was ",(0,a.yg)("inlineCode",{parentName:"p"},"deployment")," but it was an oversimplification. In a ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," we specify the required artefact instances and interlinking. So ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," is better suited and the design is richer and more expressive than the constrained syntax offered by\nthe YAML based ",(0,a.yg)("inlineCode",{parentName:"p"},"binding")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"mapping")," configuration scopes."),(0,a.yg)("p",null,"Also, separating the runtime commands such as ",(0,a.yg)("inlineCode",{parentName:"p"},"deploy")," from the specifications to be deployed or that are subject to lifecycle management\ninteractions was quickly established as a requirement when brainstorming the structure and semantics of the language and comparing it with\nproduction use cases where the needs are very well understood."),(0,a.yg)("h1",{id:"prior-art"},"Prior art"),(0,a.yg)("p",null,"Environments like ",(0,a.yg)("inlineCode",{parentName:"p"},"terraform")," from ",(0,a.yg)("inlineCode",{parentName:"p"},"HashiCorp")," are a good example of resource or state management in the form of configuration as code\nand the scheduler and tooling that moves a runtime from one planned state to another. In ",(0,a.yg)("inlineCode",{parentName:"p"},"troy")," we separate out ",(0,a.yg)("inlineCode",{parentName:"p"},"definitions")," or specifications from ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," - which captures the runtime model and interlinking from deployment commands such as ",(0,a.yg)("inlineCode",{parentName:"p"},"deploy")," which are commands\nto the runtime to execute a change to deploye state."),(0,a.yg)("p",null,"Another environment worth exploring is the Erlang REPL. Erlang is unique as a language and runtime in that the REPL can be used to\nnavigate, explore and alter the running state of a live clustered deployemnt. In contrast to the ",(0,a.yg)("inlineCode",{parentName:"p"},"terraform")," model, in Erlang and\nother actor-based or inspired systems the runtime topology can be modified live."),(0,a.yg)("p",null,"Both are useful models that inspired and influenced the evolution of ",(0,a.yg)("inlineCode",{parentName:"p"},"troy")," as documented in this RFC."),(0,a.yg)("h1",{id:"unresolved-questions"},"Unresolved questions"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Should we use Tremor URLs in ",(0,a.yg)("inlineCode",{parentName:"p"},"create")," statements?\nDisposition: The simpler ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," model is seen as sufficient at this time.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Should we add means to refer to artefacts by their attributes (host, artefact-type, artefact-id, configuration , module path)?\nDisposition: There are no use cases that we know of that would benefit from this flexibility at this time.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Should we allow users to create dormant, non-deployed and non-referenced artefacts or instances?\nDisposition: Whilst powerful, this is not seen a need at this time, and tradeoffs would need to be carefully considered."))),(0,a.yg)("h1",{id:"future-possibilities"},"Future possibilities"),(0,a.yg)("h2",{id:"configure-artefacts-using-script-blocks"},"Configure Artefacts using Script blocks"),(0,a.yg)("p",null,"Given the plan is to implement the with block as syntax sugar around a tremor-script block with a ",(0,a.yg)("inlineCode",{parentName:"p"},"multi-let")," expression, we could enable the feature to use a more complex script block to define the configuration record. E.g. if we need to dispatch on som arguments and chose different config entries based on that, this would not be possible using a ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," block."),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define file connector my_file_connector\nargs \n    dispatch_arg = "default"\nscript\n    match dispatch_arg of\n        case "snot" => {"snot": true, "arg": dispatch_arg}\n        case "badger" => {"badger": true, "arg": dispatch_arg}\n        default => {"default": true}\n    end\nend\n')),(0,a.yg)("h2",{id:"graceful-operations"},"Graceful Operations"),(0,a.yg)("p",null,"We could add statement variants for create that fail if an instance with the same id already exists or that gracefully do nothing if that is the case. This graceful behavior needs to be able to verify that the existing instance is from the very same artefact, and for this might be checking the artefact content too, not just its name."),(0,a.yg)("h2",{id:"non-string-tremor-urls"},"Non-String Tremor-URLs"),(0,a.yg)("p",null,"It would be nice for static analysis of troy scripts to have tremor urls in connect statements to not be strings,\nbut to have them use ids as references to defined artefacts or already created artefact instances. string urls allow references\noutside the context of the current troy script though, which might or might not be valid based on the state of the registry at the point of creation. So maybe, an id based syntax for tremor-urls might help with error detection in troy scripts but would only work when referencing artefacts and instances is limited to the current troy script (including imports)."),(0,a.yg)("p",null,"Some ideas to spawn discussion:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"pipeline:my_pipeline/instance_id:in\n")),(0,a.yg)("p",null,"If we change the requirement for artefact ids to be globally unique, not only per artefact type, we wouldnt even need to prefix them with their artefact type every time:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"my_pipeline/instance_id:in\n")),(0,a.yg)("h2",{id:"define-codecs-and-interceptors-aka-pre--and-post-processors"},"Define Codecs and interceptors (a.k.a pre- and post-processors)"),(0,a.yg)("p",null,"It might be nice to be able to define codecs and interceptors as well in the deployment language.\nThat will mean:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"builtin codecs and interceptors are predefined in something like a Troy stdlib:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"intrinsic codec json;\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"codecs and interceptors can be provided with configuration and be referencable under a unique name.")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"define codec pretty_json from json\nwith\n    pretty = true,\n    indent = 4,\nend;\n")),(0,a.yg)("p",null,"This will solve the current problem that ",(0,a.yg)("inlineCode",{parentName:"p"},"pre-")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"postprocessors")," are not configurable.\nIt will nonetheless introduce another type of ",(0,a.yg)("inlineCode",{parentName:"p"},"artefact")," that actually isnt a proper artefact, and so applying the language concepts to it might not fully work out and lead to confusion."),(0,a.yg)("p",null,"Also it is not possible to fully define codecs and interceptors inside troy. They are all written in rust for performance reasons. The only thing we can do is to configure them and associate a codec/interceptor with its configuration and make this pair referencable within the language."),(0,a.yg)("p",null,"Think about what the natural extension and evolution of your proposal would\nbe and how it would affect Tremor as a whole in a holistic way. Try to use\nthis section as a tool to more fully consider all possible interactions with the\nproject in your proposal. Also consider how the this all fits into the roadmap for\nthe project and of the relevant sub-team."),(0,a.yg)("p",null,'This is also a good place to "dump ideas", if they are out of scope for the\nRFC you are writing but otherwise related.'),(0,a.yg)("p",null,"If you have tried and cannot think of any future possibilities,\nyou may simply state that you cannot think of anything."),(0,a.yg)("p",null,"Note that having something written down in the future-possibilities section\nis not a reason to accept the current or a future RFC; such notes should be\nin the section on motivation or rationale in this or subsequent RFCs.\nThe section merely provides additional information."),(0,a.yg)("h1",{id:"errata"},"Errata"),(0,a.yg)("h4",{id:"syntax-sugar-for-let-expressions-in-with-blocks"},"Syntax sugar for let expressions in with blocks"),(0,a.yg)("p",null,"In order to make defining config entries in tremor-script convenient, we introduced the ",(0,a.yg)("inlineCode",{parentName:"p"},"with")," block. We need to add a few features to tremor-script to make this work reasonably well in a configuration context, where all we want is to return a record value without too much fuss and ceremony:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Add multi-let statements, that combine multiple ",(0,a.yg)("inlineCode",{parentName:"p"},"let"),"s inside a single statement whcih defined the variables therein and returns a record value with all those definitions.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"Add auto-creation of intermediary path segments in let stetements:"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre"},"let config.nested.value = 1;\n")),(0,a.yg)("p",{parentName:"li"},"In this case if ",(0,a.yg)("inlineCode",{parentName:"p"},"config.nested")," does not exist we would auto-create it as part of this let as an empty record. This statement would fail, if we would try to ",(0,a.yg)("em",{parentName:"p"},"nest")," into an existing field that is not a record."))),(0,a.yg)("h4",{id:"reference-an-external-trickle-file-for-pipeline-definitions"},"Reference an external trickle file for pipeline definitions"),(0,a.yg)("p",null,"It might be interesting to be able to load a trickle query from a trickle file. To that end we add new config directives to trickle that can define arguments and their default values."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-trickle"},'#!config arg my_arg = "foo"\n#!config arg required_arg\n...\n')),(0,a.yg)("h4",{id:"flow-connect-statement-sugar"},"Flow Connect Statement Sugar"),(0,a.yg)("p",null,"Connect statements describe the very primitive operation needed to establish an event flow from sources/connectors via pipelines towards sinks/connectors. Defining each single connection manually might be a bit too verbose. That is why we will provide some more convenient versions that basically all encode ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," statements, but are much more concise and expressive."),(0,a.yg)("p",null,"We call them ",(0,a.yg)("inlineCode",{parentName:"p"},"arrow")," statements. Both the LHS and the RHS are Tremor URL string. The LHS of a simple ",(0,a.yg)("inlineCode",{parentName:"p"},"arrow"),' statement is the "sender" of events, the RHS is the "receiver". The direction of the arrow describes the flow direction. If no port is provided, the LHS uses the ',(0,a.yg)("inlineCode",{parentName:"p"},"out")," port, the RHS uses the ",(0,a.yg)("inlineCode",{parentName:"p"},"in")," port, so users dont need to specify them in the normal case."),(0,a.yg)("p",null,"Examples:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'# without ports\n"/source/stdin" -> "/pipeline/pipe";\n"/pipeline/pipe/err" -> "/sink/system::stderr";\n\n# with ports\n"/pipeline/pipe:err" -> "/sink/my_error_file:in";\n')),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"Arrow")," statements also support chaining. This works as follows: As ",(0,a.yg)("inlineCode",{parentName:"p"},"arrow")," statements when used as expression, will expose its RHS if used as LHS and its LHS if it is used as RHS. The arrow statements handle other arrow statements as LHS and RHS separately. In effect chaining ",(0,a.yg)("inlineCode",{parentName:"p"},"arrow")," statements is just writing multiple TremorURLs connected via ",(0,a.yg)("inlineCode",{parentName:"p"},"arrows"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'"/source/system::stdin" -> "/pipeline/system::passthrough" -> "/sink/system::stderr";\n')),(0,a.yg)("p",null,"This is equivalent to the following, when adding explicit parens to show precedence:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'("/source/system::stdin/out" -> "/pipeline/system::passthrough/in") -> "/sink/system::stderr/in";\n')),(0,a.yg)("p",null,"Which resolves via desugaring:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'connect "/source/system::stdin/out" to "/pipeline/system::passthrough/in";\nconnect "/pipeline/system::passthrough/out" to "/sink/system::stderr/in";\n')),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"Arrow")," statements also support tuples of Tremor URLs or tuples of other ",(0,a.yg)("inlineCode",{parentName:"p"},"Arrow")," statements. These describe branching and joining\nat the troy level."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'"/source/system::stdin/out" -> ("/pipeline/system::passthrough", "/pipeline/my_pipe" ) -> "/sink/system::stderr/in";\n')),(0,a.yg)("p",null,"This desugars to:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'"/source/system::stdin/out" -> "/pipeline/system::passthrough" -> "/sink/system::stderr/in";\n"/source/system::stdin/out" -> "/pipeline/my_pipe" -> "/sink/system::stderr/in";\n')),(0,a.yg)("p",null,"If we have multiple tuples within a statement, we create statements for each combination of them. Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'# full sugar\n("/source/my_file", "/source/my_other_file") -> ("/pipeline/pipe1", "/pipeline/pipe2") -> "/sink/system::stderr";\n\n# desugars to:\n\n"/source/my_file" -> "/pipeline/pipe1" -> "/sink/system::stderr";\n"/source/my_file" -> "/pipeline/pipe2" -> "/sink/system::stderr";\n"/source/my_other_file" -> "/pipeline/pipe1" -> "/sink/system::stderr";\n"/source/my_other_file" -> "/pipeline/pipe2" -> "/sink/system::stderr";\n')),(0,a.yg)("p",null,"The immediate win in terseness is obvious, we hope."),(0,a.yg)("p",null,"It will be very interesting to explore how to expose the same sugar to trickle select queries. This is a future possibility."),(0,a.yg)("h4",{id:"top-level-connect-statements"},"Top level connect statements"),(0,a.yg)("p",null,"Connect statements have been introduced as part of ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," definitions. It will greatly simplify setting up tremor installations if we could write them at the top level of a troy script."),(0,a.yg)("p",null,"The process of describing a tremor deployment would then consist conceptually of the following steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"define artefacts to be connected"),(0,a.yg)("li",{parentName:"ol"},"connect those artefacts")),(0,a.yg)("p",null,"These steps describe a good intuition about setting up a graph of nodes for events to flow through."),(0,a.yg)("p",null,"Example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'define file connector my-file-connector\nwith\n  source = "/my-file.json",\n  codec = "json"\nend;\n\nconnect "/connector/my-file-connector/out" to "/pipeline/system::passthrough/in";\nconnect "/pipeline/system::passthrough/out" to "/connector/system::stderr/in";\n')),(0,a.yg)("p",null,"For setting up tremor with this script, the conecpt of a ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," doesnt event need to be introduced. Escpecially for getting started and\ntrying out simple setups in a local dev environment or for tutorials and workshops, this removes friction and descreases ",(0,a.yg)("inlineCode",{parentName:"p"},"time-to-get-something-running-and-have-fun-understanding"),"."),(0,a.yg)("p",null,"What is going on under the hood here to make this work?"),(0,a.yg)("p",null,"Those connect statements will be put into a synthetic ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," artefact with the artefact id being the file in which they are declared. There is exactly one such synthetic ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," artefact for a troy file, but only if at least 1 globale ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," statement is given. The ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," instance id will be ",(0,a.yg)("inlineCode",{parentName:"p"},"default"),".\nThis ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," artefact is defined and created without args upon deployment of the troy script file."),(0,a.yg)("p",null,"Following this route it sounds reasonable to also add ",(0,a.yg)("inlineCode",{parentName:"p"},"disconnect")," statements as the dual of ",(0,a.yg)("inlineCode",{parentName:"p"},"connect"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'disconnect "/connector/my-file-connector/out" from "/pipeline/system::passthrough/in";\n')),(0,a.yg)("p",null,"With ",(0,a.yg)("inlineCode",{parentName:"p"},"flows")," we would destroy the whole ",(0,a.yg)("inlineCode",{parentName:"p"},"flow")," instance to delete the connections therein at once. With top level ",(0,a.yg)("inlineCode",{parentName:"p"},"connect")," statements,\nwe cannot reference any such instance, unless we reference it using the naming scheme above. But we would lose the power to modify single connections if we'd refrain from looking into ",(0,a.yg)("inlineCode",{parentName:"p"},"disconnect"),"."))}m.isMDXComponent=!0}}]);