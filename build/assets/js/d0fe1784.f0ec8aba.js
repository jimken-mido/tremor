"use strict";(self.webpackChunktremor_website=self.webpackChunktremor_website||[]).push([[6352],{53309:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>u,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>m});var r=t(58168),l=(t(96540),t(15680));t(40281);const o={},u=void 0,i={unversionedId:"language/reference/EBNF",id:"version-0.12/language/reference/EBNF",title:"EBNF",description:"EBNF Grammar",source:"@site/versioned_docs/version-0.12/language/reference/EBNF.md",sourceDirName:"language/reference",slug:"/language/reference/EBNF",permalink:"/docs/0.12/language/reference/EBNF",draft:!1,editUrl:"https://github.com/tremor-rs/tremor-www/tree/main/versioned_docs/version-0.12/language/reference/EBNF.md",tags:[],version:"0.12",frontMatter:{},sidebar:"indexSidebar",previous:{title:"Grammar",permalink:"/docs/0.12/language/reference/"},next:{title:"Deploy Grammar",permalink:"/docs/0.12/language/reference/deploy"}},a={},m=[{value:"EBNF Grammar",id:"ebnf-grammar",level:2}],p={toc:m},s="wrapper";function d(n){let{components:e,...t}=n;return(0,l.yg)(s,(0,r.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,l.yg)("h2",{id:"ebnf-grammar"},"EBNF Grammar"),(0,l.yg)("p",null,'This EBNF grammar was generated from: "/home/mat/dev/tremor/tremor-www/tremor-runtime/tremor-script/src/grammar.lalrpop"'),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-ebnf"},"\n\nrule ModuleFile ::=\n    ModuleBody \n  ;\n\nrule ModuleBody ::=\n    ( ModComment ) ?  ModuleStmts \n  ;\n\nrule ModComment ::=\n     '<mod-comment>' \n  | ModComment  '<mod-comment>' \n  ;\n\nrule DocComment ::=\n     '<doc-comment>' \n  | DocComment  '<doc-comment>' \n  ;\n\nrule ModuleStmts ::=\n    ModuleStmt  ';' ModuleStmts \n  | ModuleStmt  ';' ?  \n  ;\n\nrule ModuleStmt ::=\n    Use \n  | Const \n  | FnDefn \n  | Intrinsic \n  | DefineWindow \n  | DefineOperator \n  | DefineScript \n  | DefinePipeline \n  | DefineConnector \n  | DefineFlow \n  ;\n\nrule ConfigDirectives ::=\n    ConfigDirective ConfigDirectives \n  | ConfigDirective \n  ;\n\nrule ConfigDirective ::=\n     '#!config' WithExpr \n  ;\n\nrule Use ::=\n     'use' ModularTarget \n  |  'use' ModularTarget  'as' Ident \n  ;\n\nrule ArgsWithEnd ::=\n    ArgsClause ?  WithEndClause \n  | \n  ;\n\nrule DefinitionArgs ::=\n    ArgsClause ?  \n  ;\n\nrule ArgsClause ::=\n     'args' ArgsExprs \n  ;\n\nrule ArgsExprs ::=\n    Sep!(ArgsExprs, ArgsExpr, \",\") \n  ;\n\nrule ArgsExpr ::=\n    Ident  '=' ExprImut \n  | Ident \n  ;\n\nrule CreationWithEnd ::=\n    WithEndClause \n  | \n  ;\n\nrule CreationWith ::=\n    WithClause \n  | \n  ;\n\nrule WithClause ::=\n     'with' WithExprs \n  ;\n\nrule WithEndClause ::=\n    WithClause  'end' \n  ;\n\nrule WithExprs ::=\n    Sep!(WithExprs, WithExpr, \",\") \n  ;\n\nrule WithExpr ::=\n    Ident  '=' ExprImut \n  ;\n\nrule ModularTarget ::=\n    Ident \n  | ModPath  '::' Ident \n  ;\n\nrule Deploy ::=\n    ConfigDirectives ( ModComment ) ?  DeployStmts \n  | ( ModComment ) ?  DeployStmts \n  ;\n\nrule DeployStmts ::=\n    DeployStmt  ';' DeployStmts \n  | DeployStmt  ';' ?  \n  ;\n\nrule DeployStmt ::=\n    DefineFlow \n  | DeployFlowStmt \n  | Use \n  ;\n\nrule DeployFlowStmt ::=\n    ( DocComment ) ?   'deploy'  'flow' Ident  'from' ModularTarget CreationWithEnd \n  | ( DocComment ) ?   'deploy'  'flow' Ident CreationWithEnd \n  ;\n\nrule ConnectorKind ::=\n    Ident \n  ;\n\nrule FlowStmts ::=\n    FlowStmts_ \n  ;\n\nrule FlowStmts_ ::=\n    Sep!(FlowStmts_, FlowStmtInner, \";\") \n  ;\n\nrule CreateKind ::=\n     'connector' \n  |  'pipeline' \n  ;\n\nrule FlowStmtInner ::=\n    Define \n  | Create \n  | Connect \n  | Use \n  ;\n\nrule Define ::=\n    DefinePipeline \n  | DefineConnector \n  ;\n\nrule Create ::=\n     'create' CreateKind Ident  'from' ModularTarget CreationWithEnd \n  |  'create' CreateKind Ident CreationWithEnd \n  ;\n\nrule Connect ::=\n     'connect'  '/' ConnectFromConnector  'to'  '/' ConnectToPipeline \n  |  'connect'  '/' ConnectFromPipeline  'to'  '/' ConnectToConnector \n  |  'connect'  '/' ConnectFromPipeline  'to'  '/' ConnectToPipeline \n  ;\n\nrule ConnectFromConnector ::=\n     'connector'  '/' Ident MaybePort \n  ;\n\nrule ConnectFromPipeline ::=\n     'pipeline'  '/' Ident MaybePort \n  ;\n\nrule ConnectToPipeline ::=\n     'pipeline'  '/' Ident MaybePort \n  ;\n\nrule ConnectToConnector ::=\n     'connector'  '/' Ident MaybePort \n  ;\n\nrule DefineConnector ::=\n    ( DocComment ) ?   'define'  'connector' Ident  'from' ConnectorKind ArgsWithEnd \n  ;\n\nrule DefineFlow ::=\n    ( DocComment ) ?   'define'  'flow' Ident DefinitionArgs  'flow' FlowStmts  'end' \n  ;\n\nrule Query ::=\n    ConfigDirectives Stmts \n  | Stmts \n  ;\n\nrule Stmts ::=\n    Stmt  ';' Stmts \n  | Stmt  ';' ?  \n  ;\n\nrule Stmt ::=\n    Use \n  | DefineWindow \n  | DefineOperator \n  | DefineScript \n  | DefinePipeline \n  | CreateOperator \n  | CreateScript \n  | CreatePipeline \n  | CreateStream \n  | OperatorSelect \n  ;\n\nrule DefineWindow ::=\n    ( DocComment ) ?   'define'  'window' Ident  'from' WindowKind CreationWith ( EmbeddedScriptImut ) ?   'end' \n  ;\n\nrule DefineOperator ::=\n    ( DocComment ) ?   'define'  'operator' Ident  'from' OperatorKind ArgsWithEnd \n  ;\n\nrule DefineScript ::=\n    ( DocComment ) ?   'define'  'script' Ident DefinitionArgs EmbeddedScript \n  ;\n\nrule DefinePipeline ::=\n    ( DocComment ) ?   'define'  'pipeline' Ident (  'from' Ports ) ?  (  'into' Ports ) ?  DefinitionArgs Pipeline \n  ;\n\nrule OperatorSelect ::=\n     'select' ComplexExprImut  'from' StreamPort ( WindowClause ) ?  ( WhereClause ) ?  ( GroupByClause ) ?   'into' StreamPort ( HavingClause ) ?  \n  ;\n\nrule CreateStream ::=\n     'create'  'stream' Ident \n  ;\n\nrule CreateScript ::=\n     'create'  'script' Ident CreationWithEnd \n  |  'create'  'script' Ident  'from' ModularTarget CreationWithEnd \n  ;\n\nrule CreateOperator ::=\n     'create'  'operator' Ident CreationWithEnd \n  |  'create'  'operator' Ident  'from' ModularTarget CreationWithEnd \n  ;\n\nrule CreatePipeline ::=\n     'create'  'pipeline' Ident CreationWithEnd \n  |  'create'  'pipeline' Ident  'from' ModularTarget CreationWithEnd \n  ;\n\nrule MaybePort ::=\n    (  '/' Ident ) ?  \n  ;\n\nrule StreamPort ::=\n    Ident MaybePort \n  ;\n\nrule WindowKind ::=\n     'sliding' \n  |  'tumbling' \n  ;\n\nrule WindowClause ::=\n    WindowDefn \n  ;\n\nrule Windows ::=\n    Windows_ \n  ;\n\nrule Windows_ ::=\n    Sep!(Windows_, Window, \",\") \n  ;\n\nrule Window ::=\n    ModularTarget \n  ;\n\nrule WindowDefn ::=\n     '[' Windows  ']' \n  ;\n\nrule WhereClause ::=\n     'where' ComplexExprImut \n  ;\n\nrule HavingClause ::=\n     'having' ComplexExprImut \n  ;\n\nrule GroupByClause ::=\n     'group'  'by' GroupDef \n  ;\n\nrule GroupDef ::=\n    ExprImut \n  |  'set'  '(' GroupDefs  ')' \n  |  'each'  '(' ExprImut  ')' \n  ;\n\nrule GroupDefs ::=\n    GroupDefs_ \n  ;\n\nrule GroupDefs_ ::=\n    Sep!(GroupDefs_, GroupDef, \",\") \n  ;\n\nrule EmbeddedScriptImut ::=\n     'script' EmbeddedScriptContent \n  ;\n\nrule EmbeddedScriptContent ::=\n    ExprImut \n  ;\n\nrule Ports ::=\n    Sep!(Ports, <Ident>, \",\") \n  ;\n\nrule OperatorKind ::=\n    Ident  '::' Ident \n  ;\n\nrule EmbeddedScript ::=\n     'script' TopLevelExprs  'end' \n  ;\n\nrule Pipeline ::=\n     'pipeline' ConfigDirectives ?  PipelineCreateInner  'end' \n  ;\n\nrule PipelineCreateInner ::=\n    Stmt  ';' Stmts \n  | Stmt  ';' ?  \n  ;\n\nrule Script ::=\n    ( ModComment ) ?  TopLevelExprs \n  ;\n\nrule TopLevelExprs ::=\n    TopLevelExpr  ';' TopLevelExprs \n  | TopLevelExpr  ';' ?  \n  ;\n\nrule InnerExprs ::=\n    Expr  ';' InnerExprs \n  | Expr  ';' ?  \n  ;\n\nrule TopLevelExpr ::=\n    Const \n  | FnDefn \n  | Intrinsic \n  | Expr \n  | Use \n  ;\n\nrule Const ::=\n    ( DocComment ) ?   'const' Ident  '=' ComplexExprImut \n  ;\n\nrule Expr ::=\n    SimpleExpr \n  ;\n\nrule SimpleExpr ::=\n    Match \n  | For \n  | Let \n  | Drop \n  | Emit \n  | ExprImut \n  ;\n\nrule AlwaysImutExpr ::=\n    Patch \n  | Merge \n  | Invoke \n  | Literal \n  | Path \n  | Record \n  | List \n  | StringLiteral \n  | BytesLiteral \n  | Recur \n  ;\n\nrule Recur ::=\n     'recur'  '('  ')' \n  |  'recur'  '(' InvokeArgs  ')' \n  ;\n\nrule ExprImut ::=\n    OrExprImut \n  ;\n\nrule OrExprImut ::=\n    BinOp!(BinOr, ExprImut, XorExprImut) \n  | XorExprImut \n  ;\n\nrule XorExprImut ::=\n    BinOp!(BinXor, XorExprImut, AndExprImut) \n  | AndExprImut \n  ;\n\nrule AndExprImut ::=\n    BinOp!(BinAnd, AndExprImut, BitOrExprImut) \n  | BitOrExprImut \n  ;\n\nrule BitOrExprImut ::=\n    BitXorExprImut \n  ;\n\nrule BitXorExprImut ::=\n    BinOp!(BinBitXor, BitXorExprImut, BitAndExprImut) \n  | BitAndExprImut \n  ;\n\nrule BitAndExprImut ::=\n    BinOp!(BinBitAnd, BitAndExprImut, EqExprImut) \n  | EqExprImut \n  ;\n\nrule EqExprImut ::=\n    BinOp!(BinEq, EqExprImut, CmpExprImut) \n  | CmpExprImut \n  ;\n\nrule CmpExprImut ::=\n    BinOp!(BinCmp, CmpExprImut, BitShiftExprImut) \n  | BitShiftExprImut \n  ;\n\nrule BitShiftExprImut ::=\n    BinOp!(BinBitShift, BitShiftExprImut, AddExprImut) \n  | AddExprImut \n  ;\n\nrule AddExprImut ::=\n    BinOp!(BinAdd, AddExprImut, MulExprImut) \n  | MulExprImut \n  ;\n\nrule MulExprImut ::=\n    BinOp!(BinMul, MulExprImut, UnaryExprImut) \n  | UnaryExprImut \n  ;\n\nrule UnaryExprImut ::=\n     '+' UnaryExprImut \n  |  '-' UnaryExprImut \n  | UnarySimpleExprImut \n  ;\n\nrule UnarySimpleExprImut ::=\n     'not' UnarySimpleExprImut \n  |  '!' UnarySimpleExprImut \n  | PresenceSimplExprImut \n  ;\n\nrule PresenceSimplExprImut ::=\n     'present' Path \n  |  'absent' Path \n  | SimpleExprImut \n  ;\n\nrule ComplexExprImut ::=\n    MatchImut \n  | ForImut \n  | ExprImut \n  ;\n\nrule Intrinsic ::=\n    ( DocComment ) ?   'intrinsic'  'fn' Ident  '('  ')'  'as' ModularTarget \n  | ( DocComment ) ?   'intrinsic'  'fn' Ident  '(' FnArgs  ')'  'as' ModularTarget \n  | ( DocComment ) ?   'intrinsic'  'fn' Ident  '(' FnArgs  ','  '.'  '.'  '.'  ')'  'as' ModularTarget \n  | ( DocComment ) ?   'intrinsic'  'fn' Ident  '('  '.'  '.'  '.'  ')'  'as' ModularTarget \n  ;\n\nrule FnDefn ::=\n    ( DocComment ) ?   'fn' Ident  '('  '.'  '.'  '.'  ')'  'with' InnerExprs  'end' \n  | ( DocComment ) ?   'fn' Ident  '(' FnArgs  ','  '.'  '.'  '.'  ')'  'with' InnerExprs  'end' \n  | ( DocComment ) ?   'fn' Ident  '('  ')'  'with' InnerExprs  'end' \n  | ( DocComment ) ?   'fn' Ident  '(' FnArgs  ')'  'with' InnerExprs  'end' \n  | ( DocComment ) ?   'fn' Ident  '('  ')'  'of' FnCases  'end' \n  | ( DocComment ) ?   'fn' Ident  '(' FnArgs  ')'  'of' FnCases  'end' \n  ;\n\nrule FnCases ::=\n    FnCaseClauses FnCaseDefault \n  | FnCaseDefault \n  ;\n\nrule FnCaseDefault ::=\n     'default' Effectors \n  ;\n\nrule FnCase ::=\n     'case'  '(' ArrayPredicatePatterns  ')' WhenClause Effectors \n  ;\n\nrule FnCaseClauses ::=\n    FnCase \n  | FnCaseClauses FnCase \n  ;\n\nrule FnArgs ::=\n    Ident \n  | FnArgs  ',' Ident \n  ;\n\nrule SimpleExprImut ::=\n     '(' ComplexExprImut  ')' \n  | AlwaysImutExpr \n  ;\n\nrule Literal ::=\n    Nil \n  | Bool \n  | Int \n  | Float \n  ;\n\nrule Nil ::=\n     'nil' \n  ;\n\nrule Bool ::=\n     'bool' \n  ;\n\nrule Int ::=\n     'int' \n  ;\n\nrule Float ::=\n     'float' \n  ;\n\nrule StringLiteral ::=\n     'heredoc_start' StrLitElements  'heredoc_end' \n  |  '\\\\' StrLitElements  '\\\\' \n  |  '\\\\'  '\\\\' \n  ;\n\nrule StrLitElements ::=\n    StringPart StrLitElements \n  |  '\\\\\\\\#' StrLitElements \n  |  '#{' ExprImut  '}' StrLitElements \n  | StringPart \n  |  '\\\\\\\\#' \n  |  '#{' ExprImut  '}' \n  ;\n\nrule StringPart ::=\n     'string' \n  |  'heredoc' \n  ;\n\nrule List ::=\n     '[' ListElements  ']' \n  |  '['  ']' \n  ;\n\nrule ListElements ::=\n    ListElements_ \n  ;\n\nrule ListElements_ ::=\n    Sep!(ListElements_, ComplexExprImut, \",\") \n  ;\n\nrule Record ::=\n     '{' Fields  '}' \n  |  '{'  '}' \n  ;\n\nrule Field ::=\n    StringLiteral  ':' ComplexExprImut \n  ;\n\nrule Path ::=\n    MetaPath \n  | EventPath \n  | StatePath \n  | LocalPath \n  | ConstPath \n  | AggrPath \n  | ArgsPath \n  | ExprPath \n  ;\n\nrule ExprPathRoot ::=\n     '(' ComplexExprImut  ')' \n  | Invoke \n  | Record \n  | List \n  ;\n\nrule ExprPath ::=\n    ExprPathRoot PathSegments \n  ;\n\nrule MetaPath ::=\n     '$' Ident PathSegments \n  |  '$' Ident \n  |  '$' \n  ;\n\nrule AggrPath ::=\n     'group' PathSegments \n  |  'group' \n  |  'window' PathSegments \n  |  'window' \n  ;\n\nrule ArgsPath ::=\n     'args' PathSegments \n  |  'args' \n  ;\n\nrule LocalPath ::=\n    Ident PathSegments \n  | Ident \n  ;\n\nrule ConstPath ::=\n    ModPath  '::' LocalPath \n  ;\n\nrule StatePath ::=\n     'state' PathSegments \n  |  'state' \n  ;\n\nrule EventPath ::=\n     'event' PathSegments \n  |  'event' \n  ;\n\nrule PathSegments ::=\n     '.' Ident PathSegments \n  |  '[' Selector  ']' PathSegments \n  |  '[' Selector  ']' \n  |  '.' Ident \n  ;\n\nrule Selector ::=\n    ComplexExprImut  ':' ComplexExprImut \n  | ComplexExprImut \n  ;\n\nrule Invoke ::=\n    FunctionName  '(' InvokeArgs  ')' \n  | FunctionName  '('  ')' \n  ;\n\nrule FunctionName ::=\n    Ident \n  | ModPath  '::' Ident \n  ;\n\nrule ModPath ::=\n    ModPath  '::' Ident \n  | Ident \n  ;\n\nrule InvokeArgs ::=\n    InvokeArgs_ \n  ;\n\nrule InvokeArgs_ ::=\n    Sep!(InvokeArgs_, ComplexExprImut, \",\") \n  ;\n\nrule Drop ::=\n     'drop' \n  ;\n\nrule Emit ::=\n     'emit' ComplexExprImut  '=>' StringLiteral \n  |  'emit' ComplexExprImut \n  |  'emit'  '=>' StringLiteral \n  |  'emit' \n  ;\n\nrule Let ::=\n     'let' Assignment \n  ;\n\nrule Assignment ::=\n    Path  '=' SimpleExpr \n  ;\n\nrule Patch ::=\n     'patch' ComplexExprImut  'of' PatchOperations  'end' \n  ;\n\nrule PatchOperations ::=\n    PatchOperationClause \n  | PatchOperations  ';' PatchOperationClause \n  ;\n\nrule PatchField ::=\n    StringLiteral \n  ;\n\nrule PatchOperationClause ::=\n     'insert' PatchField  '=>' ComplexExprImut \n  |  'upsert' PatchField  '=>' ComplexExprImut \n  |  'update' PatchField  '=>' ComplexExprImut \n  |  'erase' PatchField \n  |  'move' PatchField  '=>' PatchField \n  |  'copy' PatchField  '=>' PatchField \n  |  'merge' PatchField  '=>' ComplexExprImut \n  |  'merge'  '=>' ComplexExprImut \n  |  'default' PatchField  '=>' ComplexExprImut \n  |  'default'  '=>' ComplexExprImut \n  ;\n\nrule Merge ::=\n     'merge' ComplexExprImut  'of' ComplexExprImut  'end' \n  ;\n\nrule For ::=\n     'for' ComplexExprImut  'of' ForCaseClauses  'end' \n  ;\n\nrule ForCaseClauses ::=\n    ForCaseClause \n  | ForCaseClauses ForCaseClause \n  ;\n\nrule ForCaseClause ::=\n     'case'  '(' Ident  ',' Ident  ')' WhenClause Effectors \n  ;\n\nrule ForImut ::=\n     'for' ComplexExprImut  'of' ForCaseClausesImut  'end' \n  ;\n\nrule ForCaseClausesImut ::=\n    ForCaseClauseImut \n  | ForCaseClausesImut ForCaseClauseImut \n  ;\n\nrule ForCaseClauseImut ::=\n     'case'  '(' Ident  ',' Ident  ')' WhenClause EffectorsImut \n  ;\n\nrule Match ::=\n     'match' ComplexExprImut  'of' Predicates  'end' \n  ;\n\nrule Predicates ::=\n    PredicateClause \n  | Predicates PredicateClause \n  ;\n\nrule PredicateClause ::=\n     'case' CasePattern WhenClause Effectors \n  |  'default' Effectors \n  ;\n\nrule Effectors ::=\n     '=>' Block \n  ;\n\nrule Block ::=\n    Expr \n  | Block  ';' Expr \n  ;\n\nrule MatchImut ::=\n     'match' ComplexExprImut  'of' PredicatesImut  'end' \n  ;\n\nrule PredicatesImut ::=\n    PredicateClauseImut \n  | PredicatesImut PredicateClauseImut \n  ;\n\nrule CasePattern ::=\n    RecordPattern \n  | ArrayPattern \n  | TuplePattern \n  | ComplexExprImut \n  |  '_' \n  |  '~' TestExpr \n  | Ident  '=' CasePattern \n  ;\n\nrule PredicateClauseImut ::=\n     'case' CasePattern WhenClause EffectorsImut \n  |  'default' EffectorsImut \n  ;\n\nrule EffectorsImut ::=\n     '=>' BlockImut \n  ;\n\nrule BlockImut ::=\n    ComplexExprImut \n  | BlockImut  ',' ComplexExprImut \n  ;\n\nrule WhenClause ::=\n    (  'when' ComplexExprImut ) ?  \n  ;\n\nrule PredicateFieldPattern ::=\n    Ident  '~=' TestExpr \n  | Ident  '=' Ident  '~=' TestExpr \n  | Ident  '~=' RecordPattern \n  | Ident  '~=' ArrayPattern \n  | Ident  '~=' TuplePattern \n  |  'present' Ident \n  |  'absent' Ident \n  | Ident BinCmpEq ComplexExprImut \n  ;\n\nrule TestExpr ::=\n    Ident TestLiteral \n  ;\n\nrule RecordPattern ::=\n     '%{' PatternFields  '}' \n  |  '%{'  '}' \n  ;\n\nrule ArrayPattern ::=\n     '%[' ArrayPredicatePatterns  ']' \n  |  '%['  ']' \n  ;\n\nrule TuplePattern ::=\n     '%(' TuplePredicatePatterns OpenTuple  ')' \n  |  '%('  ')' \n  |  '%('  '.'  '.'  '.'  ')' \n  ;\n\nrule OpenTuple ::=\n    (  ','  '.'  '.'  '.' ) ?  \n  ;\n\nrule TuplePredicatePatterns ::=\n    TuplePredicatePatterns  ',' TuplePredicatePattern \n  | TuplePredicatePattern \n  ;\n\nrule TuplePredicatePattern ::=\n    ArrayPredicatePattern \n  ;\n\nrule ArrayPredicatePattern ::=\n     '~' TestExpr \n  |  '_' \n  | ComplexExprImut \n  | RecordPattern \n  ;\n\nrule ArrayPredicatePatterns ::=\n    ArrayPredicatePatterns  ',' ArrayPredicatePattern \n  | ArrayPredicatePattern \n  ;\n\nrule PatternFields ::=\n    PatternFields_ \n  ;\n\nrule PatternFields_ ::=\n    Sep!(PatternFields_, PredicateFieldPattern, \",\") \n  ;\n\nrule Fields ::=\n    Fields_ \n  ;\n\nrule Fields_ ::=\n    Sep!(Fields_, Field, \",\") \n  ;\n\nrule Ident ::=\n     '<ident>' \n  ;\n\nrule TestLiteral ::=\n     '<extractor>' \n  ;\n\nrule BytesLiteral ::=\n     '<<'  '>>' \n  |  '<<' Bytes  '>>' \n  ;\n\nrule Bytes ::=\n    BytesPart \n  | Bytes  ',' BytesPart \n  ;\n\nrule BytesPart ::=\n    SimpleExprImut \n  | SimpleExprImut  ':'  'int' \n  | SimpleExprImut  '/' Ident \n  | SimpleExprImut  ':'  'int'  '/' Ident \n  ;\n\nmacro Sep<L, T, D> ::=\n    T D L \n  | T D ?  \n  ;\n\nmacro BinOp<Op, Current, Next> ::=\n    ( Current ) ( Op ) Next \n  ;\n\nrule BinCmpEq ::=\n    BinEq \n  | BinCmp \n  ;\n\nrule BinOr ::=\n     'or' \n  ;\n\nrule BinXor ::=\n     'xor' \n  ;\n\nrule BinAnd ::=\n     'and' \n  ;\n\nrule BinBitXor ::=\n     '^' \n  ;\n\nrule BinBitAnd ::=\n     '&' \n  ;\n\nrule BinEq ::=\n     '==' \n  |  '!=' \n  ;\n\nrule BinCmp ::=\n     '>=' \n  |  '>' \n  |  '<=' \n  |  '<' \n  ;\n\nrule BinBitShift ::=\n     '>>' \n  |  '>>>' \n  |  '<<' \n  ;\n\nrule BinAdd ::=\n     '+' \n  |  '-' \n  ;\n\nrule BinMul ::=\n     '*' \n  |  '/' \n  |  '%' \n  ;\n\n")))}d.isMDXComponent=!0}}]);